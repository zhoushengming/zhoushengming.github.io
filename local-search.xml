<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>做技术预研的一些想法</title>
    <link href="/2020/11/20/%E5%81%9A%E6%8A%80%E6%9C%AF%E9%A2%84%E7%A0%94%E7%9A%84%E4%B8%80%E4%BA%9B%E6%83%B3%E6%B3%95/"/>
    <url>/2020/11/20/%E5%81%9A%E6%8A%80%E6%9C%AF%E9%A2%84%E7%A0%94%E7%9A%84%E4%B8%80%E4%BA%9B%E6%83%B3%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<blockquote><p>技术预研（Technical Pre-Research, TPR）是指在立项之后到开发工作完成之前的时间内，对项目将采用的关键技术提前学习和研究，以便尽可能早地发现并解决开发过程中将会遇到的技术障碍。</p></blockquote><a id="more"></a><h3 id="了解需求"><a href="#了解需求" class="headerlink" title="了解需求"></a>了解需求</h3><p>这块是预研的第一步，我们需要向需求方了解要实现什么功能？实现什么效果？给用户带来什么好处？能不能真正的解决问题？会不会产生什么不良的影响？这个需求的难点是什么？为这个需求要付出多大的代价（开发成本、沟通成本、机器、钱）？这个需求的性价比如何？这个需求是否违法？可能在这一步中，我们就可以把一些价值不大或者违法的需求扼杀在摇篮里。</p><h3 id="充分理解需求"><a href="#充分理解需求" class="headerlink" title="充分理解需求"></a>充分理解需求</h3><p>一切技术都是为了产品服务的，没有产品技术一文不值。我们要真正地从产品角度去思考，去理解产品经理到底要做什么；我们还要从用户的角度出发，去思考用户需要什么样的功能。这两点都可以帮助我们充分地理解需求。</p><h3 id="需求的分解"><a href="#需求的分解" class="headerlink" title="需求的分解"></a>需求的分解</h3><p>在充分了解技术背景后，和产品沟通，了解可能的产品形态。需要尽量多的列举出不同的产品形态，然后将需求进行小粒度的分解。</p><h3 id="预研的顺序"><a href="#预研的顺序" class="headerlink" title="预研的顺序"></a>预研的顺序</h3><p>对需求分解成一个个小的技术点，并对每个技术点的相互依赖关系进行排序，预研应该先研究被依赖的技术点，而不是最难的技术点。当然，工程师可以凭借自己的经验来判断某技术点是否需要预研。所以说经验越多的工程师，预研的速度越快。</p><h3 id="对于依赖方的验证"><a href="#对于依赖方的验证" class="headerlink" title="对于依赖方的验证"></a>对于依赖方的验证</h3><p>我们对自己的技术能有一个整体的把握，能有一定的信心。但是对依赖方（第三方）的技术就不一定了，所以我们要对依赖方做一个充分的技术验证，这块也是非常的重要。我们需要尽早的发现问题，如果需要依赖方去修改，这块的周期是非常长的，如果依赖方不配合修改，整个方案可能因此不通，很可能导致整个方案失败。具体的验证方式可以参照下面“技术方案的验证”。</p><h3 id="多种技术方案的比较"><a href="#多种技术方案的比较" class="headerlink" title="多种技术方案的比较"></a>多种技术方案的比较</h3><p>对于一个功能，可能存在着多种实现方式，所以说我们需要将不同方案的优缺点弄清楚，并形成文档，并从工程师的角度给出自己推荐的方式，并说明自己的理由。对于不同方案的优缺点，一定要保持一种客观的态度，尽量通过多个维度去比较各种方案，比如：实现的难易程度、对性能的影响、对三方的依赖、资金成本、兼容性问题、是否存在体验上的偏差、稳定性。</p><h3 id="技术方案的验证"><a href="#技术方案的验证" class="headerlink" title="技术方案的验证"></a>技术方案的验证</h3><p>我们要尽早暴露技术方案的问题，一些致命的问题可能会导致整个方案失败。<br>我们可以从以下方面去找到问题：</p><blockquote><p>基本功能的坑<br>稳定性问题<br>性能的坑<br>压力测试<br>不同机型/平台/硬件的坑<br>兼容性问题<br>依赖方/耦合程度问题</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>技术预研</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android监控Java层的网络打印</title>
    <link href="/2020/10/24/Android%E7%9B%91%E6%8E%A7Java%E5%B1%82%E7%9A%84%E7%BD%91%E7%BB%9C%E6%89%93%E5%8D%B0/"/>
    <url>/2020/10/24/Android%E7%9B%91%E6%8E%A7Java%E5%B1%82%E7%9A%84%E7%BD%91%E7%BB%9C%E6%89%93%E5%8D%B0/</url>
    
    <content type="html"><![CDATA[<!-- abstract area --><p>由于一个特殊的需求，检测应用有没有在联网，于是我尝试写了这个工具。需要声明一点，我这个工具需要自己重新编译ROM。</p><a id="more"></a><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>其实很简单，APP需要访问网络时，需要调用Java层的接口</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">// 请求的地址</span>String spec = <span class="hljs-string">"http://localhost:9090/formTest"</span>;<span class="hljs-comment">// 根据地址创建URL对象</span>URL url = <span class="hljs-keyword">new</span> URL(spec);<span class="hljs-comment">// 根据URL对象打开链接</span>HttpURLConnection urlConnection = (HttpURLConnection) url                    .openConnection();</code></pre></div><p>所以我们在URL#openConnection()中，添加自己的监控逻辑即可。<br>可以看到<code>java.net.URL</code>是在jrt中的，也就是java的运行环境中的，所以我们需要修改jrt的东西。<br>经过一些查询我知道了Android的libcore和ojluni。</p><h2 id="ojluni"><a href="#ojluni" class="headerlink" title="ojluni"></a>ojluni</h2><p>ojluni就是OpenJDK, java.lang / java.util / java.net / java.io 的缩写，就是OpenJDK核心库的意思。ojluni在libcore目录下。<br>有兴趣的同学可以在<code><a href="http://androidxref.com/9.0.0_r3/xref/libcore/" target="_blank" rel="noopener">http://androidxref.com/9.0.0_r3/xref/libcore/</a></code>查看所有的源码</p><h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><p>接下来我们需要修改ojluni下的URL的源码，需要先下载libcore项目，找到URL.java的位置：</p><div class="hljs"><pre><code class="hljs awk">libcore<span class="hljs-regexp">/ojluni/</span>src<span class="hljs-regexp">/main/</span>java<span class="hljs-regexp">/java/</span>net<span class="hljs-regexp">/URL.java</span></code></pre></div><p>在openConnection()方法中添加日志打印，并且将日志保存下来</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> URLConnection <span class="hljs-title">openConnection</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> java.io.IOException </span>&#123;       java.util.SeempLog.record_str(<span class="hljs-number">91</span>, <span class="hljs-string">"URL:"</span> + query);       logHttpUrlByLocalSocket();  <span class="hljs-comment">// 添加此行，记录上层应用访问网络的情况</span>       <span class="hljs-keyword">return</span> handler.openConnection(<span class="hljs-keyword">this</span>);   &#125;</code></pre></div><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/** 记录访问网络的应用PID/UID/TID/进程名称和调用栈 */</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">logHttpUrlByLocalSocket</span><span class="hljs-params">()</span> </span>&#123;    String url = String.format(<span class="hljs-string">"%s://%s%s?%s"</span>, protocol, authority, path, query);    String lineData = String.format(<span class="hljs-string">"%s#pid:%s#uid:%s#tid:%s#cmdline:%s#%s\n"</span>,             System.currentTimeMillis(), getPid(), getUid(), getTid(), getCmdline(getPid()), url.trim());    String callStack = getCallStack();    File file = <span class="hljs-keyword">new</span> File(<span class="hljs-string">"sdcard/Download/http.txt"</span>);    <span class="hljs-keyword">try</span> &#123;        <span class="hljs-keyword">if</span> (!file.exists()) &#123;            file.createNewFile();        &#125;    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;        e.printStackTrace();    &#125;    <span class="hljs-keyword">try</span> (RandomAccessFile raf = <span class="hljs-keyword">new</span> RandomAccessFile(file, <span class="hljs-string">"rwd"</span>)) &#123;        raf.seek(file.length());        raf.write(lineData.getBytes());        raf.write(callStack.getBytes());        raf.write(<span class="hljs-string">"\n"</span>.getBytes());    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;        e.printStackTrace();    &#125;&#125;<span class="hljs-comment">/** 获取pid对应的进程名称 */</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">getCmdline</span><span class="hljs-params">(<span class="hljs-keyword">int</span> pid)</span> </span>&#123;    FileReader in = <span class="hljs-keyword">null</span>;    BufferedReader reader = <span class="hljs-keyword">null</span>;    String result = <span class="hljs-keyword">null</span>;    <span class="hljs-keyword">try</span> &#123;        File file = <span class="hljs-keyword">new</span> File(<span class="hljs-string">"/proc/"</span> + pid + <span class="hljs-string">"/cmdline"</span>);        in = <span class="hljs-keyword">new</span> FileReader(file);        reader = <span class="hljs-keyword">new</span> BufferedReader(in);        String line = reader.readLine();        <span class="hljs-keyword">if</span> (line != <span class="hljs-keyword">null</span>) &#123;            result = line.replace(<span class="hljs-string">"\0"</span>, <span class="hljs-string">""</span>);        &#125;    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;        e.printStackTrace();    &#125; <span class="hljs-keyword">finally</span> &#123;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">if</span> (in != <span class="hljs-keyword">null</span>) &#123;                in.close();            &#125;        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            e.printStackTrace();        &#125;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">if</span> (reader != <span class="hljs-keyword">null</span>) &#123;                reader.close();            &#125;        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            e.printStackTrace();        &#125;    &#125;    <span class="hljs-keyword">if</span> (result == <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">"null"</span>;    &#125;    <span class="hljs-keyword">return</span> result;&#125;<span class="hljs-comment">/** 反射获取PID */</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getPid</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">try</span> &#123;        Object pid = callStaticObjectMethod(Class.forName(<span class="hljs-string">"android.os.Process"</span>), <span class="hljs-string">"myPid"</span>, <span class="hljs-keyword">null</span>);        <span class="hljs-keyword">if</span> (pid != <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">return</span> (<span class="hljs-keyword">int</span>) pid;        &#125;    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;        e.printStackTrace();    &#125;    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;&#125;<span class="hljs-comment">/** 反射获取UID */</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getUid</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">try</span> &#123;        Object pid = callStaticObjectMethod(Class.forName(<span class="hljs-string">"android.os.Process"</span>), <span class="hljs-string">"myUid"</span>, <span class="hljs-keyword">null</span>);        <span class="hljs-keyword">if</span> (pid != <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">return</span> (<span class="hljs-keyword">int</span>) pid;        &#125;    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;        e.printStackTrace();    &#125;    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;&#125;<span class="hljs-comment">/** 反射获取TID */</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getTid</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">try</span> &#123;        Object pid = callStaticObjectMethod(Class.forName(<span class="hljs-string">"android.os.Process"</span>), <span class="hljs-string">"myTid"</span>, <span class="hljs-keyword">null</span>);        <span class="hljs-keyword">if</span> (pid != <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">return</span> (<span class="hljs-keyword">int</span>) pid;        &#125;    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;        e.printStackTrace();    &#125;    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;&#125;<span class="hljs-comment">/** 获取调用栈 */</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">getCallStack</span><span class="hljs-params">()</span> </span>&#123;    StackTraceElement[] stackTrace = <span class="hljs-keyword">new</span> Throwable().fillInStackTrace().getStackTrace();    StringBuffer callStack = <span class="hljs-keyword">new</span> StringBuffer();    callStack.append(<span class="hljs-string">"callStack:"</span>);    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; stackTrace.length; i++) &#123;        callStack.append(stackTrace[i].toString());        callStack.append(<span class="hljs-string">"\n"</span>);    &#125;    <span class="hljs-keyword">return</span> callStack.toString();&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title">callObjectMethod</span><span class="hljs-params">(Object target, String method, Class&lt;?&gt;[] parameterTypes, Object... values)</span></span><span class="hljs-function">        <span class="hljs-keyword">throws</span> NoSuchMethodException, SecurityException, IllegalAccessException, IllegalArgumentException, InvocationTargetException </span>&#123;    Class&lt;? extends Object&gt; clazz = target.getClass();    Method declaredMethod = clazz.getDeclaredMethod(method, parameterTypes);    declaredMethod.setAccessible(<span class="hljs-keyword">true</span>);    <span class="hljs-keyword">return</span> declaredMethod.invoke(target, values);&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title">callStaticObjectMethod</span><span class="hljs-params">(Class&lt;?&gt; clazz, String method, Class&lt;?&gt;[] parameterTypes, Object... values)</span></span><span class="hljs-function">        <span class="hljs-keyword">throws</span> NoSuchMethodException, SecurityException, IllegalAccessException, IllegalArgumentException, InvocationTargetException </span>&#123;    Method declaredMethod = clazz.getDeclaredMethod(method, parameterTypes);    declaredMethod.setAccessible(<span class="hljs-keyword">true</span>);    <span class="hljs-keyword">return</span> declaredMethod.invoke(<span class="hljs-keyword">null</span>, values);&#125;</code></pre></div><p>以上就是整个功能。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Android</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android View的绘制</title>
    <link href="/2020/08/08/Android-View%E7%9A%84%E7%BB%98%E5%88%B6/"/>
    <url>/2020/08/08/Android-View%E7%9A%84%E7%BB%98%E5%88%B6/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Android View的测量</title>
    <link href="/2020/07/31/Android-view%E7%9A%84%E6%B5%8B%E9%87%8F/"/>
    <url>/2020/07/31/Android-view%E7%9A%84%E6%B5%8B%E9%87%8F/</url>
    
    <content type="html"><![CDATA[<p>todo</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Android动画原理</title>
    <link href="/2020/07/28/Android%E5%8A%A8%E7%94%BB%E5%8E%9F%E7%90%86/"/>
    <url>/2020/07/28/Android%E5%8A%A8%E7%94%BB%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p>动画很炫酷，小小的脑袋，大大的疑惑。<br>– 到底为什么属性动画后， View在新位置还能响应事件</p><a id="more"></a><h1 id="View-Animation"><a href="#View-Animation" class="headerlink" title="View Animation"></a>View Animation</h1><p>View 动画也就是补间动画</p><h1 id="Property-Animation"><a href="#Property-Animation" class="headerlink" title="Property Animation"></a>Property Animation</h1><p>属性动画</p><blockquote><p>参考：<a href="https://juejin.im/post/5d137218e51d4555fd20a36d" target="_blank" rel="noopener">https://juejin.im/post/5d137218e51d4555fd20a36d</a><br>参考：<a href="https://juejin.im/entry/6844903465211133959" target="_blank" rel="noopener">https://juejin.im/entry/6844903465211133959</a></p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HashMap实现原理</title>
    <link href="/2020/07/28/HashMap%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    <url>/2020/07/28/HashMap%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p>这是一个面试经常会问到的问题。<br>底层原理是数组和链表，JDK 8以后添加了红黑树。<br>了解原理前，需要先了解以下概念：</p><p>hashCode, equals, 取模运算, 数组, 链表, 还有一些位运算</p><a id="more"></a><h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><p>分析原理最好使用能查看堆栈信息的工具，我这里用了idea的debug功能。如果你直接使用idea的debug是无法直接查看真实的map，因为idea为了更加直观的展示map中的数据，做了专门的优化，一开始你看的是这样的：</p><p><img src="/img/WX20200804-205407@2x.png" srcset="/img/loading.gif" alt=""></p><p>我们需要修改一下设置，在settings中搜索debug，找到data views-&gt;java, 然后可以看到这个，我们需要把那个Enable alternative view for Collections classes 关掉，这样就可以看到map的真是结构了。</p><p><img src="/img/Enable_alternative_view_for_Collections_classes.png" srcset="/img/loading.gif" alt=""></p><p><img src="/img/WX20200804-210431@2x.png" srcset="/img/loading.gif" alt=""></p><h2 id="hashMap分析"><a href="#hashMap分析" class="headerlink" title="hashMap分析"></a>hashMap分析</h2><p>我们最常用的就是put方法，向hashMap中put数据。</p><div class="hljs"><pre><code class="hljs arduino">HashMap&lt;<span class="hljs-keyword">String</span>, Integer&gt; <span class="hljs-built_in">map</span> = <span class="hljs-keyword">new</span> HashMap&lt;<span class="hljs-keyword">String</span>, Integer&gt;();<span class="hljs-built_in">map</span>.<span class="hljs-built_in">put</span>(<span class="hljs-string">"语文"</span>, <span class="hljs-number">1</span>);<span class="hljs-built_in">map</span>.<span class="hljs-built_in">put</span>(<span class="hljs-string">"数学"</span>, <span class="hljs-number">2</span>);<span class="hljs-built_in">map</span>.<span class="hljs-built_in">put</span>(<span class="hljs-string">"英语"</span>, <span class="hljs-number">3</span>);<span class="hljs-built_in">map</span>.<span class="hljs-built_in">put</span>(<span class="hljs-string">"历史"</span>, <span class="hljs-number">4</span>);<span class="hljs-built_in">map</span>.<span class="hljs-built_in">put</span>(<span class="hljs-string">"政治"</span>, <span class="hljs-number">5</span>);<span class="hljs-built_in">map</span>.<span class="hljs-built_in">put</span>(<span class="hljs-string">"地理"</span>, <span class="hljs-number">6</span>);<span class="hljs-built_in">map</span>.<span class="hljs-built_in">put</span>(<span class="hljs-string">"生物"</span>, <span class="hljs-number">7</span>);<span class="hljs-built_in">map</span>.<span class="hljs-built_in">put</span>(<span class="hljs-string">"化学"</span>, <span class="hljs-number">8</span>);<span class="hljs-keyword">for</span> (Map.Entry&lt;<span class="hljs-keyword">String</span>, Integer&gt; entry : <span class="hljs-built_in">map</span>.entrySet()) &#123;    System.out.<span class="hljs-built_in">println</span>(entry.<span class="hljs-built_in">getKey</span>() + <span class="hljs-string">": "</span> + entry.getValue());&#125;</code></pre></div><p>我们来看一下内存的情况：</p><p><img src="/img/WX20200804-211033.png" srcset="/img/loading.gif" alt=""></p><h3 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h3><p>我们发现数据都存在了一个table的数组里，table的声明为：<code>transient Node<K,V>[] table;</code>, 它是一个数组，数组的类型为Node。我们来看一下：</p><div class="hljs"><pre><code class="hljs arduino"><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span>&lt;K,V&gt; <span class="hljs-title">implements</span> <span class="hljs-title">Map</span>.<span class="hljs-title">Entry</span>&lt;K,V&gt; &#123;</span>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> hash;  <span class="hljs-comment">// 是指Key的hash值，算法是key的hashCode高16位与低16位相与，为了降低hash冲突、碰撞</span>    <span class="hljs-keyword">final</span> K key;    V value;    Node&lt;K,V&gt; next;  <span class="hljs-comment">// next，为链表的特性</span>    Node(<span class="hljs-keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;        <span class="hljs-keyword">this</span>.hash = hash;        <span class="hljs-keyword">this</span>.key = key;        <span class="hljs-keyword">this</span>.value = value;        <span class="hljs-keyword">this</span>.next = next;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> K <span class="hljs-title">getKey</span><span class="hljs-params">()</span>        </span>&#123; <span class="hljs-keyword">return</span> key; &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> V <span class="hljs-title">getValue</span><span class="hljs-params">()</span>      </span>&#123; <span class="hljs-keyword">return</span> value; &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">String</span> <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> key + <span class="hljs-string">"="</span> + value; &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hashCode</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> V <span class="hljs-title">setValue</span><span class="hljs-params">(V newValue)</span> </span>&#123;        V oldValue = value;        value = newValue;        <span class="hljs-keyword">return</span> oldValue;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object o)</span> </span>&#123; <span class="hljs-comment">// 会比较k v的equals</span>        <span class="hljs-keyword">if</span> (o == <span class="hljs-keyword">this</span>)            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;        <span class="hljs-keyword">if</span> (o instanceof Map.Entry) &#123;            Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;            <span class="hljs-keyword">if</span> (Objects.equals(key, e.<span class="hljs-built_in">getKey</span>()) &amp;&amp;                Objects.equals(value, e.getValue()))                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    &#125;&#125;</code></pre></div><h3 id="resize"><a href="#resize" class="headerlink" title="resize()"></a>resize()</h3><p>上边看到table的大小为16，这里是为什么呢？通过查找赋值过程，我找到了resize方法：</p><div class="hljs"><pre><code class="hljs haxe">final Node&lt;K,V&gt;[] resize() &#123;    Node&lt;K,V&gt;[] oldTab = table;    int oldCap = (oldTab == <span class="hljs-literal">null</span>) ? <span class="hljs-number">0</span> : <span class="hljs-type">oldTab</span>.length;    int oldThr = threshold;    int <span class="hljs-keyword">new</span><span class="hljs-type">Cap</span>, <span class="hljs-keyword">new</span><span class="hljs-type">Thr</span> = <span class="hljs-number">0</span>;    <span class="hljs-keyword">if</span> (oldCap &gt; <span class="hljs-number">0</span>) &#123;    <span class="hljs-comment">// 超过最大值就不再扩充了，就只好随你碰撞去吧</span>        <span class="hljs-keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;            threshold = Integer.MAX_VALUE;            <span class="hljs-keyword">return</span> oldTab;        &#125;        <span class="hljs-comment">// 没超过最大值，就扩充为原来的2倍</span>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((<span class="hljs-keyword">new</span><span class="hljs-type">Cap</span> = oldCap &lt;&lt; <span class="hljs-number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)            <span class="hljs-keyword">new</span><span class="hljs-type">Thr</span> = oldThr &lt;&lt; <span class="hljs-number">1</span>; <span class="hljs-comment">// double threshold</span>    &#125;    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (oldThr &gt; <span class="hljs-number">0</span>) <span class="hljs-comment">// initial capacity was placed in threshold</span>        <span class="hljs-keyword">new</span><span class="hljs-type">Cap</span> = oldThr;    <span class="hljs-keyword">else</span> &#123;               <span class="hljs-comment">// zero initial threshold signifies using defaults</span>        <span class="hljs-keyword">new</span><span class="hljs-type">Cap</span> = DEFAULT_INITIAL_CAPACITY; <span class="hljs-comment">// 默认16</span>        <span class="hljs-keyword">new</span><span class="hljs-type">Thr</span> = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);  <span class="hljs-comment">// 0.75*16 = 12 触发扩容的临界值</span>    &#125;    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">new</span><span class="hljs-type">Thr</span> == <span class="hljs-number">0</span>) &#123;        float ft = (float)<span class="hljs-keyword">new</span><span class="hljs-type">Cap</span> * loadFactor;        <span class="hljs-keyword">new</span><span class="hljs-type">Thr</span> = (<span class="hljs-keyword">new</span><span class="hljs-type">Cap</span> &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?                  (int)ft : <span class="hljs-type">Integer</span>.MAX_VALUE);    &#125;    threshold = <span class="hljs-keyword">new</span><span class="hljs-type">Thr</span>;  <span class="hljs-comment">// 触发扩容的临界值</span>    @SuppressWarnings(&#123;<span class="hljs-string">"rawtypes"</span>,<span class="hljs-string">"unchecked"</span>&#125;)        Node&lt;K,V&gt;[] <span class="hljs-keyword">new</span><span class="hljs-type">Tab</span> = (Node&lt;K,V&gt;[])<span class="hljs-keyword">new</span> <span class="hljs-type">Node</span>[<span class="hljs-keyword">new</span><span class="hljs-type">Cap</span>];  <span class="hljs-comment">// 创建table</span>    table = <span class="hljs-keyword">new</span><span class="hljs-type">Tab</span>;    <span class="hljs-keyword">if</span> (oldTab != <span class="hljs-literal">null</span>) &#123;  <span class="hljs-comment">// 迁移旧table数据</span>        <span class="hljs-keyword">for</span> (int j = <span class="hljs-number">0</span>; j &lt; oldCap; ++j) &#123;            Node&lt;K,V&gt; e;            <span class="hljs-keyword">if</span> ((e = oldTab[j]) != <span class="hljs-literal">null</span>) &#123;                oldTab[j] = <span class="hljs-literal">null</span>;  <span class="hljs-comment">// 释放内存</span>                <span class="hljs-keyword">if</span> (e.next == <span class="hljs-literal">null</span>)                    <span class="hljs-keyword">new</span><span class="hljs-type">Tab</span>[e.hash &amp; (<span class="hljs-keyword">new</span><span class="hljs-type">Cap</span> - <span class="hljs-number">1</span>)] = e;  <span class="hljs-comment">// 与table大小-1相与，得到新的index</span>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (e instanceof TreeNode) <span class="hljs-comment">// 拆分树形的node</span>                    ((TreeNode&lt;K,V&gt;)e).split(<span class="hljs-built_in">this</span>, <span class="hljs-keyword">new</span><span class="hljs-type">Tab</span>, j, oldCap);                <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// preserve order   // 拆分链表形的node</span>                    Node&lt;K,V&gt; loHead = <span class="hljs-literal">null</span>, loTail = <span class="hljs-literal">null</span>;                    Node&lt;K,V&gt; hiHead = <span class="hljs-literal">null</span>, hiTail = <span class="hljs-literal">null</span>;                    Node&lt;K,V&gt; next;                    <span class="hljs-keyword">do</span> &#123;                        next = e.next;                        <span class="hljs-keyword">if</span> ((e.hash &amp; oldCap) == <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 这种情况下，node还在原来的index下</span>                            <span class="hljs-keyword">if</span> (loTail == <span class="hljs-literal">null</span>)                                loHead = e;                            <span class="hljs-keyword">else</span>                                loTail.next = e;                            loTail = e;                        &#125;                        <span class="hljs-keyword">else</span> &#123;     <span class="hljs-comment">// 这种情况下，node还在原来的index+j下</span>                            <span class="hljs-keyword">if</span> (hiTail == <span class="hljs-literal">null</span>)                                hiHead = e;                            <span class="hljs-keyword">else</span>                                hiTail.next = e;                            hiTail = e;                        &#125;                    &#125; <span class="hljs-keyword">while</span> ((e = next) != <span class="hljs-literal">null</span>);                    <span class="hljs-keyword">if</span> (loTail != <span class="hljs-literal">null</span>) &#123;                        loTail.next = <span class="hljs-literal">null</span>;                        <span class="hljs-keyword">new</span><span class="hljs-type">Tab</span>[j] = loHead;                    &#125;                    <span class="hljs-keyword">if</span> (hiTail != <span class="hljs-literal">null</span>) &#123;                        hiTail.next = <span class="hljs-literal">null</span>;                        <span class="hljs-keyword">new</span><span class="hljs-type">Tab</span>[j + oldCap] = hiHead;                    &#125;                &#125;            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span><span class="hljs-type">Tab</span>;&#125;</code></pre></div><p>以上就是table的创建以及扩容的过程，我们可以看到默认大小是16，扩容是以二倍的方式去扩容的，而开始扩容的时机为达到容量的0.75。<br>扩容过程中，会把就数据复制到新的table中，这里分为三种情况:node无next、next为树形、next为链式。</p><h3 id="put"><a href="#put" class="headerlink" title="put()"></a>put()</h3><p>我们在看一下put的实现：</p><div class="hljs"><pre><code class="hljs processing"><span class="hljs-keyword">public</span> V put(K <span class="hljs-built_in">key</span>, V value) &#123;    <span class="hljs-keyword">return</span> putVal(hash(<span class="hljs-built_in">key</span>), <span class="hljs-built_in">key</span>, value, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">true</span>);&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * Implements Map.put and related methods</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * @param hash hash for key</span><span class="hljs-comment"> * @param key the key</span><span class="hljs-comment"> * @param value the value to put</span><span class="hljs-comment"> * @param onlyIfAbsent if true, don't change existing value  如果为true，这不会改变现有值</span><span class="hljs-comment"> * @param evict if false, the table is in creation mode.</span><span class="hljs-comment"> * @return previous value, or null if none</span><span class="hljs-comment"> */</span><span class="hljs-keyword">final</span> V putVal(<span class="hljs-built_in">int</span> hash, K <span class="hljs-built_in">key</span>, V value, <span class="hljs-built_in">boolean</span> onlyIfAbsent,               <span class="hljs-built_in">boolean</span> evict) &#123;    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="hljs-built_in">int</span> n, i;  <span class="hljs-comment">// n为table大小</span>    <span class="hljs-keyword">if</span> ((tab = table) == <span class="hljs-keyword">null</span> || (n = tab.length) == <span class="hljs-number">0</span>)        n = (tab = resize()).length;  <span class="hljs-comment">// 创建新的table</span>    <span class="hljs-keyword">if</span> ((p = tab[i = (n - <span class="hljs-number">1</span>) &amp; hash]) == <span class="hljs-keyword">null</span>)  <span class="hljs-comment">// 获取index，并将index位置的node赋给p， (n - 1) &amp; hash  会得到一个0~(n-1的数)，其实可以理解成hash%(n-1)</span>        tab[i] = newNode(hash, <span class="hljs-built_in">key</span>, value, <span class="hljs-keyword">null</span>);  <span class="hljs-comment">// 该index下 无数据，直接赋值</span>    <span class="hljs-keyword">else</span> &#123;        Node&lt;K,V&gt; e; K k;        <span class="hljs-keyword">if</span> (p.hash == hash &amp;&amp;            ((k = p.<span class="hljs-built_in">key</span>) == <span class="hljs-built_in">key</span> || (<span class="hljs-built_in">key</span> != <span class="hljs-keyword">null</span> &amp;&amp; <span class="hljs-built_in">key</span>.equals(k))))  <span class="hljs-comment">// 存在相同的key，接下来会进行替换</span>            e = p;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p <span class="hljs-keyword">instanceof</span> TreeNode)  <span class="hljs-comment">// 头部节点为树</span>            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="hljs-keyword">this</span>, tab, hash, <span class="hljs-built_in">key</span>, value);        <span class="hljs-keyword">else</span> &#123;      <span class="hljs-comment">// 头部节点为链表</span>            <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> binCount = <span class="hljs-number">0</span>; ; ++binCount) &#123;                <span class="hljs-keyword">if</span> ((e = p.next) == <span class="hljs-keyword">null</span>) &#123;                    p.next = newNode(hash, <span class="hljs-built_in">key</span>, value, <span class="hljs-keyword">null</span>);  <span class="hljs-comment">// 新建node 插入尾部</span>                    <span class="hljs-keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="hljs-number">1</span>) <span class="hljs-comment">// -1 for 1st</span>                        treeifyBin(tab, hash);  <span class="hljs-comment">// &gt;=7时，转换为树 </span>                    <span class="hljs-keyword">break</span>;                &#125;                <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp;                    ((k = e.<span class="hljs-built_in">key</span>) == <span class="hljs-built_in">key</span> || (<span class="hljs-built_in">key</span> != <span class="hljs-keyword">null</span> &amp;&amp; <span class="hljs-built_in">key</span>.equals(k))))  <span class="hljs-comment">// key相同，更新value</span>                    <span class="hljs-keyword">break</span>;                p = e;            &#125;        &#125;        <span class="hljs-keyword">if</span> (e != <span class="hljs-keyword">null</span>) &#123; <span class="hljs-comment">// existing mapping for key</span>            V oldValue = e.value;            <span class="hljs-keyword">if</span> (!onlyIfAbsent || oldValue == <span class="hljs-keyword">null</span>)                e.value = value;            afterNodeAccess(e);  <span class="hljs-comment">// linkedHashmap利用这个排序</span>            <span class="hljs-keyword">return</span> oldValue;        &#125;    &#125;    ++modCount;    <span class="hljs-keyword">if</span> (++<span class="hljs-built_in">size</span> &gt; threshold)        resize();  <span class="hljs-comment">//  是否需要扩容</span>    afterNodeInsertion(evict);  <span class="hljs-comment">// linkedHashmap利用这个排序</span>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;&#125;</code></pre></div><h3 id="get"><a href="#get" class="headerlink" title="get()"></a>get()</h3><p>当我们从hashMap中获取key对应的对象时，需要用的get方法</p><div class="hljs"><pre><code class="hljs q">public V <span class="hljs-built_in">get</span>(Object <span class="hljs-built_in">key</span>) &#123;    Node&lt;K,V&gt; e;    return (e = getNode(hash(<span class="hljs-built_in">key</span>), <span class="hljs-built_in">key</span>)) == <span class="hljs-built_in">null</span> ? <span class="hljs-built_in">null</span> : e.<span class="hljs-built_in">value</span>;&#125;final Node&lt;K,V&gt; getNode(<span class="hljs-type">int</span> hash, Object <span class="hljs-built_in">key</span>) &#123;    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; <span class="hljs-built_in">first</span>, e; <span class="hljs-type">int</span> n; K k;    if ((tab = table) != <span class="hljs-built_in">null</span> &amp;&amp; (n = tab.length) &gt; <span class="hljs-number">0</span> &amp;&amp;        (<span class="hljs-built_in">first</span> = tab[(n - <span class="hljs-number">1</span>) &amp; hash]) != <span class="hljs-built_in">null</span>) &#123;        <span class="hljs-comment">// 直接命中</span>        if (<span class="hljs-built_in">first</span>.hash == hash &amp;&amp; <span class="hljs-comment">// always check first node</span>            ((k = <span class="hljs-built_in">first</span>.<span class="hljs-built_in">key</span>) == <span class="hljs-built_in">key</span> || (<span class="hljs-built_in">key</span> != <span class="hljs-built_in">null</span> &amp;&amp; <span class="hljs-built_in">key</span>.equals(k))))            return <span class="hljs-built_in">first</span>;        <span class="hljs-comment">// 未命中</span>        if ((e = <span class="hljs-built_in">first</span>.<span class="hljs-built_in">next</span>) != <span class="hljs-built_in">null</span>) &#123;            <span class="hljs-comment">// 在树中get</span>            if (<span class="hljs-built_in">first</span> instanceof TreeNode)                return ((TreeNode&lt;K,V&gt;)<span class="hljs-built_in">first</span>).getTreeNode(hash, <span class="hljs-built_in">key</span>);            <span class="hljs-comment">// 在链表中get</span>            <span class="hljs-keyword">do</span> &#123;                if (e.hash == hash &amp;&amp;                    ((k = e.<span class="hljs-built_in">key</span>) == <span class="hljs-built_in">key</span> || (<span class="hljs-built_in">key</span> != <span class="hljs-built_in">null</span> &amp;&amp; <span class="hljs-built_in">key</span>.equals(k))))                    return e;            &#125; <span class="hljs-keyword">while</span> ((e = e.<span class="hljs-built_in">next</span>) != <span class="hljs-built_in">null</span>);        &#125;    &#125;    return <span class="hljs-built_in">null</span>;&#125;</code></pre></div><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li><p>如何确定存进来的对象的位置<br>首先，会对key的hashCode方法进行运算，生成一个新的hash，这个运算方法为：<code>(key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);</code> 即使用hashCode的高16与低16位相与。我们知道hashCode为int类型，int占4个字节，也就是4 * 8 = 32位。得到新的hash后，通过<code>(n - 1) & hash</code>得到在数组中的位置。<br>如果这个位置上没有东西，则直接赋值过去，<br>如果有东西：</p><ul><li>会先判断是不是相同的key，如果key相同则替换value</li><li>是否为红黑树，进行红黑树的操作，新增或者替换</li><li>是否为链表，进行链表的操作，新增或者替换</li></ul></li><li><p>链表转为红黑树的条件<br>如果一个链表的长度超过了<code>TREEIFY_THRESHOLD = 8;</code>, 那么就会将这个链表转成红黑树</p></li><li><p>table的扩容过程<br>默认情况下，table的初始大小为<code>DEFAULT_INITIAL_CAPACITY = 16</code>, 扩容因子为<code>DEFAULT_LOAD_FACTOR = 0.75f</code>, 当map的size达到了table.length * 扩容因子时，就会触发扩容。扩容时，table会变成原来的2倍，table中的数据也会重新计算位置。</p></li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><p><a href="https://www.bilibili.com/video/BV1Pp411d7kB" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1Pp411d7kB</a><br><a href="https://yikun.github.io/2015/04/01/Java-HashMap%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/" target="_blank" rel="noopener">https://yikun.github.io/2015/04/01/Java-HashMap%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/</a><br><a href="https://zhuanlan.zhihu.com/p/31610616" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/31610616</a></p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android View中Listener的不同写法</title>
    <link href="/2020/07/22/Android-Listener%E7%9A%84%E4%B8%8D%E5%90%8C%E5%86%99%E6%B3%95/"/>
    <url>/2020/07/22/Android-Listener%E7%9A%84%E4%B8%8D%E5%90%8C%E5%86%99%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>TODO</p>]]></content>
    
    
    
    <tags>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CopyOnWriteArrayList的优点及原理</title>
    <link href="/2020/07/21/CopyOnWriteArrayList%E7%9A%84%E4%BC%98%E7%82%B9%E5%8F%8A%E5%8E%9F%E7%90%86/"/>
    <url>/2020/07/21/CopyOnWriteArrayList%E7%9A%84%E4%BC%98%E7%82%B9%E5%8F%8A%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p>CopyOnWriteArrayList这个类，我还是看系统源码的时候看到的，但是一直不知道他是干什么用的，今天打算看一下它的实现。</p><a id="more"></a><p>我第一次看到CopyOnWriteArrayList的时候是在android.view.View.ListenerInfo#mOnAttachStateChangeListeners，当时的想法就是这个是一个listeners，而listeners肯定要经常的遍历，还有增删listener。后面我在写一些观察者模式代码时，也尝试使用了CopyOnWriteArrayList。</p><p>什么是CopyOnWrite呢，直接性的理解就是：在写入数据的时候先copy，copy什么呢，copy原来的数据。</p><p>我们来看一下write的情况 add()和remove()</p><div class="hljs"><pre><code class="hljs reasonml">public boolean add(E e) &#123;    synchronized (lock) &#123;        Object<span class="hljs-literal">[]</span> elements = get<span class="hljs-constructor">Array()</span>;        <span class="hljs-built_in">int</span> len = elements.length;        Object<span class="hljs-literal">[]</span> newElements = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Arrays</span>.</span></span>copy<span class="hljs-constructor">Of(<span class="hljs-params">elements</span>, <span class="hljs-params">len</span> + 1)</span>;        newElements<span class="hljs-literal">[<span class="hljs-identifier">len</span>]</span> = e;        set<span class="hljs-constructor">Array(<span class="hljs-params">newElements</span>)</span>;        return <span class="hljs-literal">true</span>;    &#125;&#125;</code></pre></div><p>代码不是很复杂，首先加了个锁，处理并发写入，只允许一个线程进行写入操作。对现有的数据进行copy，然后对copy出来的数据进行赋值，最后用新数据替换掉旧数据。</p><div class="hljs"><pre><code class="hljs pgsql"><span class="hljs-built_in">public</span> E remove(<span class="hljs-type">int</span> <span class="hljs-keyword">index</span>) &#123;    synchronized (<span class="hljs-keyword">lock</span>) &#123;        <span class="hljs-keyword">Object</span>[] elements = getArray();        <span class="hljs-type">int</span> len = elements.length;        E oldValue = <span class="hljs-keyword">get</span>(elements, <span class="hljs-keyword">index</span>);        <span class="hljs-type">int</span> numMoved = len - <span class="hljs-keyword">index</span> - <span class="hljs-number">1</span>;        <span class="hljs-keyword">if</span> (numMoved == <span class="hljs-number">0</span>)            setArray(Arrays.copyOf(elements, len - <span class="hljs-number">1</span>));        <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">Object</span>[] newElements = <span class="hljs-built_in">new</span> <span class="hljs-keyword">Object</span>[len - <span class="hljs-number">1</span>];            <span class="hljs-keyword">System</span>.arraycopy(elements, <span class="hljs-number">0</span>, newElements, <span class="hljs-number">0</span>, <span class="hljs-keyword">index</span>);            <span class="hljs-keyword">System</span>.arraycopy(elements, <span class="hljs-keyword">index</span> + <span class="hljs-number">1</span>, newElements, <span class="hljs-keyword">index</span>,                             numMoved);            setArray(newElements);        &#125;        <span class="hljs-keyword">return</span> oldValue;    &#125;&#125;</code></pre></div><p>也是对操作加锁，这里和add方法用了同一个锁，也就是说，add和remove只能有一个在执行。剩下的也是先copy得到新数组，然后操作新数组，然后用新数组覆盖旧数组。</p><div class="hljs"><pre><code class="hljs pgsql"><span class="hljs-built_in">public</span> E <span class="hljs-keyword">get</span>(<span class="hljs-type">int</span> <span class="hljs-keyword">index</span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">get</span>(getArray(), <span class="hljs-keyword">index</span>);&#125;private E <span class="hljs-keyword">get</span>(<span class="hljs-keyword">Object</span>[] a, <span class="hljs-type">int</span> <span class="hljs-keyword">index</span>) &#123;    <span class="hljs-keyword">return</span> (E) a[<span class="hljs-keyword">index</span>];&#125;</code></pre></div><p>get方法简单粗暴。没有锁。</p><p>总得来说，CopyOnWriteArrayList是一个线程安全的list，写入时有锁控制，缺陷就是数据会更新不及时，而且每次都copy也比较耗费资源（内存）。但是查询比较快，所以这个list适合读取频繁，增删少的情况，所以作为listener的容器还是很合适的。</p><p>既然说到了多线程安全，那就还有一个头疼的问题，iterator！</p><p>我们知道有好多线程安全的类，比如vector。但是在做iterator的仍然会抛出ConcurrentModificationException。但是CopyOnWriteArrayList不会。</p><p>我们来看一下它的实现。</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">public</span> Iterator&lt;E&gt; <span class="hljs-title">iterator</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> COWIterator&lt;E&gt;(getArray(), <span class="hljs-number">0</span>);&#125;</code></pre></div><p>首先，在iterator时，他创建了一个COWIterator，并且使用了getArray，那就说明了一个问题，在多线程调用add、remove时，并不会修改这个COWIterator的array，因为他们不是同一个对象。</p><div class="hljs"><pre><code class="hljs arduino"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">COWIterator</span>&lt;E&gt; <span class="hljs-title">implements</span> <span class="hljs-title">ListIterator</span>&lt;E&gt; &#123;</span>    COWIterator(Object[] elements, <span class="hljs-keyword">int</span> initialCursor) &#123;        <span class="hljs-built_in">cursor</span> = initialCursor;        snapshot = elements;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Not supported. Always throws UnsupportedOperationException.</span><span class="hljs-comment">     * @throws UnsupportedOperationException always; &#123;@code remove&#125;</span><span class="hljs-comment">     *         is not supported by this iterator.</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UnsupportedOperationException();    &#125;    @SuppressWarnings(<span class="hljs-string">"unchecked"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">next</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">if</span> (! hasNext())            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NoSuchElementException();        <span class="hljs-keyword">return</span> (E) snapshot[<span class="hljs-built_in">cursor</span>++];    &#125;&#125;</code></pre></div><p>通过以上代码，我们看到array直接被命名成了snapshot，这个很形象。next方法就直接获取了array中的数据，不会出现ConcurrentModificationException。但是他竟然没有实现remove()，这个很蛋疼，但是也没办法，因为她是个snapshot，这个remove很可能会失效，很可能被add、remove操作覆盖掉。所以没办法实现。</p><p>所以 我们还是少用iterator吧，这个有太多的问题了，我现在唯一能想到的安全调用iterator的方式就是：</p><p>使用vector，然后对整个iterator加上锁</p><div class="hljs"><pre><code class="hljs ada"><span class="hljs-keyword">synchronized</span> (vector) &#123;// <span class="hljs-keyword">do</span> iterator&#125;</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>性能优化</tag>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面向对象思想中的抽象类和接口</title>
    <link href="/2020/07/20/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%80%9D%E6%83%B3%E4%B8%AD%E7%9A%84%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3/"/>
    <url>/2020/07/20/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%80%9D%E6%83%B3%E4%B8%AD%E7%9A%84%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3/</url>
    
    <content type="html"><![CDATA[<blockquote><p>参考：<a href="https://www.cnblogs.com/dolphin0520/p/3811437.html" target="_blank" rel="noopener">https://www.cnblogs.com/dolphin0520/p/3811437.html</a></p></blockquote><a id="more"></a><h3 id="抽象类和接口的共同点和区别"><a href="#抽象类和接口的共同点和区别" class="headerlink" title="抽象类和接口的共同点和区别"></a>抽象类和接口的共同点和区别</h3><p>都不能被实例化</p><p>一个是类，一个是接口</p><p>一个可以被继承，一个被实现</p><p>一个只能单继承，一个可以被实现多个接口</p><p>一个可以有自己的实现，一个不可以</p><p>接口中不能含有静态代码块以及静态方法，而抽象类可以有静态代码块和静态方法；</p><p>抽象类是对一种事物的抽象，即对类抽象，而接口是对行为的抽象</p><h3 id="举例子"><a href="#举例子" class="headerlink" title="举例子"></a>举例子</h3><h4 id="第一个例子：飞机和鸟"><a href="#第一个例子：飞机和鸟" class="headerlink" title="第一个例子：飞机和鸟"></a>第一个例子：飞机和鸟</h4><p>飞机和鸟不是同一类的事物，但是他们都会飞，所以应该设计一个飞机类，一个鸟类，而把会飞这个属性设计成接口。</p><p>我们不能把会飞这个属性设计成类，因为飞只是一种行为、一种特性，并不是一类事物，他不是一个真实的物品。</p><p>继承是一种 “是不是的关系” ，而接口是一种 “有没有的关系” 。</p><h4 id="第二个例子：门和警报"><a href="#第二个例子：门和警报" class="headerlink" title="第二个例子：门和警报"></a>第二个例子：门和警报</h4><p>门都有open和close的两个功能，所以我们可以把门设计成类或者接口</p><div class="hljs"><pre><code class="hljs cs"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Door</span> &#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">open</span>(<span class="hljs-params"></span>)</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">close</span>(<span class="hljs-params"></span>)</span>;&#125;</code></pre></div><p>或者：</p><div class="hljs"><pre><code class="hljs cs"><span class="hljs-keyword">interface</span> <span class="hljs-title">Door</span> &#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">open</span>(<span class="hljs-params"></span>)</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">close</span>(<span class="hljs-params"></span>)</span>;&#125;</code></pre></div><p>假如我们现在需要添加一个警报功能，</p><ol><li><p>我们可以将警报alarm添加到抽象类Door中，这样一来所有继承于Door的类都获得了警报功能，但是现实中，并不是所有的门都有警报功能。</p></li><li><p>我们把这个警报alarm放到接口Door中去，这样一来所有实现了警报功能的类都要实现open和close功能，但是有些东西不需要open和close功能，比如火灾报警器。</p></li></ol><p>所以，门的open close和alarm不是同一个东西。open和close是同一类范畴的东西，而警报alarm是一个拓展的功能，所以，我们最好把door设计成一个抽象类，把alarm设计成一个接口。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Alram</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">alarm</span><span class="hljs-params">()</span></span>;&#125; <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Door</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">open</span><span class="hljs-params">()</span></span>;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">close</span><span class="hljs-params">()</span></span>;&#125; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AlarmDoor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Door</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Alarm</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">oepn</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-comment">//....</span>    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">close</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-comment">//....</span>    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">alarm</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-comment">//....</span>    &#125;&#125;</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>面向对象</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android源码阅读导图</title>
    <link href="/2020/07/20/Android%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E5%AF%BC%E5%9B%BE/"/>
    <url>/2020/07/20/Android%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E5%AF%BC%E5%9B%BE/</url>
    
    <content type="html"><![CDATA[<p>我决定慢慢更新这个导图。</p><a id="more"></a><p>Android源码导图：</p><img src="/img/android_source_xmind.png" srcset="/img/loading.gif">]]></content>
    
    
    
    <tags>
      
      <tag>Android</tag>
      
      <tag>源代码</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android App直接调用隐藏Api</title>
    <link href="/2020/06/27/Android-App%E7%9B%B4%E6%8E%A5%E8%B0%83%E7%94%A8%E9%9A%90%E8%97%8FApi/"/>
    <url>/2020/06/27/Android-App%E7%9B%B4%E6%8E%A5%E8%B0%83%E7%94%A8%E9%9A%90%E8%97%8FApi/</url>
    
    <content type="html"><![CDATA[<!-- abstract area --><p>有点标题党了，本文档主要针对已经解耦的系统应用。<br>何为解耦，这里的解耦为可以脱离系统独立编译的app。<br>一般的系统APP都需要依赖系统编译，使用make命令，这样编译比较慢，而且也没有像Android Studio这么好用的开发工具</p><a id="more"></a><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>我们需要编译生成framework.jar，这个jar是系统编译的中间产物，这个里边会包含隐藏的api。<br>我们平时调用不到隐藏的api，是因为我们使用的Android sdk中的环境变量中已经剔除了隐藏的api。<br>所以我们需要把自己编译的jar放到Android studio的环境变量里边。</p><p>下面介绍具体实现，我们首先有一个基于gradle的项目。</p><h2 id="build-framework-jar"><a href="#build-framework-jar" class="headerlink" title="build framework.jar:"></a>build framework.jar:</h2><p>运行命令进行编译</p><div class="hljs"><pre><code class="hljs ebnf"><span class="hljs-attribute">make framework</span></code></pre></div><p>生成到./out/target/common/obj/JAVA_LIBRARIES/framework_intermediates/classes-full-debug.jar</p><blockquote><p>对于不同版本的源码，编译方式不太一样，具体的可以Google</p></blockquote><h2 id="module-的-build-gradle-修改"><a href="#module-的-build-gradle-修改" class="headerlink" title="module 的 build.gradle 修改"></a>module 的 build.gradle 修改</h2><div class="hljs"><pre><code class="hljs routeros">dependencies &#123;  <span class="hljs-built_in">..</span><span class="hljs-built_in">..</span><span class="hljs-built_in">..</span><span class="hljs-built_in">..</span>  compileOnly files(<span class="hljs-string">'../sharelibs/framework-27.jar'</span>)&#125;</code></pre></div><p>添加下下面的脚本,把module.iml里的<orderEntry type="jdk" jdkName="Android API 27 Platform" jdkType="Android SDK"/>放到最后</p><div class="hljs"><pre><code class="hljs gradle">preBuild &#123;  <span class="hljs-keyword">doLast</span> &#123;    <span class="hljs-keyword">def</span> imlFile = <span class="hljs-keyword">file</span>( <span class="hljs-keyword">project</span>.name + <span class="hljs-string">".iml"</span>)    <span class="hljs-keyword">println</span> <span class="hljs-string">'Change '</span> + <span class="hljs-keyword">project</span>.name + <span class="hljs-string">'.iml order'</span>    <span class="hljs-keyword">try</span> &#123;      <span class="hljs-keyword">def</span> parsedXml = (<span class="hljs-keyword">new</span> XmlParser()).parse(imlFile)      <span class="hljs-keyword">def</span> jdkNode = parsedXml.component[<span class="hljs-number">1</span>].orderEntry.<span class="hljs-keyword">find</span> &#123; it.<span class="hljs-string">'@type'</span> == <span class="hljs-string">'jdk'</span> &#125;      parsedXml.component[<span class="hljs-number">1</span>].remove(jdkNode)      <span class="hljs-keyword">def</span> sdkString = <span class="hljs-string">"Android API "</span> + android.compileSdkVersion.substring(<span class="hljs-string">"android-"</span>.length()) + <span class="hljs-string">" Platform"</span>      <span class="hljs-keyword">println</span> <span class="hljs-string">'what'</span> + sdkString      <span class="hljs-keyword">new</span> Node(parsedXml.component[<span class="hljs-number">1</span>], <span class="hljs-string">'orderEntry'</span>, [<span class="hljs-string">'type'</span>: <span class="hljs-string">'jdk'</span>, <span class="hljs-string">'jdkName'</span>: sdkString, <span class="hljs-string">'jdkType'</span>: <span class="hljs-string">'Android SDK'</span>])      groovy.xml.XmlUtil.serialize(parsedXml, <span class="hljs-keyword">new</span> FileOutputStream(imlFile))    &#125; <span class="hljs-keyword">catch</span> (FileNotFoundException e) &#123;      <span class="hljs-comment">// nop, iml not found</span>      <span class="hljs-keyword">println</span> <span class="hljs-string">"no iml found"</span>    &#125;  &#125;&#125;</code></pre></div><h2 id="project-的build-gradle-添加"><a href="#project-的build-gradle-添加" class="headerlink" title="project 的build.gradle 添加"></a>project 的build.gradle 添加</h2><div class="hljs"><pre><code class="hljs routeros">allprojects &#123;  <span class="hljs-built_in">..</span><span class="hljs-built_in">..</span><span class="hljs-built_in">..</span><span class="hljs-built_in">..</span><span class="hljs-built_in">..</span><span class="hljs-built_in">..</span><span class="hljs-built_in">..</span>  gradle.projectsEvaluated &#123;    tasks.withType(JavaCompile) &#123;      options.compilerArgs.<span class="hljs-builtin-name">add</span>(<span class="hljs-string">'-Xbootclasspath/p:sharelibs/framework-27.jar'</span>)    &#125;  &#125;&#125;</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>Android</tag>
      
      <tag>编译</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>定制适合自己的Android studio插件</title>
    <link href="/2020/06/26/%E5%AE%9A%E5%88%B6%E9%80%82%E5%90%88%E8%87%AA%E5%B7%B1%E7%9A%84Android-studio%E6%8F%92%E4%BB%B6/"/>
    <url>/2020/06/26/%E5%AE%9A%E5%88%B6%E9%80%82%E5%90%88%E8%87%AA%E5%B7%B1%E7%9A%84Android-studio%E6%8F%92%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<!-- abstract area --><p>我们经常会去Android studio的plugin中心寻找满足自己需要的plugin，我前段时间去找了一个Translate的插件，作者是bob。<br>这个插件是挺好用的，但是有个问题，就是他会在工具栏中生成一个独占一列的tab，我用的是mac，这样就会把整个工具栏占满，导致好多图标显示不出来，<br>比如qq、微信、电量等，这个很难受，然后我决定改造一个这个插件。</p><a id="more"></a><p>我查了一下，如何开发一个Android studio插件。<br>发现需要自己定义一个Action，然后把这个action通过一个plugin.xml注册到Android studio中，<br>注册的时候要指明这个action作用在工具栏还是右键菜单。<br>那我们只需要找到这个文件，然后修改就可以了。</p><p>首先需要找到这个插件存放的位置。查到在 ~/Library/Application Support/AndroidStudio4.0<br>这个翻译插件的名字竟然叫plugin.jar，别的插件都是已功能命名的，比如GsonFormat.jar</p><p>我需要对这个jar进行解压，命令为：</p><div class="hljs"><pre><code class="hljs stata">unzip -x -q <span class="hljs-keyword">plugin</span>.jar -<span class="hljs-keyword">d</span> <span class="hljs-keyword">plugin</span></code></pre></div><p>查看一下jar包里边都有啥</p><div class="hljs"><pre><code class="hljs gherkin">.|<span class="hljs-string">____META-INF</span>|<span class="hljs-string"> </span>|<span class="hljs-string">____MANIFEST.MF</span>|<span class="hljs-string"> </span>|<span class="hljs-string">____plugin.xml</span>|____translate_tool_window|<span class="hljs-string"> </span>|<span class="hljs-string">____logo.png</span>|____com|<span class="hljs-string"> </span>|____huangmb|<span class="hljs-string"> </span>|<span class="hljs-string"> </span>|____idea|<span class="hljs-string"> </span>|<span class="hljs-string"> </span>|<span class="hljs-string"> </span>|<span class="hljs-string">____省略</span>|<span class="hljs-string"> </span>|____intellij|<span class="hljs-string"> </span>|<span class="hljs-string"> </span>|____uiDesigner|<span class="hljs-string"> </span>|<span class="hljs-string"> </span>|<span class="hljs-string"> </span>|<span class="hljs-string">____省略</span></code></pre></div><p>查看plugin.xml</p><div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">idea-plugin</span> <span class="hljs-attr">version</span>=<span class="hljs-string">"2"</span>&gt;</span>    .......    <span class="hljs-tag">&lt;<span class="hljs-name">actions</span>&gt;</span>        <span class="hljs-comment">&lt;!-- Add your actions here --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">group</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"Hello"</span> <span class="hljs-attr">text</span>=<span class="hljs-string">"Translate"</span> <span class="hljs-attr">description</span>=<span class="hljs-string">"translate plugin"</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">separator</span>/&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">add-to-group</span> <span class="hljs-attr">group-id</span>=<span class="hljs-string">"MainMenu"</span> <span class="hljs-attr">anchor</span>=<span class="hljs-string">"last"</span>/&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">add-to-group</span> <span class="hljs-attr">group-id</span>=<span class="hljs-string">"EditorPopupMenu"</span> <span class="hljs-attr">relative-to-action</span>=<span class="hljs-string">"EditorToggleColumnMode"</span> <span class="hljs-attr">anchor</span>=<span class="hljs-string">"after"</span>/&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">add-to-group</span> <span class="hljs-attr">group-id</span>=<span class="hljs-string">"MainToolBar"</span> <span class="hljs-attr">anchor</span>=<span class="hljs-string">"last"</span>/&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">add-to-group</span> <span class="hljs-attr">group-id</span>=<span class="hljs-string">"NavBarToolBar"</span> <span class="hljs-attr">anchor</span>=<span class="hljs-string">"last"</span>/&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">action</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"TranslatePlugin.TranslateAction"</span></span><span class="hljs-tag">                    <span class="hljs-attr">class</span>=<span class="hljs-string">"com.huangmb.idea.action.TranslateAction"</span></span><span class="hljs-tag">                    <span class="hljs-attr">text</span>=<span class="hljs-string">"Translate"</span></span><span class="hljs-tag">                    <span class="hljs-attr">icon</span>=<span class="hljs-string">"/translate_tool_window/logo.png"</span></span><span class="hljs-tag">                    <span class="hljs-attr">description</span>=<span class="hljs-string">"toggle translate"</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">keyboard-shortcut</span> <span class="hljs-attr">keymap</span>=<span class="hljs-string">"$default"</span> <span class="hljs-attr">first-keystroke</span>=<span class="hljs-string">"ctrl meta T"</span>/&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">action</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">group</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">actions</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">idea-plugin</span>&gt;</span></code></pre></div><p>需要删掉group-id=”MainMenu”的那一行，删除后重新打包</p><div class="hljs"><pre><code class="hljs stata">jar cvf <span class="hljs-keyword">plugin</span>.jar <span class="hljs-keyword">META</span>-<span class="hljs-keyword">INF</span>/MANIFEST.MF *</code></pre></div><p>然后打开Android studio卸载旧的插件，然后选择从磁盘安装插件，选择我们新生成的那个jar。</p><p>重启Android studio。</p><p>一切都变得顺滑了。。。</p>]]></content>
    
    
    
    <tags>
      
      <tag>开发环境</tag>
      
      <tag>DIY</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>转载:Android 4.4系统获取root权限的方法</title>
    <link href="/2020/06/12/%E8%BD%AC%E8%BD%BD-Android-4-4%E7%B3%BB%E7%BB%9F%E8%8E%B7%E5%8F%96root%E6%9D%83%E9%99%90%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    <url>/2020/06/12/%E8%BD%AC%E8%BD%BD-Android-4-4%E7%B3%BB%E7%BB%9F%E8%8E%B7%E5%8F%96root%E6%9D%83%E9%99%90%E7%9A%84%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<!-- abstract area --><blockquote><p>转载自：<a href="https://www.cnblogs.com/jiayayao/p/7147140.html" target="_blank" rel="noopener">https://www.cnblogs.com/jiayayao/p/7147140.html</a> </p></blockquote><p>对于一些不可以root的手机，我们可以通过修改boot.img的方式进行修改，修改boot.img后，需要重新打包boot.img，然后通过fastboot重新刷入新的boot.img</p><a id="more"></a><ol><li>准备工作：</li></ol><p>准备一台ubuntu机器，将boot.img复制到该机器上，下载必要的工具<br>sudo apt-get install abootimg<br>git clone <a href="https://github.com/anestisb/android-simg2img.git">https://github.com/anestisb/android-simg2img.git</a><br>cd android-simg2img<br>make<br>sudo cp simg2img /usr/bin</p><ol start="2"><li><p>解压缩boot镜像<br>abootimg -x boot.img<br>mkdir ramdisk<br>cd ramdisk<br>gunzip -c ../initrd.img | cpio -i</p></li><li><p>修改default.prop文件，使得<br>ro.secure=0<br>ro.debuggable=1</p></li><li><p>修改init.rc，使得<br>on property:ro.debuggable=1<br>start console</p></li></ol><p>service adbd /sbin/adbd<br>class core<br>socket adbd stream 660 system system<br>disabled<br>seclabel u:r:su:s0</p><p>on post-fs</p><h1 id="once-everything-is-setup-no-need-to-modify"><a href="#once-everything-is-setup-no-need-to-modify" class="headerlink" title="once everything is setup, no need to modify /"></a>once everything is setup, no need to modify /</h1><p>mount rootfs rootfs / rw remount</p><ol start="5"><li><p>修改fstab.freescale，使得挂载权限可写<br>/dev/block/mmcblk0p5 /system ext4 rw wait</p></li><li><p>重新打包ramdisk文件<br>cd ramdisk/<br>find . | cpio –o –H newc | gzip &gt; ../new-ramdisk.img</p></li><li><p>生成新的boot.img<br>由于解压缩后再打包，new-randisk.img文件大小会与原来的initrd.img大小不同，<br>如果比原来大，需要重新设置boot.img的大小，<br>查看原来的大小<br>cat bootimg.cfg，<br>第一行是原来的boot.img的大小，<br>使用ls -l 查看initrd.img和new-ramdisk.img两个文件的大小，<br>在原来boot.img的大小基础上加上两个文件的大小差（NEWSIZE-BYTES），注意增加的字节数最好是block的整数倍，例如4096字节等等。<br>然后使用命令生成新的镜像：<br>abootimg –create new-boot.img -f bootimg.cfg -k zImage -r new-ramdisk.img -c “bootsize=NEWSIZE-BYTES”</p></li><li><p>将生成的new-boot.img作为boot.img重新刷入开发板，<br>重启后进入系统，system分区变成可写了。</p></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>Android</tag>
      
      <tag>Root</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OkHttp源码阅读</title>
    <link href="/2020/03/12/OkHttp%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    <url>/2020/03/12/OkHttp%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/</url>
    
    <content type="html"><![CDATA[<!-- abstract area --><p>OkHttp这个开源项目真的是一个神项目，我也一直想读OkHttp的源码，但是一直没有勇气，现在有了一套视频，我结合着视频和自己的理解，用了三个晚上把源码粗略的看了一遍，整理了一个思维导图。</p><a id="more"></a><blockquote><p>这个图片有点大，这个博客系统好像没有图片放大功能，可以在Chrome中右键“在新标签中打开图片”</p></blockquote><p>简单的介绍一下整个分析流程</p><ol><li><p>OkHttp的使用，分为同步请求和异步请求</p></li><li><p>如何处理多个请求并发情况</p></li><li><p>请求如何访问网络并拿到结果</p></li></ol><img src="/img/OkHttp.png" srcset="/img/loading.gif">]]></content>
    
    
    
    <tags>
      
      <tag>OkHttp</tag>
      
      <tag>源码</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>WDYDT-20-SharedPreferences探索</title>
    <link href="/2019/09/10/WDYDT-20-SharedPreferences%E6%8E%A2%E7%B4%A2/"/>
    <url>/2019/09/10/WDYDT-20-SharedPreferences%E6%8E%A2%E7%B4%A2/</url>
    
    <content type="html"><![CDATA[<!-- abstract area --><p>前几天遇到了一个使用SharedPreferences(以下简写成sp)导致严格模式报警的问题，我打点计算了一下sp#getInt()的时间，发现sp还是挺慢的，大约30ms。今天有点空闲，我们来研究一下sp的原理。</p><p>(源码基于android-28)</p><a id="more"></a><p>我接下来会顺着我们使用sp的步骤，一步一步的来分析。<br>主要包含：sp的创建、sp的数据读取、sp的写入。</p><h3 id="sp的创建"><a href="#sp的创建" class="headerlink" title="sp的创建"></a>sp的创建</h3><p>通话context#getSharedPreferences可以获取到sp实例。</p><div class="hljs"><pre><code class="hljs java">android.content.Context#getSharedPreferences(java.io.File, int)<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> SharedPreferences <span class="hljs-title">getSharedPreferences</span><span class="hljs-params">(File file, @PreferencesMode <span class="hljs-keyword">int</span> mode)</span></span>;</code></pre></div><p>通过源码可以看出，这里的具体实现应该是在ContextImpl.java</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> SharedPreferences <span class="hljs-title">getSharedPreferences</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> mode)</span> </span>&#123;    <span class="hljs-comment">// At least one application in the world actually passes in a null</span>    <span class="hljs-comment">// name.  This happened to work because when we generated the file name</span>    <span class="hljs-comment">// we would stringify it to "null.xml".  Nice.</span>    <span class="hljs-keyword">if</span> (mPackageInfo.getApplicationInfo().targetSdkVersion &lt;            Build.VERSION_CODES.KITKAT) &#123;        <span class="hljs-keyword">if</span> (name == <span class="hljs-keyword">null</span>) &#123;            name = <span class="hljs-string">"null"</span>;        &#125;    &#125;    File file;    <span class="hljs-keyword">synchronized</span> (ContextImpl<span class="hljs-class">.<span class="hljs-keyword">class</span>) </span>&#123;  <span class="hljs-comment">//字节码 同步锁</span>        <span class="hljs-keyword">if</span> (mSharedPrefsPaths == <span class="hljs-keyword">null</span>) &#123;            mSharedPrefsPaths = <span class="hljs-keyword">new</span> ArrayMap&lt;&gt;();  <span class="hljs-comment">// sp path的内存缓存</span>        &#125;        file = mSharedPrefsPaths.get(name);        <span class="hljs-keyword">if</span> (file == <span class="hljs-keyword">null</span>) &#123;            file = getSharedPreferencesPath(name);  <span class="hljs-comment">// 见下边的方法</span>            mSharedPrefsPaths.put(name, file);        &#125;    &#125;    <span class="hljs-keyword">return</span> getSharedPreferences(file, mode);  <span class="hljs-comment">// 见下边的方法</span>&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> File <span class="hljs-title">getSharedPreferencesPath</span><span class="hljs-params">(String name)</span> </span>&#123;    <span class="hljs-keyword">return</span> makeFilename(getPreferencesDir(), name + <span class="hljs-string">".xml"</span>);&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> SharedPreferences <span class="hljs-title">getSharedPreferences</span><span class="hljs-params">(File file, <span class="hljs-keyword">int</span> mode)</span> </span>&#123;    SharedPreferencesImpl sp;  <span class="hljs-comment">//SharedPreferencesImpl 真正的实现类</span>    <span class="hljs-keyword">synchronized</span> (ContextImpl<span class="hljs-class">.<span class="hljs-keyword">class</span>) </span>&#123;        <span class="hljs-keyword">final</span> ArrayMap&lt;File, SharedPreferencesImpl&gt; cache = getSharedPreferencesCacheLocked();  <span class="hljs-comment">// 缓存</span>        sp = cache.get(file);  <span class="hljs-comment">// 从缓存中拿到sp impl</span>        <span class="hljs-keyword">if</span> (sp == <span class="hljs-keyword">null</span>) &#123;            checkMode(mode);            <span class="hljs-keyword">if</span> (getApplicationInfo().targetSdkVersion &gt;= android.os.Build.VERSION_CODES.O) &#123;                <span class="hljs-keyword">if</span> (isCredentialProtectedStorage()                        &amp;&amp; !getSystemService(UserManager<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class">                                .<span class="hljs-title">isUserUnlockingOrUnlocked</span>(<span class="hljs-title">UserHandle</span>.<span class="hljs-title">myUserId</span>())) </span>&#123;                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"SharedPreferences in credential encrypted "</span>                            + <span class="hljs-string">"storage are not available until after user is unlocked"</span>);                &#125;            &#125;            sp = <span class="hljs-keyword">new</span> SharedPreferencesImpl(file, mode);  <span class="hljs-comment">// 创建 sp impl</span>            cache.put(file, sp);            <span class="hljs-keyword">return</span> sp;        &#125;    &#125;    <span class="hljs-keyword">if</span> ((mode &amp; Context.MODE_MULTI_PROCESS) != <span class="hljs-number">0</span> ||        getApplicationInfo().targetSdkVersion &lt; android.os.Build.VERSION_CODES.HONEYCOMB) &#123;        <span class="hljs-comment">// If somebody else (some other process) changed the prefs</span>        <span class="hljs-comment">// file behind our back, we reload it.  This has been the</span>        <span class="hljs-comment">// historical (if undocumented) behavior.</span>        sp.startReloadIfChangedUnexpectedly();    &#125;    <span class="hljs-keyword">return</span> sp;&#125;<span class="hljs-meta">@GuardedBy</span>(<span class="hljs-string">"ContextImpl.class"</span>)<span class="hljs-function"><span class="hljs-keyword">private</span> ArrayMap&lt;File, SharedPreferencesImpl&gt; <span class="hljs-title">getSharedPreferencesCacheLocked</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">if</span> (sSharedPrefsCache == <span class="hljs-keyword">null</span>) &#123;        sSharedPrefsCache = <span class="hljs-keyword">new</span> ArrayMap&lt;&gt;();    &#125;    <span class="hljs-keyword">final</span> String packageName = getPackageName();    ArrayMap&lt;File, SharedPreferencesImpl&gt; packagePrefs = sSharedPrefsCache.get(packageName);    <span class="hljs-keyword">if</span> (packagePrefs == <span class="hljs-keyword">null</span>) &#123;        packagePrefs = <span class="hljs-keyword">new</span> ArrayMap&lt;&gt;();        sSharedPrefsCache.put(packageName, packagePrefs);    &#125;    <span class="hljs-keyword">return</span> packagePrefs;&#125;</code></pre></div><p>所以sharedPreferences的真正实现在SharedPreferencesImpl。</p><p>再来看一下SharedPreferencesImpl的初始化过程</p><div class="hljs"><pre><code class="hljs java">SharedPreferencesImpl(File file, <span class="hljs-keyword">int</span> mode) &#123;    mFile = file;    mBackupFile = makeBackupFile(file);  <span class="hljs-comment">// 获取备份文件</span>    mMode = mode;    mLoaded = <span class="hljs-keyword">false</span>;    mMap = <span class="hljs-keyword">null</span>;    mThrowable = <span class="hljs-keyword">null</span>;    startLoadFromDisk();  <span class="hljs-comment">// 初始化数据</span>&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">startLoadFromDisk</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">synchronized</span> (mLock) &#123;        mLoaded = <span class="hljs-keyword">false</span>;    &#125;    <span class="hljs-keyword">new</span> Thread(<span class="hljs-string">"SharedPreferencesImpl-load"</span>) &#123;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;            loadFromDisk();  <span class="hljs-comment">// 异步从磁盘读取数据</span>        &#125;    &#125;.start();&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">loadFromDisk</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">synchronized</span> (mLock) &#123;        <span class="hljs-keyword">if</span> (mLoaded) &#123;            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-keyword">if</span> (mBackupFile.exists()) &#123;            mFile.delete();            mBackupFile.renameTo(mFile);        &#125;    &#125;    .... <span class="hljs-comment">// 加载数据到map里边</span>    <span class="hljs-keyword">synchronized</span> (mLock) &#123;        mLoaded = <span class="hljs-keyword">true</span>;   <span class="hljs-comment">// 标记数据加载完成</span>        mThrowable = thrown;        ....        <span class="hljs-keyword">try</span> &#123;            .... <span class="hljs-comment">// 初始化mMap，正常情况下会 mMap = map</span>        &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;            mThrowable = t;        &#125; <span class="hljs-keyword">finally</span> &#123;            mLock.notifyAll(); <span class="hljs-comment">// 释放锁</span>        &#125;    &#125;&#125;</code></pre></div><p>从上面的代码我们可以发现，sp的创建过程虽然复杂，但是耗时操作已经放到了子线程，所以我们在获取sp实例的时候不需要担心阻塞的问题。</p><p>同时，我们注意到有两个变量比较重要：mLoaded和mLock，这两个变量是为了保证必须在数据从disk上加载完毕后，我们才能对sp进行读写操作。</p><h3 id="sp的数据读取"><a href="#sp的数据读取" class="headerlink" title="sp的数据读取"></a>sp的数据读取</h3><div class="hljs"><pre><code class="hljs java">sharedPreferences.getInt() <span class="hljs-comment">// 这是一种常用的获取sp数据的方式</span></code></pre></div><p>来看一下具体的实现：</p><div class="hljs"><pre><code class="hljs java">android.app.SharedPreferencesImpl#getInt    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getInt</span><span class="hljs-params">(String key, <span class="hljs-keyword">int</span> defValue)</span> </span>&#123;        <span class="hljs-keyword">synchronized</span> (mLock) &#123;  <span class="hljs-comment">// 这里用了mLock，保证上边的初始化和现在的读取互斥</span>            awaitLoadedLocked(); <span class="hljs-comment">// 检查或等待数据加载完成</span>            Integer v = (Integer)mMap.get(key);            <span class="hljs-keyword">return</span> v != <span class="hljs-keyword">null</span> ? v : defValue;        &#125;    &#125;    <span class="hljs-meta">@GuardedBy</span>(<span class="hljs-string">"mLock"</span>)    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">awaitLoadedLocked</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">if</span> (!mLoaded) &#123;            <span class="hljs-comment">// Raise an explicit StrictMode onReadFromDisk for this</span>            <span class="hljs-comment">// thread, since the real read will be in a different</span>            <span class="hljs-comment">// thread and otherwise ignored by StrictMode.</span>            BlockGuard.getThreadPolicy().onReadFromDisk();        &#125;        <span class="hljs-keyword">while</span> (!mLoaded) &#123; <span class="hljs-comment">// 如果没有加载完成，</span>            <span class="hljs-keyword">try</span> &#123;                mLock.wait(); <span class="hljs-comment">// 等待加载完成，这里会阻塞线程</span>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException unused) &#123;            &#125;        &#125;        <span class="hljs-keyword">if</span> (mThrowable != <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(mThrowable);        &#125;    &#125;</code></pre></div><p>所以，因为awaitLoadedLocked的存在，我们在getInt的时候，可能会有一定的耗时。只要你不是刚初始化sp，就立刻去get数据，一般也不会阻塞。</p><h3 id="sp的写入"><a href="#sp的写入" class="headerlink" title="sp的写入"></a>sp的写入</h3><div class="hljs"><pre><code class="hljs java">sharedPreferences.edit().putInt().apply();sharedPreferences.edit().putInt().commit();</code></pre></div><p>sp的写入有两种方式，apply和commit。</p><p>这里有个新的类：Editor，他的实现在android.app.SharedPreferencesImpl.EditorImpl，我们重点关注apply和commit方法。</p><div class="hljs"><pre><code class="hljs java">      <span class="hljs-meta">@Override</span>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">apply</span><span class="hljs-params">()</span> </span>&#123;          <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> startTime = System.currentTimeMillis();          <span class="hljs-keyword">final</span> MemoryCommitResult mcr = commitToMemory();  <span class="hljs-comment">// 提交到内存</span>          <span class="hljs-keyword">final</span> Runnable awaitCommit = <span class="hljs-keyword">new</span> Runnable() &#123;                  <span class="hljs-meta">@Override</span>                  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;                      <span class="hljs-keyword">try</span> &#123;                          mcr.writtenToDiskLatch.await();                      &#125; <span class="hljs-keyword">catch</span> (InterruptedException ignored) &#123;                      &#125;                      <span class="hljs-keyword">if</span> (DEBUG &amp;&amp; mcr.wasWritten) &#123;                          Log.d(TAG, mFile.getName() + <span class="hljs-string">":"</span> + mcr.memoryStateGeneration                                  + <span class="hljs-string">" applied after "</span> + (System.currentTimeMillis() - startTime)                                  + <span class="hljs-string">" ms"</span>);                      &#125;                  &#125;              &#125;;          QueuedWork.addFinisher(awaitCommit);  <span class="hljs-comment">//这是个内部工具类，用于跟踪那些未完成的或尚未结束的全局任务，新任务通过方法 queue 加入。添加 finisher 的runnables，由 waitToFinish 方法保证执行，用于保证任务已被处理完成。</span>          Runnable postWriteRunnable = <span class="hljs-keyword">new</span> Runnable() &#123;                  <span class="hljs-meta">@Override</span>                  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;                      awaitCommit.run();                      QueuedWork.removeFinisher(awaitCommit);                  &#125;              &#125;;          SharedPreferencesImpl.<span class="hljs-keyword">this</span>.enqueueDiskWrite(mcr, postWriteRunnable); <span class="hljs-comment">// 真正的异步写入disk</span>          <span class="hljs-comment">// Okay to notify the listeners before it's hit disk</span>          <span class="hljs-comment">// because the listeners should always get the same</span>          <span class="hljs-comment">// SharedPreferences instance back, which has the</span>          <span class="hljs-comment">// changes reflected in memory.</span>          notifyListeners(mcr); <span class="hljs-comment">// 通知观察者</span>      &#125;      <span class="hljs-comment">// Returns true if any changes were made</span>      <span class="hljs-function"><span class="hljs-keyword">private</span> MemoryCommitResult <span class="hljs-title">commitToMemory</span><span class="hljs-params">()</span> </span>&#123;          <span class="hljs-keyword">long</span> memoryStateGeneration;          List&lt;String&gt; keysModified = <span class="hljs-keyword">null</span>;          Set&lt;OnSharedPreferenceChangeListener&gt; listeners = <span class="hljs-keyword">null</span>;          Map&lt;String, Object&gt; mapToWriteToDisk;          <span class="hljs-keyword">synchronized</span> (SharedPreferencesImpl.<span class="hljs-keyword">this</span>.mLock) &#123; <span class="hljs-comment">// 使用sp中的那个数据访问锁，保证线程安全</span>              <span class="hljs-comment">// We optimistically don't make a deep copy until</span>              <span class="hljs-comment">// a memory commit comes in when we're already</span>              <span class="hljs-comment">// writing to disk.</span>              <span class="hljs-keyword">if</span> (mDiskWritesInFlight &gt; <span class="hljs-number">0</span>) &#123;                  <span class="hljs-comment">// We can't modify our mMap as a currently</span>                  <span class="hljs-comment">// in-flight write owns it.  Clone it before</span>                  <span class="hljs-comment">// modifying it.</span>                  <span class="hljs-comment">// noinspection unchecked</span>                  mMap = <span class="hljs-keyword">new</span> HashMap&lt;String, Object&gt;(mMap);              &#125;              mapToWriteToDisk = mMap; <span class="hljs-comment">// 拿到sp中的map</span>              mDiskWritesInFlight++;              <span class="hljs-keyword">boolean</span> hasListeners = mListeners.size() &gt; <span class="hljs-number">0</span>;              <span class="hljs-keyword">if</span> (hasListeners) &#123;                  keysModified = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();                  listeners = <span class="hljs-keyword">new</span> HashSet&lt;OnSharedPreferenceChangeListener&gt;(mListeners.keySet());              &#125;              <span class="hljs-keyword">synchronized</span> (mEditorLock) &#123;                  <span class="hljs-keyword">boolean</span> changesMade = <span class="hljs-keyword">false</span>;                  <span class="hljs-keyword">if</span> (mClear) &#123;                      <span class="hljs-keyword">if</span> (!mapToWriteToDisk.isEmpty()) &#123;                          changesMade = <span class="hljs-keyword">true</span>;                          mapToWriteToDisk.clear();                      &#125;                      mClear = <span class="hljs-keyword">false</span>;                  &#125;                  <span class="hljs-keyword">for</span> (Map.Entry&lt;String, Object&gt; e : mModified.entrySet()) &#123;                      String k = e.getKey();                      Object v = e.getValue();                      <span class="hljs-comment">// "this" is the magic value for a removal mutation. In addition,</span>                      <span class="hljs-comment">// setting a value to "null" for a given key is specified to be</span>                      <span class="hljs-comment">// equivalent to calling remove on that key.</span>                      <span class="hljs-keyword">if</span> (v == <span class="hljs-keyword">this</span> || v == <span class="hljs-keyword">null</span>) &#123;                          <span class="hljs-keyword">if</span> (!mapToWriteToDisk.containsKey(k)) &#123;                              <span class="hljs-keyword">continue</span>;                          &#125;                          mapToWriteToDisk.remove(k);  <span class="hljs-comment">//写入数据到map中，即内存中</span>                      &#125; <span class="hljs-keyword">else</span> &#123;                          <span class="hljs-keyword">if</span> (mapToWriteToDisk.containsKey(k)) &#123;                              Object existingValue = mapToWriteToDisk.get(k);                              <span class="hljs-keyword">if</span> (existingValue != <span class="hljs-keyword">null</span> &amp;&amp; existingValue.equals(v)) &#123;                                  <span class="hljs-keyword">continue</span>;                              &#125;                          &#125;                          mapToWriteToDisk.put(k, v); <span class="hljs-comment">//写入数据到map中，即内存中 </span>                      &#125;                      changesMade = <span class="hljs-keyword">true</span>;                      <span class="hljs-keyword">if</span> (hasListeners) &#123;                          keysModified.add(k);                      &#125;                  &#125;                  mModified.clear();                  <span class="hljs-keyword">if</span> (changesMade) &#123;                      mCurrentMemoryStateGeneration++;                  &#125;                  memoryStateGeneration = mCurrentMemoryStateGeneration;              &#125;          &#125;          <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> MemoryCommitResult(memoryStateGeneration, keysModified, listeners,                  mapToWriteToDisk);      &#125;      <span class="hljs-meta">@Override</span>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">commit</span><span class="hljs-params">()</span> </span>&#123;          <span class="hljs-keyword">long</span> startTime = <span class="hljs-number">0</span>;          <span class="hljs-keyword">if</span> (DEBUG) &#123;              startTime = System.currentTimeMillis();          &#125;          MemoryCommitResult mcr = commitToMemory();          SharedPreferencesImpl.<span class="hljs-keyword">this</span>.enqueueDiskWrite(              mcr, <span class="hljs-keyword">null</span> <span class="hljs-comment">/* sync write on this thread okay */</span>); <span class="hljs-comment">//这里的写入是异步的</span>          <span class="hljs-keyword">try</span> &#123;              mcr.writtenToDiskLatch.await();  <span class="hljs-comment">// 但是这里会阻塞等待写入完成</span>          &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;              <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;          &#125; <span class="hljs-keyword">finally</span> &#123;              <span class="hljs-keyword">if</span> (DEBUG) &#123;                  Log.d(TAG, mFile.getName() + <span class="hljs-string">":"</span> + mcr.memoryStateGeneration                          + <span class="hljs-string">" committed after "</span> + (System.currentTimeMillis() - startTime)                          + <span class="hljs-string">" ms"</span>);              &#125;          &#125;          notifyListeners(mcr);          <span class="hljs-keyword">return</span> mcr.writeToDiskResult;      &#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">enqueueDiskWrite</span><span class="hljs-params">(<span class="hljs-keyword">final</span> MemoryCommitResult mcr,</span></span><span class="hljs-function"><span class="hljs-params">                                <span class="hljs-keyword">final</span> Runnable postWriteRunnable)</span> </span>&#123;      <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> isFromSyncCommit = (postWriteRunnable == <span class="hljs-keyword">null</span>);      <span class="hljs-keyword">final</span> Runnable writeToDiskRunnable = <span class="hljs-keyword">new</span> Runnable() &#123;              <span class="hljs-meta">@Override</span>              <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;                  <span class="hljs-keyword">synchronized</span> (mWritingToDiskLock) &#123;                      writeToFile(mcr, isFromSyncCommit); <span class="hljs-comment">// 异步写入文件</span>                  &#125;                  <span class="hljs-keyword">synchronized</span> (mLock) &#123;                      mDiskWritesInFlight--;                  &#125;                  <span class="hljs-keyword">if</span> (postWriteRunnable != <span class="hljs-keyword">null</span>) &#123;                      postWriteRunnable.run();                  &#125;              &#125;          &#125;;      <span class="hljs-comment">// Typical #commit() path with fewer allocations, doing a write on</span>      <span class="hljs-comment">// the current thread.</span>      <span class="hljs-keyword">if</span> (isFromSyncCommit) &#123;          <span class="hljs-keyword">boolean</span> wasEmpty = <span class="hljs-keyword">false</span>;          <span class="hljs-keyword">synchronized</span> (mLock) &#123;              wasEmpty = mDiskWritesInFlight == <span class="hljs-number">1</span>;          &#125;          <span class="hljs-keyword">if</span> (wasEmpty) &#123;              writeToDiskRunnable.run();              <span class="hljs-keyword">return</span>;          &#125;      &#125;      QueuedWork.queue(writeToDiskRunnable, !isFromSyncCommit);  &#125;  <span class="hljs-meta">@GuardedBy</span>(<span class="hljs-string">"mWritingToDiskLock"</span>)  <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">writeToFile</span><span class="hljs-params">(MemoryCommitResult mcr, <span class="hljs-keyword">boolean</span> isFromSyncCommit)</span> </span>&#123;      .... <span class="hljs-comment">//写入相关的</span>          <span class="hljs-keyword">if</span> (!backupFileExists) &#123;              <span class="hljs-keyword">if</span> (!mFile.renameTo(mBackupFile)) &#123;                  Log.e(TAG, <span class="hljs-string">"Couldn't rename file "</span> + mFile                        + <span class="hljs-string">" to backup file "</span> + mBackupFile);                  mcr.setDiskWriteResult(<span class="hljs-keyword">false</span>, <span class="hljs-keyword">false</span>); <span class="hljs-comment">// 对CountDownLatch进行countDown，释放阻塞</span>                  <span class="hljs-keyword">return</span>;              &#125;          &#125; <span class="hljs-keyword">else</span> &#123;              mFile.delete();          &#125;      &#125;  &#125;</code></pre></div><p>所以apply是先提交到内存，异步存储到disk。而commit是先提交到内存后，然后阻塞线程到存储disk完成。</p><h3 id="QueuedWork"><a href="#QueuedWork" class="headerlink" title="QueuedWork"></a>QueuedWork</h3><p>这里需要补充一下QueuedWork，这个类我们用不到，因为是@hide，我们需要知道的是这个queue是异步的，是通过Handler实现的，线程名称是queued-work-looper。感觉这个代码比较关键：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Lazily create a handler on a separate thread.</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> the handler</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Handler <span class="hljs-title">getHandler</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">synchronized</span> (sLock) &#123;        <span class="hljs-keyword">if</span> (sHandler == <span class="hljs-keyword">null</span>) &#123;            HandlerThread handlerThread = <span class="hljs-keyword">new</span> HandlerThread(<span class="hljs-string">"queued-work-looper"</span>,                    Process.THREAD_PRIORITY_FOREGROUND);            handlerThread.start();            sHandler = <span class="hljs-keyword">new</span> QueuedWorkHandler(handlerThread.getLooper());        &#125;        <span class="hljs-keyword">return</span> sHandler;    &#125;&#125;</code></pre></div><p>以上是所有内容，The End.</p>]]></content>
    
    
    
    <tags>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>WDYDT-19-使用systrace查找掉帧问题</title>
    <link href="/2019/09/01/WDYDT-19-%E4%BD%BF%E7%94%A8systrace%E6%9F%A5%E6%89%BE%E6%8E%89%E5%B8%A7%E9%97%AE%E9%A2%98/"/>
    <url>/2019/09/01/WDYDT-19-%E4%BD%BF%E7%94%A8systrace%E6%9F%A5%E6%89%BE%E6%8E%89%E5%B8%A7%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<!-- abstract area --><p>这次遇到的问题发生在了listview的绘制上，也是研究systrace的时候偶然发现的。</p><a id="more"></a><p>命令：</p><blockquote><p> python systrace.py -b 32768 -o mytrace.html sched  gfx view am dalvik binder_driver core_services -a &lt;包名&gt;</p></blockquote><h3 id="解释一下命令"><a href="#解释一下命令" class="headerlink" title="解释一下命令"></a>解释一下命令</h3><p>systrace是android提供的一个性能优化工具。</p><p>路径在android sdk/platform-tools/,是一个Python脚本，所以需要Python环境，我用的Python2.7。</p><p>说一下参数，这里只用了一部分：</p><p>-b   即buffer大小</p><p>-o   output，结果输出到哪里</p><p>sched  cpu的调度信息</p><p>gfx   图像图形相关的</p><p>view  view相关</p><p>am  ActivityManager</p><p>dalvik  java虚拟机，gc啥的</p><p>binder_driver  binder相关的，对这块我还是小白</p><p>core_services 核心服务的情况</p><p>-a 你的包名</p><h3 id="掉帧"><a href="#掉帧" class="headerlink" title="掉帧"></a>掉帧</h3><img src="/img/wdydt-19/WX20190901-012311@2x.png" srcset="/img/loading.gif"><p>首先，我们先找到自己的进程，可以看到一堆F,那种红色的F就是有问题，准确的说，不是绿色的都有问题。</p><img src="/img/wdydt-19/WX20190901-012405@2x.png" srcset="/img/loading.gif"><p>上边这个就是有问题的，我们放大一些看一下。明显layout过程太长了，超过了一帧，即16ms。</p><img src="/img/wdydt-19/WX20190901-012426@2x.png" srcset="/img/loading.gif"><p>点击layout，发现耗时24ms, layout里边有一些inflate，通过查看listview的代码，我们可以发现这么几个地方：</p><p>ref: android.widget.AbsListView#obtainView</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function">View <span class="hljs-title">obtainView</span><span class="hljs-params">(<span class="hljs-keyword">int</span> position, <span class="hljs-keyword">boolean</span>[] outMetadata)</span> </span>&#123;    Trace.traceBegin(Trace.TRACE_TAG_VIEW, <span class="hljs-string">"obtainView"</span>);  <span class="hljs-comment">// 搜集trace</span>    outMetadata[<span class="hljs-number">0</span>] = <span class="hljs-keyword">false</span>;    <span class="hljs-comment">// Check whether we have a transient state view. Attempt to re-bind the</span>    <span class="hljs-comment">// data and discard the view if we fail.</span>    <span class="hljs-keyword">final</span> View transientView = mRecycler.getTransientStateView(position);    <span class="hljs-keyword">if</span> (transientView != <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">final</span> LayoutParams params = (LayoutParams) transientView.getLayoutParams();        <span class="hljs-comment">// If the view type hasn't changed, attempt to re-bind the data.</span>        <span class="hljs-keyword">if</span> (params.viewType == mAdapter.getItemViewType(position)) &#123;            <span class="hljs-keyword">final</span> View updatedView = mAdapter.getView(position, transientView, <span class="hljs-keyword">this</span>);  <span class="hljs-comment">// adapter#getView 这是我们的方法，我们会在这里inflate</span>            <span class="hljs-comment">// If we failed to re-bind the data, scrap the obtained view.</span>            <span class="hljs-keyword">if</span> (updatedView != transientView) &#123;                setItemViewLayoutParams(updatedView, position);                mRecycler.addScrapView(updatedView, position);            &#125;        &#125;        outMetadata[<span class="hljs-number">0</span>] = <span class="hljs-keyword">true</span>;        <span class="hljs-comment">// Finish the temporary detach started in addScrapView().</span>        transientView.dispatchFinishTemporaryDetach();        <span class="hljs-keyword">return</span> transientView;    &#125;    <span class="hljs-keyword">final</span> View scrapView = mRecycler.getScrapView(position);    <span class="hljs-keyword">final</span> View child = mAdapter.getView(position, scrapView, <span class="hljs-keyword">this</span>); <span class="hljs-comment">// adapter#getView 这是我们的方法，我们会在这里inflate</span>    <span class="hljs-keyword">if</span> (scrapView != <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">if</span> (child != scrapView) &#123;            <span class="hljs-comment">// Failed to re-bind the data, return scrap to the heap.</span>            mRecycler.addScrapView(scrapView, position);        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (child.isTemporarilyDetached()) &#123;            outMetadata[<span class="hljs-number">0</span>] = <span class="hljs-keyword">true</span>;            <span class="hljs-comment">// Finish the temporary detach started in addScrapView().</span>            child.dispatchFinishTemporaryDetach();        &#125;    &#125;    <span class="hljs-keyword">if</span> (mCacheColorHint != <span class="hljs-number">0</span>) &#123;        child.setDrawingCacheBackgroundColor(mCacheColorHint);    &#125;    <span class="hljs-keyword">if</span> (child.getImportantForAccessibility() == IMPORTANT_FOR_ACCESSIBILITY_AUTO) &#123;        child.setImportantForAccessibility(IMPORTANT_FOR_ACCESSIBILITY_YES);    &#125;    setItemViewLayoutParams(child, position);    <span class="hljs-keyword">if</span> (AccessibilityManager.getInstance(mContext).isEnabled()) &#123;        <span class="hljs-keyword">if</span> (mAccessibilityDelegate == <span class="hljs-keyword">null</span>) &#123;            mAccessibilityDelegate = <span class="hljs-keyword">new</span> ListItemAccessibilityDelegate();        &#125;        <span class="hljs-keyword">if</span> (child.getAccessibilityDelegate() == <span class="hljs-keyword">null</span>) &#123;            child.setAccessibilityDelegate(mAccessibilityDelegate);        &#125;    &#125;    Trace.traceEnd(Trace.TRACE_TAG_VIEW);    <span class="hljs-keyword">return</span> child;&#125;</code></pre></div><p>所以是我们在adapter的getView方法里inflate过多导致的，应该复用view，避免多次inflate。同时，可以看出来inflate是一个比较耗时的方法。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>决定要改改我的简历</title>
    <link href="/2019/08/12/%E5%86%B3%E5%AE%9A%E8%A6%81%E6%94%B9%E6%94%B9%E6%88%91%E7%9A%84%E7%AE%80%E5%8E%86/"/>
    <url>/2019/08/12/%E5%86%B3%E5%AE%9A%E8%A6%81%E6%94%B9%E6%94%B9%E6%88%91%E7%9A%84%E7%AE%80%E5%8E%86/</url>
    
    <content type="html"><![CDATA[<!-- abstract area --><p>记得有次面试，面试官有心无心的说了句：你简历内容这么多！我感觉我的简历是有些问题的。</p><p>今天筛简历，偶然发现一个挺好的简历结构，记录一下。</p><a id="more"></a><h4 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h4><p>姓名 性别 目前状态 年龄 学历 等</p><p>ps: 基本信息这一行可以不写，姓名单独一行，宋体三号。</p><h4 id="技能相关"><a href="#技能相关" class="headerlink" title="技能相关"></a>技能相关</h4><p>精通 熟练 掌握 了解</p><h4 id="工作经历"><a href="#工作经历" class="headerlink" title="工作经历"></a>工作经历</h4><p>日期区间  公司名称  职位</p><p>ps: 别写太复杂，时间倒序</p><h4 id="项目经历"><a href="#项目经历" class="headerlink" title="项目经历"></a>项目经历</h4><p>时间 项目名称 责任描述 项目描述（写技术亮点）</p><p>ps: 时间倒序，有的项目可以不写</p><h4 id="学历相关"><a href="#学历相关" class="headerlink" title="学历相关"></a>学历相关</h4><p>时间区间 学校名称 专业 （统招）学历</p><p>最后，篇幅不要超过3页吧，最好两页，也就是一张纸。字体为宋体 小五，子标题类的字体为宋体 11。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>WDYDT-18-晚睡的危害</title>
    <link href="/2019/04/22/WDYDT-18-%E6%99%9A%E7%9D%A1%E7%9A%84%E5%8D%B1%E5%AE%B3/"/>
    <url>/2019/04/22/WDYDT-18-%E6%99%9A%E7%9D%A1%E7%9A%84%E5%8D%B1%E5%AE%B3/</url>
    
    <content type="html"><![CDATA[<!-- abstract area --><p>应该是从我小学开始，我就喜欢熬夜。<br>对于熬夜来说，一切都是因为自己的自控力不行。</p><a id="more"></a><p>小时候是因为自己的作业写不完，白天控制不住自己，不想写作业，天天跑出去玩，然后回来发现自己的作业没有写完，只能硬着头皮熬夜把作业写完，一般一些就是12点。这一点到现在还是记忆犹新，每次都是这样，每次都后悔，每次都被老妈嘲讽，但是不管自己当时多后悔，下一次还是继续玩，还是继续熬夜，反正自己能熬的住，反正自己年轻，有大把的晚上时间可以用来写作业，就把白天的大好时光拿去玩吧，这可能就是我现在喜欢熬夜的原因吧。</p><p>到了今天，我有点熬不住了。有人说，喜欢熬夜是因为自己舍不得今天，而又不想迎来明天。是的，对于我来说的确是这样。工作的压力时时压的我不想面对它，每天下班就很晚了，感觉自己还没玩一会，这明显不是自己的性格啊，心理跨不过去这个槛儿，一定要玩会，玩会手机，刷会视频啥的，一直刷到睡着。为什么一定要玩会呢，因为我这样一天都在工作，如果不玩会儿就感觉整个一天都奉献给了工作，人呢活着不能只是为了工作啊，所以要玩，无拘无束的玩，不管到多晚，玩到自己拿着手机睡着。</p><p>然而，这种熬夜的危害也是非常大的。</p><p>第一，不管你怎么不想迎来明天，不管你再怎么玩，明天一样会到来，工作还是一样的繁杂。而你的心情可能会因为昨天的放松变得好一些，但是熬夜带来的生理上的疲惫感更严重，这可能会让你加速衰老、掉发、起痘痘等等。</p><p>第二，熬夜一时爽，爽过了就没意思了，并不能丰富你的知识，因为你熬夜的大部分时间都是玩，都是看一些没有营养的短视频、一些搞笑视频，不是说这些视频不能看，但是你浪费你宝贵的睡眠时间去看这些东西，的确不合适。</p><p>第三，熬夜会让你的工作越来越糟糕，一日复一日，渐渐地你对工作产生了厌恶的情绪。</p><p>第四，熬夜很容易形成一种错误的生物钟，当你来到假期，你会继续熬夜，晚上不睡，白天不起，逐渐变成一个宅男，你不再想去出门，整天与床为伴。</p><p>所以呢，还是不要熬夜了，我曾经也有段时间早睡早起，我相信我还能找回那种感觉，希望自己不再熬夜</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>WDYDT-17-adb dumpsys使用归纳</title>
    <link href="/2019/03/07/WDYDT-17-adb-dumpsys%E4%BD%BF%E7%94%A8%E5%BD%92%E7%BA%B3/"/>
    <url>/2019/03/07/WDYDT-17-adb-dumpsys%E4%BD%BF%E7%94%A8%E5%BD%92%E7%BA%B3/</url>
    
    <content type="html"><![CDATA[<p>dumpsys命令实在是太强大了，包含了太多的命令，这篇文档我打算一点点的写。</p><!-- abstract area --><a id="more"></a><h1 id="命令概要"><a href="#命令概要" class="headerlink" title="命令概要"></a>命令概要</h1><blockquote><p>dumpsys在源码的/frameworks/native/cmds/dumpsys目录</p></blockquote><p><a href="#dumpsys所有命令">支持的所有命令</a></p><p>在这么多命令中，我比较常用的有<br>dumpsys activity</p><h1 id="dumpsys-activity"><a href="#dumpsys-activity" class="headerlink" title="dumpsys activity"></a>dumpsys activity</h1><p>执行dumpsys activity -h可以看到如下帮助文档</p><div class="hljs"><pre><code class="hljs pf">chiron:/ <span class="hljs-comment"># dumpsys activity -h</span>Activity manager dump options:  [-a] [-c] [-p PACKAGE] [-h] [WHAT] ...  WHAT may be one of:    a[ctivities]: activity stack <span class="hljs-keyword">state</span>    r[recents]: recent activities <span class="hljs-keyword">state</span>    b[roadcasts] [PACKAGE_NAME] [history [-s]]: broadcast <span class="hljs-keyword">state</span>    broadcast-stats [PACKAGE_NAME]: aggregated broadcast statistics    i[ntents] [PACKAGE_NAME]: pending intent <span class="hljs-keyword">state</span>    p[rocesses] [PACKAGE_NAME]: process <span class="hljs-keyword">state</span>    o[om]: <span class="hljs-keyword">out</span> of memory management    perm[issions]: URI permission grant <span class="hljs-keyword">state</span>    prov[iders] [COMP_SPEC ...]: content provider <span class="hljs-keyword">state</span>    provider [COMP_SPEC]: provider client-side <span class="hljs-keyword">state</span>    s[ervices] [COMP_SPEC ...]: service <span class="hljs-keyword">state</span>    as[sociations]: tracked app associations    settings: currently applied config settings    service [COMP_SPEC]: service client-side <span class="hljs-keyword">state</span>    package [PACKAGE_NAME]: <span class="hljs-literal">all</span> <span class="hljs-keyword">state</span> related <span class="hljs-keyword">to</span> given package    <span class="hljs-literal">all</span>: dump <span class="hljs-literal">all</span> activities    top: dump the top activity  WHAT may also be a COMP_SPEC <span class="hljs-keyword">to</span> dump activities.  COMP_SPEC may be a component name (com.foo/.myApp),    a partial substring <span class="hljs-keyword">in</span> a component name, a    hex object identifier.  -a: include <span class="hljs-literal">all</span> available server <span class="hljs-keyword">state</span>.  -c: include client <span class="hljs-keyword">state</span>.  -p: <span class="hljs-keyword">limit</span> output <span class="hljs-keyword">to</span> given package.  --checkin: output checkin format, resetting data.  --C: output checkin format, not resetting data.</code></pre></div><p>使用实例</p><div class="hljs"><pre><code class="hljs stylus">dumpsys activity -<span class="hljs-selector-tag">p</span> com<span class="hljs-selector-class">.ss</span><span class="hljs-selector-class">.android</span><span class="hljs-selector-class">.article</span><span class="hljs-selector-class">.news</span> services <span class="hljs-comment">// 查看service状态</span></code></pre></div><div class="hljs"><pre><code class="hljs gradle">dumpsys activity | <span class="hljs-keyword">grep</span> mResumedActivity <span class="hljs-comment">// 查看显示的activity</span></code></pre></div><h1 id="dumpsys所有命令"><a href="#dumpsys所有命令" class="headerlink" title="dumpsys所有命令"></a>dumpsys所有命令</h1><p>使用<code>dumpsys -l</code> 可以查看所有的子命令</p><p>可以看到支持的命令有这么多：</p><p>Currently running services:<br>  DockObserver<br>  MiuiBackup<br>  MiuiInit<br>  ProcessManager<br>  SurfaceFlinger<br>  accessibility<br>  account<br>  activity<br>  alarm<br>  android.security.keystore<br>  android.service.gatekeeper.IGateKeeperService<br>  appops<br>  appwidget<br>  audio<br>  autofill<br>  backup<br>  battery<br>  batteryproperties<br>  batterystats<br>  bluetooth_manager<br>  carrier_config<br>  clipboard<br>  cneservice<br>  com.goodix.FingerprintService<br>  com.qualcomm.location.izat.IzatService<br>  commontime_management<br>  companiondevice<br>  connectivity<br>  connmetrics<br>  consumer_ir<br>  content<br>  contexthub<br>  country_detector<br>  cpuinfo<br>  dbinfo<br>  device_identifiers<br>  device_policy<br>  deviceidle<br>  devicestoragemonitor<br>  diskstats<br>  display<br>  dpmservice<br>  dreams<br>  drm.drmManager<br>  dropbox<br>  ethernet<br>  extphone<br>  fingerprint<br>  gfxinfo<br>  gpu<br>  graphicsstats<br>  hardware_properties<br>  imms<br>  input<br>  input_method<br>  installd<br>  iphonesubinfo<br>  isms<br>  isub<br>  jobscheduler<br>  launcherapps<br>  location<br>  locationpolicy<br>  lock_settings<br>  media.audio_flinger<br>  media.audio_policy<br>  media.camera<br>  media.camera.proxy<br>  media.cas<br>  media.drm<br>  media.extractor<br>  media.metrics<br>  media.player<br>  media.radio<br>  media.resource_manager<br>  media.sound_trigger_hw<br>  media_projection<br>  media_resource_monitor<br>  media_router<br>  media_session<br>  meminfo<br>  midi<br>  miui.contentcatcher.ContentCatcherService<br>  miui.face.FaceService<br>  miui.fdpp<br>  miui.mqsas.IMQSNative<br>  miui.mqsas.MQSService<br>  miui.sedc<br>  miui.shell<br>  miui.whetstone.klo<br>  miui.whetstone.mcd<br>  miui.whetstone.power<br>  mount<br>  netd<br>  netd_listener<br>  netpolicy<br>  netstats<br>  network_management<br>  network_score<br>  network_time_update_service<br>  nfc<br>  notification<br>  oem_lock<br>  otadexopt<br>  overlay<br>  package<br>  perfshielder<br>  permission<br>  persistent_data_block<br>  phone<br>  pinner<br>  power<br>  print<br>  processinfo<br>  procstats<br>  qti.ims.ext<br>  recovery<br>  restrictions<br>  rttmanager<br>  samplingprofiler<br>  scheduling_policy<br>  search<br>  sec_key_att_app_id_provider<br>  security<br>  sensorservice<br>  serial<br>  servicediscovery<br>  settings<br>  shortcut<br>  simphonebook<br>  sip<br>  sms-sec<br>  soundtrigger<br>  statusbar<br>  storaged<br>  storagestats<br>  telecom<br>  telephony.registry<br>  textservices<br>  trust<br>  uimode<br>  updatelock<br>  usagestats<br>  usb<br>  user<br>  vibrator<br>  voiceinteraction<br>  vrmanager<br>  wallpaper<br>  webviewupdate<br>  whetstone.activity<br>  wifi<br>  wificond<br>  wifip2p<br>  wifiscanner<br>  window<br>  xiaomi.joyose</p>]]></content>
    
    
    
    <tags>
      
      <tag>adb</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>分享两次技术被虐经历</title>
    <link href="/2019/01/30/%E5%88%86%E4%BA%AB%E4%B8%A4%E6%AC%A1%E6%8A%80%E6%9C%AF%E8%A2%AB%E8%99%90%E7%BB%8F%E5%8E%86/"/>
    <url>/2019/01/30/%E5%88%86%E4%BA%AB%E4%B8%A4%E6%AC%A1%E6%8A%80%E6%9C%AF%E8%A2%AB%E8%99%90%E7%BB%8F%E5%8E%86/</url>
    
    <content type="html"><![CDATA[<!-- abstract area --><p>好久没有出去MS了，没想到一出去就被虐的这么惨。</p><a id="more"></a><p>以下是面试的问题：<br>自我介绍<br>项目难点<br>handle<br>静态内部类和内部类<br>string stringBuilder stringBuffer 区别<br>UncaughtExceptionHandler 层级关系<br>事件分发<br>自定义view<br>滑动冲突<br>“热词”布局+动画<br>recyclerView<br>圆角矩形 抗锯齿<br>录像的时候 手机横过来怎么处理<br>intentservice</p><p>OOM 内存泄漏<br>ANR分析<br>string2int</p><p>总的来说，这次面试是失败的，彻底的失败。我感觉有两点是导致我失败的关键因素。<br>1 面试准备不充分<br>2 面试心态没有把握好</p><p>有几点感悟：<br>1 以后再面试一定要先面试小公司，把好的状态留给大公司面试时候用。<br>2 面试前一点要做好充分的准备，不准备好的情况下不投简历。<br>3 面试前要做题，算法题要做一些，把自己的思维带动起来。<br>4 面试的时候要端正心态，不管公司如何，面试官如何，一定要表现出积极的态度，还有一定要自信，不能和面试官赌气。</p>]]></content>
    
    
    
    <tags>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>WDYDT-16-Android加载jar的一个需要注意的点</title>
    <link href="/2018/12/03/WDYDT-16-Android%E5%8A%A0%E8%BD%BDjar%E7%9A%84%E4%B8%80%E4%B8%AA%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E7%82%B9/"/>
    <url>/2018/12/03/WDYDT-16-Android%E5%8A%A0%E8%BD%BDjar%E7%9A%84%E4%B8%80%E4%B8%AA%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<!-- abstract area --><p>需要动态加载一个jar包，然后一直报Class not found的错误，仔细阅读了博客，发现没有对jar进行处理，<br>需要使用dx命令对jar进行处理；</p><div class="hljs"><pre><code class="hljs reasonml">dx --dex --output=<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Loader_dex</span>.</span></span>jar <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Loader</span>.</span></span>jar</code></pre></div><a id="more"></a><h3 id="下面大体梳理一下动态加载jar的流程"><a href="#下面大体梳理一下动态加载jar的流程" class="headerlink" title="下面大体梳理一下动态加载jar的流程"></a>下面大体梳理一下动态加载jar的流程</h3><h4 id="1-jar包的制作"><a href="#1-jar包的制作" class="headerlink" title="1 jar包的制作"></a>1 jar包的制作</h4><p>代码写完后，对项目进行打包就行。比较简单。</p><h4 id="2-处理jar"><a href="#2-处理jar" class="headerlink" title="2 处理jar"></a>2 处理jar</h4><p>使用dx命令处理jar</p><div class="hljs"><pre><code class="hljs reasonml">dx --dex --output=<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Loader_dex</span>.</span></span>jar <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Loader</span>.</span></span>jar</code></pre></div><p>dx命令在Android SDK下，比如我电脑的dx文件路径为：sdk/build-tools/27.0.2/dx</p><h4 id="3-加载jar"><a href="#3-加载jar" class="headerlink" title="3 加载jar"></a>3 加载jar</h4><p>直接上代码</p><div class="hljs"><pre><code class="hljs reasonml"><span class="hljs-keyword">private</span> void load<span class="hljs-constructor">Jar()</span>&#123;       File dexoutputdir = get<span class="hljs-constructor">Dir(<span class="hljs-string">"dex1"</span>,0)</span>;       String dexPath = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Environment</span>.</span></span>get<span class="hljs-constructor">ExternalStorageDirectory()</span>.<span class="hljs-keyword">to</span><span class="hljs-constructor">String()</span> + <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">File</span>.</span></span>separator + <span class="hljs-string">"Loader_dex.jar"</span>;       DexClassLoader loader = <span class="hljs-keyword">new</span> <span class="hljs-constructor">DexClassLoader(<span class="hljs-params">dexPath</span>,<span class="hljs-params">dexoutputdir</span>.<span class="hljs-params">getAbsolutePath</span>()</span>,null,get<span class="hljs-constructor">ClassLoader()</span>);              <span class="hljs-keyword">try</span> &#123;           Class clz = loader.load<span class="hljs-constructor">Class(<span class="hljs-string">"com.example.interf.JarLoader"</span>)</span>;           ILoader iShowToast = (ILoader) clz.<span class="hljs-keyword">new</span><span class="hljs-constructor">Instance()</span>;           <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Toast</span>.</span></span>make<span class="hljs-constructor">Text(<span class="hljs-params">this</span>,<span class="hljs-params">iShowToast</span>.<span class="hljs-params">sayHi</span>()</span>,Toast.LENGTH_LONG).show<span class="hljs-literal">()</span>;       &#125; catch (Exception e)&#123;            <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Log</span>.</span></span>d(<span class="hljs-string">"dd"</span>,e.<span class="hljs-keyword">to</span><span class="hljs-constructor">String()</span>);       &#125;   &#125;</code></pre></div><p>dexPath、 dexoutputdir尽量放到APP目录下。</p><p>此处需要注意DexClassLoader的四个参数：</p><ul><li>参数1 dexPath：待加载的dex文件路径，如果是外存路径，一定要加上读外存文件的权限( <uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE" /> )，否则会报与报错，Android4.4 KitKat及以后的版本需要此权限，之前的版本不需要该权限。</li><li>参数2 optimizedDirectory：解压后的dex存放位置，此位置一定要是可读写且仅该应用可读写（安全性考虑），所以只能放在data/data下。本文getDir(“dex1”, 0)会在/data/data/**package/下创建一个名叫”app_dex1“的文件夹，其内存放的文件是自动生成Loader_dex.dex；需要注意，data/data文件夹只有在手机root之后，才看得到。</li><li>参数3 libraryPath：指向包含本地库(so)的文件夹路径，可以设为null。</li><li>参数4 parent：父级类加载器，一般可以通过Context.getClassLoader获取到，也可以通过ClassLoader.getSystemClassLoader()取到。 </li></ul><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a href="https://www.cnblogs.com/HDK2016/p/8306915.html" target="_blank" rel="noopener">【Android】Android动态加载Jar、APK的实现</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>编译</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>WDYDT-15-整理一下最近学到的知识点</title>
    <link href="/2018/11/21/WDYDT-15-%E6%95%B4%E7%90%86%E4%B8%80%E4%B8%8B%E6%9C%80%E8%BF%91%E5%AD%A6%E5%88%B0%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <url>/2018/11/21/WDYDT-15-%E6%95%B4%E7%90%86%E4%B8%80%E4%B8%8B%E6%9C%80%E8%BF%91%E5%AD%A6%E5%88%B0%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<!-- abstract area --><p>啥来着？温故而知新。</p><a id="more"></a><h4 id="最近任务挺多，接触到的东西也挺多。"><a href="#最近任务挺多，接触到的东西也挺多。" class="headerlink" title="最近任务挺多，接触到的东西也挺多。"></a>最近任务挺多，接触到的东西也挺多。</h4><p>android permission<br>系统签名<br>反射系统api<br>系统设置修改<br>录屏<br>accessibilityService 无障碍api<br>阻塞队列<br>系统编译相关，system.img挂载</p><h4 id="长时间不用-已经需要复习的有："><a href="#长时间不用-已经需要复习的有：" class="headerlink" title="长时间不用 已经需要复习的有："></a>长时间不用 已经需要复习的有：</h4><p>事件分发<br>动画<br>自定义view，draw &amp; measure<br>handler<br>IPC<br>GC<br>线程池</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>WDYDT-14-99金钱社会</title>
    <link href="/2018/09/14/WDYDT-14-99%E9%87%91%E9%92%B1%E7%A4%BE%E4%BC%9A/"/>
    <url>/2018/09/14/WDYDT-14-99%E9%87%91%E9%92%B1%E7%A4%BE%E4%BC%9A/</url>
    
    <content type="html"><![CDATA[<p>以前还有点天真，现在真的感觉这个社会就是一个金钱至上的社会。</p><!-- abstract area --><a id="more"></a><p>经济的快速发展，导致大家都去追求金钱。可能大家都穷怕了吧，这也无可厚非，有钱是可以过得很舒服。<br>最近抖音的火热，也说明了这个问题。那些家里又矿的人拍的视频满足了好多人的YY，想着自己一定也要过这样的生活。可是现实是残酷的，女人还可以搏一搏，男人就只能努力了（总不能去做一个钢丝球吧）。<br>真是负能量满满啊</p><p>但是，我决定改变了，我还是接纳这个社会吧，现在就开始拼命挣钱吧。等我有钱了，再说别的，再回归初心，归来依是少年。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>WDYDT-13-Java中自带的排序</title>
    <link href="/2018/08/13/WDYDT-13-Java%E4%B8%AD%E8%87%AA%E5%B8%A6%E7%9A%84%E6%8E%92%E5%BA%8F/"/>
    <url>/2018/08/13/WDYDT-13-Java%E4%B8%AD%E8%87%AA%E5%B8%A6%E7%9A%84%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<!-- abstract area --><p>Java 中自带了一些排序的方法，现在来看看他们用了什么排序。</p><a id="more"></a><p>Collections.sort()和Arrays.sort()使用的排序方法是好像是一样的，对于基本数据类型，采用的是快速排序。对于引用类型，才用的是TimSort。</p><p>TimSort是一种优化过的归并排序。</p><p>Java中对于对象的排序使用的是归并排序，对于基本数据类型使用的是快速排序。<br>归并排序更加稳定。<br>而且大多数情况下，我们需要排序的数据都是部分有序的数据。</p><p>以下是一个博客中的内容：</p><blockquote><p><a href="https://blog.csdn.net/lian47810925/article/details/4689323" target="_blank" rel="noopener">https://blog.csdn.net/lian47810925/article/details/4689323</a></p></blockquote><p>java中Arrays.sort使用了两种排序方法，快速排序和优化的合并排序。</p><p>快速排序主要是对哪些基本类型数据（int,short,long等）排序， 而合并排序用于对对象类型进行排序。<br>使用不同类型的排序算法主要是由于快速排序是不稳定的，而合并排序是稳定的。这里的稳定是指比较相等的数据在排序之后仍然按照排序之前的前后顺序排列。对于基本数据类型，稳定性没有意义，而对于对象类型，稳定性是比较重要的，因为对象相等的判断可能只是判断关键属性，最好保持相等对象的非关键属性的顺序与排序前一直；另外一个原因是由于合并排序相对而言比较次数比快速排序少，移动（对象引用的移动）次数比快速排序多，而对于对象来说，比较一般比移动耗时。<br>补充一点合并排序的时间复杂度是n<em>logn, 快速排序的平均时间复杂度也是n</em>logn，但是合并排序的需要额外的n个引用的空间</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>WDYDT-12-Effective Java简略简略笔记</title>
    <link href="/2018/08/09/WDYDT-12-Effective-Java%E7%AE%80%E7%95%A5%E7%AE%80%E7%95%A5%E7%AC%94%E8%AE%B0/"/>
    <url>/2018/08/09/WDYDT-12-Effective-Java%E7%AE%80%E7%95%A5%E7%AE%80%E7%95%A5%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<!-- abstract area --><p>买了本书，简单的翻了翻，发现里边的东西好像都接触过了，简单的记录一下。</p><a id="more"></a><h3 id="静态工厂方法代替构造方法"><a href="#静态工厂方法代替构造方法" class="headerlink" title="静态工厂方法代替构造方法"></a>静态工厂方法代替构造方法</h3><p>优点：1有名称，2对象复用或者单例，3可以返回子类型，灵活性较高，4代码简洁，5在编写包含该方法的类时，返回对象的类不需要存在<br>缺点：1类如果不含公有的或者受保护的构造器，就不能被子类化（子类继承），2与普通静态方法没有区别，不好辨识</p><h3 id="构建器（Builder）"><a href="#构建器（Builder）" class="headerlink" title="构建器（Builder）"></a>构建器（Builder）</h3><p>多个构造函数参数时，推荐使用构建器。易于阅读和编写，线程安全（set方式并不是线程安全的）<br>写起来麻烦点，性能上稍微弱点</p><h3 id="单例"><a href="#单例" class="headerlink" title="单例"></a>单例</h3><p>私有构造器、懒汉、饿汉、双重校验锁、静态内部类、volatile</p><h3 id="优先考虑依赖注入来引入资源"><a href="#优先考虑依赖注入来引入资源" class="headerlink" title="优先考虑依赖注入来引入资源"></a>优先考虑依赖注入来引入资源</h3><p>创建一个类的实例时，就将改资源传到构造器中。</p><h3 id="避免创造多余的对象"><a href="#避免创造多余的对象" class="headerlink" title="避免创造多余的对象"></a>避免创造多余的对象</h3><h3 id="及时消除过期的对象引用"><a href="#及时消除过期的对象引用" class="headerlink" title="及时消除过期的对象引用"></a>及时消除过期的对象引用</h3><h3 id="避免使用终结方法和清除方法"><a href="#避免使用终结方法和清除方法" class="headerlink" title="避免使用终结方法和清除方法"></a>避免使用终结方法和清除方法</h3><h3 id="使用try-with-resources"><a href="#使用try-with-resources" class="headerlink" title="使用try-with-resources"></a>使用try-with-resources</h3><h3 id="同时覆盖equals和hashcode"><a href="#同时覆盖equals和hashcode" class="headerlink" title="同时覆盖equals和hashcode"></a>同时覆盖equals和hashcode</h3><h3 id="始终覆盖toString"><a href="#始终覆盖toString" class="headerlink" title="始终覆盖toString"></a>始终覆盖toString</h3><h3 id="clone要谨慎，注意深度和浅度"><a href="#clone要谨慎，注意深度和浅度" class="headerlink" title="clone要谨慎，注意深度和浅度"></a>clone要谨慎，注意深度和浅度</h3><h3 id="comparable接口，对象的大小比较，注意数据溢出"><a href="#comparable接口，对象的大小比较，注意数据溢出" class="headerlink" title="comparable接口，对象的大小比较，注意数据溢出"></a>comparable接口，对象的大小比较，注意数据溢出</h3><h3 id="使类和成员的可访问性最小化"><a href="#使类和成员的可访问性最小化" class="headerlink" title="使类和成员的可访问性最小化"></a>使类和成员的可访问性最小化</h3><h3 id="使用getter和setter"><a href="#使用getter和setter" class="headerlink" title="使用getter和setter"></a>使用getter和setter</h3><h3 id="可变性最小化"><a href="#可变性最小化" class="headerlink" title="可变性最小化"></a>可变性最小化</h3><p>访问控制符、final类</p><h3 id="多用组合、少用继承"><a href="#多用组合、少用继承" class="headerlink" title="多用组合、少用继承"></a>多用组合、少用继承</h3><h3 id="考虑禁止继承"><a href="#考虑禁止继承" class="headerlink" title="考虑禁止继承"></a>考虑禁止继承</h3><h3 id="优先考虑泛型类-泛型方法"><a href="#优先考虑泛型类-泛型方法" class="headerlink" title="优先考虑泛型类 泛型方法"></a>优先考虑泛型类 泛型方法</h3><h3 id="使用枚举代替int常量"><a href="#使用枚举代替int常量" class="headerlink" title="使用枚举代替int常量"></a>使用枚举代替int常量</h3><p>Android中不推荐枚举，可以使用@IntDef</p><h3 id="使用-override"><a href="#使用-override" class="headerlink" title="使用@override"></a>使用@override</h3><h3 id="返回零长度的数组或集合，而不是null"><a href="#返回零长度的数组或集合，而不是null" class="headerlink" title="返回零长度的数组或集合，而不是null"></a>返回零长度的数组或集合，而不是null</h3><h3 id="编写文档、注释"><a href="#编写文档、注释" class="headerlink" title="编写文档、注释"></a>编写文档、注释</h3><h3 id="将局部变量作用域最小化"><a href="#将局部变量作用域最小化" class="headerlink" title="将局部变量作用域最小化"></a>将局部变量作用域最小化</h3><h3 id="了解已有的类"><a href="#了解已有的类" class="headerlink" title="了解已有的类"></a>了解已有的类</h3><h3 id="精确的计算请不要使用Float和Double"><a href="#精确的计算请不要使用Float和Double" class="headerlink" title="精确的计算请不要使用Float和Double"></a>精确的计算请不要使用Float和Double</h3><p>使用BigDecimal</p><h3 id="优先使用基本类型，而不是对象"><a href="#优先使用基本类型，而不是对象" class="headerlink" title="优先使用基本类型，而不是对象"></a>优先使用基本类型，而不是对象</h3><h3 id="字符串的拼接要使用stringBuilder"><a href="#字符串的拼接要使用stringBuilder" class="headerlink" title="字符串的拼接要使用stringBuilder"></a>字符串的拼接要使用stringBuilder</h3><p>stringBuffer是线程安全的</p><h3 id="不要忽略异常"><a href="#不要忽略异常" class="headerlink" title="不要忽略异常"></a>不要忽略异常</h3><h3 id="注意并发"><a href="#注意并发" class="headerlink" title="注意并发"></a>注意并发</h3><p>同步锁，单线程线程池、</p><h3 id="尽量不要使用wait、notify，推荐使用工具"><a href="#尽量不要使用wait、notify，推荐使用工具" class="headerlink" title="尽量不要使用wait、notify，推荐使用工具"></a>尽量不要使用wait、notify，推荐使用工具</h3><h3 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h3><p>Android中推荐 Parcelable，写起来麻烦，但是效率是Serializable的十倍以上。<br>当然我自己也会用json实现类似的序列化功能</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>WDYDT-11-Android Signature Version V1 V2</title>
    <link href="/2018/08/02/WDYDT-11-Android-Signature-Version-V1-V2/"/>
    <url>/2018/08/02/WDYDT-11-Android-Signature-Version-V1-V2/</url>
    
    <content type="html"><![CDATA[<!-- abstract area --><p>今天偶然搜到了这个，其实这个我知道挺久了，只是一直没有研究。</p><p>这个博客写的比较简练：</p><blockquote><p><a href="https://blog.csdn.net/lvshuchangyin/article/details/62227286" target="_blank" rel="noopener">https://blog.csdn.net/lvshuchangyin/article/details/62227286</a></p></blockquote><a id="more"></a><h3 id="问题描述-v1和v2"><a href="#问题描述-v1和v2" class="headerlink" title="问题描述(v1和v2)"></a>问题描述(v1和v2)</h3><p>Android 7.0中引入了APK Signature Scheme v2，v1呢是jar Signature来自JDK<br>V1：应该是通过ZIP条目进行验证，这样APK 签署后可进行许多修改 - 可以移动甚至重新压缩文件。<br>V2：验证压缩文件的所有字节，而不是单个 ZIP 条目，因此，在签名后无法再更改(包括 zipalign)。正因如此，现在在编译过程中，我们将压缩、调整和签署合并成一步完成。好处显而易见，更安全而且新的签名可缩短在设备上进行验证的时间（不需要费时地解压缩然后验证），从而加快应用安装速度。</p><h3 id="解决方案一"><a href="#解决方案一" class="headerlink" title="解决方案一"></a>解决方案一</h3><p>v1和v2的签名使用<br>只勾选v1签名并不会影响什么，但是在7.0上不会使用更安全的验证方式<br>只勾选V2签名7.0以下会直接安装完显示未安装，7.0以上则使用了V2的方式验证<br>同时勾选V1和V2则所有机型都没问题</p><h3 id="解决方案二"><a href="#解决方案二" class="headerlink" title="解决方案二"></a>解决方案二</h3><p>在app的build.gradle的android标签下加入如下</p><div class="hljs"><pre><code class="hljs nginx"><span class="hljs-section">signingConfigs</span> &#123;    <span class="hljs-section">debug</span> &#123;        <span class="hljs-attribute">v1SigningEnabled</span> <span class="hljs-literal">true</span>        v2SigningEnabled <span class="hljs-literal">true</span>    &#125;    release &#123;        <span class="hljs-attribute">v1SigningEnabled</span> <span class="hljs-literal">true</span>        v2SigningEnabled <span class="hljs-literal">true</span>    &#125;&#125;</code></pre></div>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>WDYDT-10-搞到系统签名和remoteView的坑</title>
    <link href="/2018/08/01/WDYDT-10-%E6%90%9E%E5%88%B0%E7%B3%BB%E7%BB%9F%E7%AD%BE%E5%90%8D%E5%92%8CremoteView%E7%9A%84%E5%9D%91/"/>
    <url>/2018/08/01/WDYDT-10-%E6%90%9E%E5%88%B0%E7%B3%BB%E7%BB%9F%E7%AD%BE%E5%90%8D%E5%92%8CremoteView%E7%9A%84%E5%9D%91/</url>
    
    <content type="html"><![CDATA[<!-- abstract area --><p>由于miui的一个广播的权限是SignatureOrSystem，所以我想拿到这个广播就要系统签名，所以我从网上找到了一个根据系统签名文件生成keystore的方法。</p><a id="more"></a><h3 id="系统签名APP"><a href="#系统签名APP" class="headerlink" title="系统签名APP"></a>系统签名APP</h3><p>首先你要找的系统的签名存放地址：<br>/build/target/product/security/</p><p>如果直接用这个签名给APP签名可以用一下命令：</p><div class="hljs"><pre><code class="hljs css"><span class="hljs-selector-tag">java</span> <span class="hljs-selector-tag">-jar</span> <span class="hljs-selector-tag">signapk</span><span class="hljs-selector-class">.jar</span> <span class="hljs-selector-tag">platform</span><span class="hljs-selector-class">.x509</span><span class="hljs-selector-class">.pem</span> <span class="hljs-selector-tag">platform</span><span class="hljs-selector-class">.pk8</span> <span class="hljs-selector-tag">XXX</span><span class="hljs-selector-class">.apk</span> <span class="hljs-selector-tag">XXXNew</span><span class="hljs-selector-class">.apk</span></code></pre></div><p>如果想生成keystore，需要一下命令</p><div class="hljs"><pre><code class="hljs delphi"># openssl pkcs8 -inform DER -nocrypt -<span class="hljs-keyword">in</span> <span class="hljs-keyword">platform</span>.pk8 -<span class="hljs-keyword">out</span> <span class="hljs-keyword">platform</span>.pem# 设置的密码是android <span class="hljs-keyword">name</span>是androiddebugkeyopenssl pkcs12 -<span class="hljs-keyword">export</span> -<span class="hljs-keyword">in</span> <span class="hljs-keyword">platform</span>.x509.pem -<span class="hljs-keyword">out</span> <span class="hljs-keyword">platform</span>.p12 -inkey <span class="hljs-keyword">platform</span>.pem -password pass:android -<span class="hljs-keyword">name</span> androiddebugkey#生成<span class="hljs-keyword">platform</span>.keystorekeytool -importkeystore -deststorepass android -destkeystore ./<span class="hljs-keyword">platform</span>.keystore -srckeystore <span class="hljs-keyword">platform</span>.p12 -srcstoretype PKCS12 -srcstorepass android</code></pre></div><p>参考：</p><blockquote><p><a href="https://blog.csdn.net/QQxiaoqiang1573/article/details/52252843" target="_blank" rel="noopener">https://blog.csdn.net/QQxiaoqiang1573/article/details/52252843</a><br><a href="http://www.cnblogs.com/blairsProgrammer/p/4220904.html" target="_blank" rel="noopener">http://www.cnblogs.com/blairsProgrammer/p/4220904.html</a><br>权限相关 <a href="https://blog.csdn.net/jltxgcy/article/details/48288467" target="_blank" rel="noopener">https://blog.csdn.net/jltxgcy/article/details/48288467</a> </p></blockquote><p>然后你就可以配置gradle实现自动签名了，配置如下：</p><div class="hljs"><pre><code class="hljs nginx"><span class="hljs-section">android</span> &#123;    <span class="hljs-section">signingConfigs</span> &#123;        <span class="hljs-section">androiddebugkey</span> &#123;            <span class="hljs-attribute">keyAlias</span> <span class="hljs-string">'you key name'</span>            keyPassword <span class="hljs-string">'you password'</span>            storeFile file(<span class="hljs-string">'../testkey-signer/platform.keystore'</span>)            storePassword <span class="hljs-string">'you password'</span>        &#125;    &#125;    buildTypes &#123;        <span class="hljs-section">release</span> &#123;            <span class="hljs-attribute">minifyEnabled</span> <span class="hljs-literal">false</span>            proguardFiles getDefaultProguardFile(<span class="hljs-string">'proguard-android.txt'</span>), <span class="hljs-string">'proguard-rules.pro'</span>            signingConfig signingConfigs.androiddebugkey        &#125;        <span class="hljs-literal">debug</span> &#123;            <span class="hljs-attribute">signingConfig</span> signingConfigs.androiddebugkey        &#125;    &#125;</code></pre></div><p>注意 signingConfigs 必须放到buildTypes前面，不然会报错，原因和声明顺序有关。</p><h3 id="RemoteView的一个坑"><a href="#RemoteView的一个坑" class="headerlink" title="RemoteView的一个坑"></a>RemoteView的一个坑</h3><p>RemoteView被使用在notification和widget中，可以设置点击事件，一般有两种setOnClickPendingIntent和setOnClickFillInIntent。<br>其中setOnClickPendingIntent是传入PendingIntent，setOnClickFillInIntent传入Intent。<br>但是！！！<br>setOnClickPendingIntent是不支持LisetView的。<br>如果在listview的情况在使用setOnClickFillInIntent，传入的intent只会被AppWidgetProvider(其实这是个BroadcastReceiver)接收。</p><p>一下是SDK中的代码:</p><div class="hljs"><pre><code class="hljs zephir">package android.widget;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RemoteViews</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Parcelable</span>, <span class="hljs-title">Filter</span> </span>&#123;     <span class="hljs-comment">/**</span><span class="hljs-comment">     * Equivalent to calling</span><span class="hljs-comment">     * &#123;<span class="hljs-doctag">@link</span> android.view.View#setOnClickListener(android.view.View.OnClickListener)&#125;</span><span class="hljs-comment">     * to launch the provided &#123;<span class="hljs-doctag">@link</span> PendingIntent&#125;.</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * When setting the on-click action of items within collections (eg. &#123;<span class="hljs-doctag">@link</span> ListView&#125;,</span><span class="hljs-comment">     * &#123;<span class="hljs-doctag">@link</span> StackView&#125; etc.), this method will not work. Instead, use &#123;<span class="hljs-doctag">@link</span></span><span class="hljs-comment">     * RemoteViews#setPendingIntentTemplate(int, PendingIntent)&#125; in conjunction with</span><span class="hljs-comment">     * &#123;<span class="hljs-doctag">@link</span> RemoteViews#setOnClickFillInIntent(int, Intent)&#125;.</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> viewId The id of the view that will trigger the &#123;<span class="hljs-doctag">@link</span> PendingIntent&#125; when clicked</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> pendingIntent The &#123;<span class="hljs-doctag">@link</span> PendingIntent&#125; to send when user clicks</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">public</span> void setOnClickPendingIntent(<span class="hljs-keyword">int</span> viewId, PendingIntent pendingIntent) &#123;        addAction(<span class="hljs-keyword">new</span> SetOnClickPendingIntent(viewId, pendingIntent));    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * When using collections (eg. &#123;<span class="hljs-doctag">@link</span> ListView&#125;, &#123;<span class="hljs-doctag">@link</span> StackView&#125; etc.) in widgets, it is very</span><span class="hljs-comment">     * costly to set PendingIntents on the individual items, and is hence not permitted. Instead</span><span class="hljs-comment">     * this method should be used to set a single PendingIntent template on the collection, and</span><span class="hljs-comment">     * individual items can differentiate their on-click behavior using</span><span class="hljs-comment">     * &#123;<span class="hljs-doctag">@link</span> RemoteViews#setOnClickFillInIntent(int, Intent)&#125;.</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> viewId The id of the collection who's children will use this PendingIntent template</span><span class="hljs-comment">     *          when clicked</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> pendingIntentTemplate The &#123;<span class="hljs-doctag">@link</span> PendingIntent&#125; to be combined with extras specified</span><span class="hljs-comment">     *          by a child of viewId and executed when that child is clicked</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">public</span> void setPendingIntentTemplate(<span class="hljs-keyword">int</span> viewId, PendingIntent pendingIntentTemplate) &#123;        addAction(<span class="hljs-keyword">new</span> SetPendingIntentTemplate(viewId, pendingIntentTemplate));    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * When using collections (eg. &#123;<span class="hljs-doctag">@link</span> ListView&#125;, &#123;<span class="hljs-doctag">@link</span> StackView&#125; etc.) in widgets, it is very</span><span class="hljs-comment">     * costly to set PendingIntents on the individual items, and is hence not permitted. Instead</span><span class="hljs-comment">     * a single PendingIntent template can be set on the collection, see &#123;<span class="hljs-doctag">@link</span></span><span class="hljs-comment">     * RemoteViews#setPendingIntentTemplate(int, PendingIntent)&#125;, and the individual on-click</span><span class="hljs-comment">     * action of a given item can be distinguished by setting a fillInIntent on that item. The</span><span class="hljs-comment">     * fillInIntent is then combined with the PendingIntent template in order to determine the final</span><span class="hljs-comment">     * intent which will be executed when the item is clicked. This works as follows: any fields</span><span class="hljs-comment">     * which are left blank in the PendingIntent template, but are provided by the fillInIntent</span><span class="hljs-comment">     * will be overwritten, and the resulting PendingIntent will be used. The rest</span><span class="hljs-comment">     * of the PendingIntent template will then be filled in with the associated fields that are</span><span class="hljs-comment">     * set in fillInIntent. See &#123;<span class="hljs-doctag">@link</span> Intent#fillIn(Intent, int)&#125; for more details.</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> viewId The id of the view on which to set the fillInIntent</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> fillInIntent The intent which will be combined with the parent's PendingIntent</span><span class="hljs-comment">     *        in order to determine the on-click behavior of the view specified by viewId</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">public</span> void setOnClickFillInIntent(<span class="hljs-keyword">int</span> viewId, Intent fillInIntent) &#123;        addAction(<span class="hljs-keyword">new</span> SetOnClickFillInIntent(viewId, fillInIntent));    &#125;&#125;</code></pre></div>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>WDYDT-9-Java性能优化权威指南</title>
    <link href="/2018/07/24/WDYDT-9-Java%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/"/>
    <url>/2018/07/24/WDYDT-9-Java%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/</url>
    
    <content type="html"><![CDATA[<!-- abstract area --><a id="more"></a><p>读了第一章了 还没啥感觉</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>WDYDT-8-一个关于简历的讨论</title>
    <link href="/2018/07/24/WDYDT-8-%E4%B8%80%E4%B8%AA%E5%85%B3%E4%BA%8E%E7%AE%80%E5%8E%86%E7%9A%84%E8%AE%A8%E8%AE%BA/"/>
    <url>/2018/07/24/WDYDT-8-%E4%B8%80%E4%B8%AA%E5%85%B3%E4%BA%8E%E7%AE%80%E5%8E%86%E7%9A%84%E8%AE%A8%E8%AE%BA/</url>
    
    <content type="html"><![CDATA[<!-- abstract area --><p>今天看到了这个贴子：</p><blockquote><p><a href="https://www.v2ex.com/t/473303" target="_blank" rel="noopener">https://www.v2ex.com/t/473303</a></p></blockquote><a id="more"></a><p>楼主说这种内容不要往简历上写了</p><blockquote><p>了解 tcp/ip,<br>了解 git 控制,<br>熟悉在 Linux 环境下编程,<br>了解 MVC, </p></blockquote><p>理由是写了这些, 没啥用, 不疼不痒. </p><p>我感觉这个楼主也是个大牛，他对这种简历有独特的看法</p><p>而大家的评论并没有赞成楼主，而是换了一个角度进行反驳，那就是hr并不懂技术，hr可能会根据这些关键字去搜索简历。</p><p>我感觉有些东西还是要写的，但是写上去的东西一定要自己会，而且比较熟悉。我就吃过这方面的亏，写了好多东西，但是自己又不是特别的深入，然后就被面试官拿着我自己的简历虐了一遍。</p><p>no zuo no die</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>WDYDT-7-先学什么的矛盾</title>
    <link href="/2018/07/23/WDYDT-7-%E5%85%88%E5%AD%A6%E4%BB%80%E4%B9%88%E7%9A%84%E7%9F%9B%E7%9B%BE/"/>
    <url>/2018/07/23/WDYDT-7-%E5%85%88%E5%AD%A6%E4%BB%80%E4%B9%88%E7%9A%84%E7%9F%9B%E7%9B%BE/</url>
    
    <content type="html"><![CDATA[<!-- abstract area --><p>最近看了看C++，然后又荒废了，基础部分还没看完，然后突然发现了几本Java的好书，打算看一下。不知道这样做好不好，不知道下次学C++是什么时候了。</p><a id="more"></a><p>最近发现的基本好书是这几本，如果是大佬的话，应该都看过。</p><ul><li>Effective Java</li><li>Java并发编程实战.pdf</li><li>Java性能优化权威指南.pdf</li><li>ThinkinJava.pdf</li><li>深入理解Java虚拟机 JVM高级特性与最佳实践.pdf</li><li>鸟哥Linux.pdf</li></ul><p>从网上找了资源，都是PDF，由于是盗版就不分享了，有钱的话还是买正版的吧。</p><p>学习顺序呢，我打算先从薄的开始看。</p><p>大体上就是这样吧，还要考驾照，还有一个科目四没考。加油。</p><p>C++我一定要学！！</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>WDYDT-6-五个关于C++的神话</title>
    <link href="/2018/07/13/WDYDT-6-%E4%BA%94%E4%B8%AA%E5%85%B3%E4%BA%8EC-%E7%9A%84%E7%A5%9E%E8%AF%9D/"/>
    <url>/2018/07/13/WDYDT-6-%E4%BA%94%E4%B8%AA%E5%85%B3%E4%BA%8EC-%E7%9A%84%E7%A5%9E%E8%AF%9D/</url>
    
    <content type="html"><![CDATA[<!-- abstract area --><p>对于学C++学崩溃的人可以看看，挺好的</p><a id="more"></a><h3 id="“Five-Popular-Myths-about-C-”"><a href="#“Five-Popular-Myths-about-C-”" class="headerlink" title="“Five Popular Myths about C++”"></a>“Five Popular Myths about C++”</h3><h3 id="Myth-1-“To-understand-C-you-must-first-learn-C”"><a href="#Myth-1-“To-understand-C-you-must-first-learn-C”" class="headerlink" title="Myth 1: “To understand C++, you must first learn C”"></a>Myth 1: “To understand C++, you must first learn C”</h3><p>想要理解c++,必须先学c</p><p>No. Learning basic programming using C++ is far easier than with C.</p><p>这是不对的，c++基础编程的学习要远远比 c 容易</p><p>C is almost a subset of C++, but it is not the best subset to learn first because C lacks the notational support, the type safety, and the easier-to-use standard library offered by C++ to simplify simple tasks. Consider a trivial function to compose an email address:</p><p>c 可以看作是 c++ 的一部分，但并不是最容易学的那部分，因为 c 没有运算符重载，没有类型安全，也没有用起来更加方便的 c++ 的标准库，这些库可以大大简化工作。试着考虑做一个组合电邮地址的小功能函数：</p><p>c++的代码：</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">compose</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp; name, <span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp; domain)</span></span><span class="hljs-function"></span>&#123;  <span class="hljs-keyword">return</span> name+<span class="hljs-string">'@'</span>+domain;&#125;</code></pre></div><p>It can be used like this<br>这样使用</p><div class="hljs"><pre><code class="hljs armasm"><span class="hljs-keyword">string </span><span class="hljs-keyword">addr </span>= compose(<span class="hljs-string">"gre"</span>,<span class="hljs-string">"research.att.com"</span>)<span class="hljs-comment">;</span></code></pre></div><p>The C version requires explicit manipulation of characters and explicit memory management:<br>c版本就需要显式的字符控制和显式的内存管理，代码如下：</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">char</span>* <span class="hljs-title">compose</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* name, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* domain)</span></span><span class="hljs-function"></span>&#123;  <span class="hljs-keyword">char</span>* res = <span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">strlen</span>(name)+<span class="hljs-built_in">strlen</span>(domain)+<span class="hljs-number">2</span>); <span class="hljs-comment">// space for strings, '@', and 0</span>  <span class="hljs-keyword">char</span>* p = <span class="hljs-built_in">strcpy</span>(res,name);  p += <span class="hljs-built_in">strlen</span>(name);  *p = <span class="hljs-string">'@'</span>;  <span class="hljs-built_in">strcpy</span>(p+<span class="hljs-number">1</span>,domain);  <span class="hljs-keyword">return</span> res;&#125;</code></pre></div><p>It can be used like this<br>使用时是这样的</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-keyword">char</span>* addr = compose(<span class="hljs-string">"gre"</span>,<span class="hljs-string">"research.att.com"</span>);<span class="hljs-comment">// …</span><span class="hljs-comment">// release memory when done</span><span class="hljs-comment">// 最后使用完，记得释放内存</span><span class="hljs-built_in">free</span>(addr);</code></pre></div><p>Which version would you rather teach? Which version is easier to use? Did I really get the C version right? Are you sure? Why?<br>你愿意教哪个版本？哪一个用起来更简单？我的c代码写对了吗？你确定？为什么？</p><p>Finally, which version is likely to be the most efficient? Yes, the C++ version, because it does not have to count the argument characters and does not use the free store (dynamic memory) for short argument strings.<br>最后，哪一个版本更高效？当然是 c++了，因为它不需要计算字符的长度，也不要申请、释放动态内存</p><h4 id="Learning-C"><a href="#Learning-C" class="headerlink" title="Learning C++"></a>Learning C++</h4><p>c++ 的学习</p><p>This is not an odd isolated example. I consider it typical. So why do so many teachers insist on the “C first” approach?<br>这不是一个稀奇的特例，我觉得它很典型。但为什么仍然有这么多老师要坚持用 c 入门呢？</p><ul><li><p>Because that’s what they have done for ages.<br>因为他们经验丰富</p></li><li><p>Because that’s what the curriculum requires.<br>因为课程要求</p></li><li><p>Because that’s the way the teachers learned it in their youth.<br>因为他们年轻时老师也这么教</p></li><li><p>Because C is smaller than C++ it is assumed to be simpler to use.<br>因为c 比 c++ “小”，它用起来应该比 c++ 更简单 </p></li><li><p>Because the students have to learn C (or the C subset of C++) sooner or later anyway.<br>因为这些学生早晚要学 c</p></li></ul><p>However, C is not the easiest or most useful subset of C++ to learn first. Furthermore, once you know a reasonable amount of C++, the C subset is easily learned. Learning C before C++ implies suffering errors that are easily avoided in C++ and learning techniques for mitigating them.<br>可是，c “作为 c++ 的一部分”在初期的学习中并不是最容易最有用的。另外，一旦你懂了一些 c++ 后，再去学c会更容易。先学习 c,经常掉入陷阱，但这些陷阱在 c++ 中可以轻易的避免或通过其他技术弱化。</p><p>For a modern approach to teaching C++, see my Programming: Principles and Practice Using C++ [13]. It even has a chapter at the end showing how to use C. It has been used, reasonably successfully, with tens of thousands of beginning students in several universities. Its second edition uses C++11 and C++14 facilities to ease learning.<br>对于c++教学的现代方法，参考《Programming: Principles and Practice Using C++》第二版。在最后有一章展示如何使用 c.成千上万的大学初学者已经开始使用,毫无疑问，它很有效。在第二版中使用 c++11 和 c++14的工具使学习更容易。</p><p>With C++11 [11-12], C++ has become more approachable for novices. For example, here is standard-library vector initialized with a sequence of elements:<br>新版的c++11 对于新手更容易上手。举个例子，用初始化列表初始化 vector </p><div class="hljs"><pre><code class="hljs angelscript">vector&lt;<span class="hljs-built_in">int</span>&gt; v = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">8</span>,<span class="hljs-number">13</span>&#125;;</code></pre></div><p>In C++98, we could only initialize arrays with lists. In C++11, we can define a constructor to accept a {} initializer list for any type for which we want one.<br>在 c++98,我们只能用初始化列表初始化数组，而在c++11中，我们可以为任何需要的类型定义一个接受初始化列表的构造函数</p><p>We could traverse that vector with a range-for loop:<br>我们可以用范围 for 循环遍历这个 vector</p><div class="hljs"><pre><code class="hljs lisp">for(<span class="hljs-name">int</span> x : v) test(<span class="hljs-name">x</span>)<span class="hljs-comment">;</span></code></pre></div><p>This will call test() once for each element of v.<br>每一个 v 中的元素都会调用一次test();</p><p>A range-for loop can traverse any sequence, so we could have simplified that example by using the initializer list directly:<br>范围 for 循环可以遍历任何序列，所以我们可以简化一下刚才的例子，直接使用初始化列表</p><div class="hljs"><pre><code class="hljs angelscript"><span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> x : &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">8</span>,<span class="hljs-number">13</span>&#125;) test(x);</code></pre></div><p>One of the aims of C++11 was to make simple things simple. Naturally, this is done without adding performance penalties.</p><p>c++11 的一个目的就是将简单的事情简单化，当然，这样做不会带有额外的性能损失</p><h3 id="Myth-2-“C-is-an-Object-Oriented-Language”"><a href="#Myth-2-“C-is-an-Object-Oriented-Language”" class="headerlink" title="Myth 2: “C++ is an Object-Oriented Language”"></a>Myth 2: “C++ is an Object-Oriented Language”</h3><p>c++ 是面向对象的语言</p><p>No. C++ supports OOP and other programming styles, but is deliberately not limited to any narrow view of “Object Oriented.” It supports a synthesis of programming techniques including object-oriented and generic programming. More often than not, the best solution to a problem involves more than one style (“paradigm”). By “best,” I mean shortest, most comprehensible, most efficient, most maintainable, etc.<br>不完全正确，c++ 不仅支持面向对象还支持其他编程方式，不能刻意地限制于面向对象狭隘的层面。它支持一套组合编程技术包括面向对象和泛型编程。通常情况下，一个问题最佳的解决方案涉及多种风格。我说的最佳，意思是代码更简洁，容易理解，更加高效，更容易维护等等</p><p>The “C++ is an OOPL” myth leads people to consider C++ unnecessary (when compared to C) unless you need large class hierarchies with many virtual (run-time polymorphic) functions – and for many people and for many problems, such use is inappropriate. Believing this myth leads others to condemn C++ for not being purely OO; after all, if you equate “good” and “object-oriented,” C++ obviously contains much that is not OO and must therefore be deemed “not good.” In either case, this myth provides a good excuse for not learning C++.<br>这种观点使人们认为 c++ 相对 c 来说，不是那么必须，除非你需要一个庞大的类层次，并且带有许多虚函数（运行时多态）。对于许多人和许多问题来说，这样使用并不合适。这个流言导致人们的谴责 c++ ，因为它的面向对象不够彻底。毕竟，如果你认为好就是面向对象，显然 c++ 包含更多的非面向对象的东西，因此被认为是不好的，这也为不要学习c++ 提供了一个好的借口。</p><p>Consider an example:<br>考虑这样一个例子</p><div class="hljs"><pre><code class="hljs reasonml">void rotate<span class="hljs-constructor">_and_draw(<span class="hljs-params">vector</span>&lt;Shape<span class="hljs-operator">*</span>&gt;&amp; <span class="hljs-params">vs</span>, <span class="hljs-params">int</span> <span class="hljs-params">r</span>)</span>&#123;  for<span class="hljs-constructor">_each(<span class="hljs-params">vs</span>.<span class="hljs-params">begin</span>()</span>,vs.<span class="hljs-keyword">end</span><span class="hljs-literal">()</span>, <span class="hljs-literal">[]</span>(Shape* p) &#123; p-&gt;rotate(r); &#125;);  <span class="hljs-comment">// rotate all elements of vs</span>  for (Shape* p : vs) p-&gt;draw<span class="hljs-literal">()</span>;                                  <span class="hljs-comment">// draw all elements of vs</span>&#125;</code></pre></div><p>Is this object-oriented? Of course it is; it relies critically on a class hierarchy with virtual functions. It is generic? Of course it is; it relies critically on a parameterized container (vector) and the generic function for_each. Is this functional? Sort of; it uses a lambda (the [] construct). So what is it?  It is modern C++: C++11.<br>这是面向对象吗？当然是，它很大程度上依赖带有虚函数的类层次结构。它是泛型吗？当然是拉，它同样依赖于参数化的模板容器 vector 和泛型函数 for_each.它是函数式的吗？它使用了 lambda 表达式，这点来说也算是。那么它到底是什么类型的？它就是现代的c++,c++11.</p><p>I used both the range-for loop and the standard-library algorithm for_each just to show off features. In real code, I would have use only one loop, which I could have written either way.<br>我同时使用了 范围 for 循环和标准库的算法 for_each ，仅仅是为了展示一下这个特性，实际中，我只会用一种循环，用另一种写法</p><h4 id="Generic-Programming"><a href="#Generic-Programming" class="headerlink" title="Generic Programming"></a>Generic Programming</h4><p>泛型编程</p><p>Would you like this code more generic? After all, it works only for vectors of pointers to Shapes. How about lists and built-in arrays? What about “smart pointers” (resource-management pointers), such as shared_ptr and unique_ptr? What about objects that are not called Shape that you can draw() and rotate()? Consider:<br>你想让这段代码再通用一点吗（模版化，泛型）？毕竟，它只是用于形状的容器指针。列表和内置数组会怎样呢？像 shared_ptr 和 unique_ptr 的智能指针呢？那些不叫 Shape 的类可以用 draw() 和 rotate() 吗？想一想：</p><div class="hljs"><pre><code class="hljs maxima">template&lt;typename Iter&gt;void rotate_and_draw(Iter <span class="hljs-built_in">first</span>, Iter <span class="hljs-built_in">last</span>, int r)&#123;  for_each(<span class="hljs-built_in">first</span>,<span class="hljs-built_in">last</span>,[](auto p) &#123; p-&gt;rotate(r); &#125;);  // rotate all elements of [<span class="hljs-built_in">first</span>:<span class="hljs-built_in">last</span>)  <span class="hljs-keyword">for</span> (auto p = <span class="hljs-built_in">first</span>; p!=<span class="hljs-built_in">last</span>; ++p) p-&gt;<span class="hljs-built_in">draw</span>();       // <span class="hljs-built_in">draw</span> all elements of [<span class="hljs-built_in">first</span>:<span class="hljs-built_in">last</span>)&#125;</code></pre></div><p>This works for any sequence you can iterate through from first to last. That’s the style of the C++ standard-library algorithms. I used auto to avoid having to name the type of the interface to “shape-like objects.” That’s a C++11 feature meaning “use the type of the expression used as initializer,” so for the for-loop p’s type is deduced to be whatever type first is. The use of auto to denote the argument type of a lambda is a C++14 feature, but already in use.<br>这段代码适用于任何可以从头到尾迭代的序列。这就是c++ 标准库算法的风格。我使用了 auto 关键字避免为类似 Shape 对象的接口类型命名。这是c++11的一个特性，意思是使用表达式的类型作为初始化类型，对于 for 循环来说，指针 p 的类型是由 Iter first 的类型得出的。使用 auto 表示 lambda 表达式参数的类型，是c++14的特征，但是现在已经可以用了。</p><p>Consider:<br>思考一下：</p><div class="hljs"><pre><code class="hljs reasonml">void user(<span class="hljs-built_in">list</span>&lt;unique_ptr&lt;Shape&gt;&gt;&amp; lus, Container&lt;Blob&gt;&amp; vb)&#123;rotate<span class="hljs-constructor">_and_draw(<span class="hljs-params">lst</span>.<span class="hljs-params">begin</span>()</span>,lst.<span class="hljs-keyword">end</span><span class="hljs-literal">()</span>);rotate<span class="hljs-constructor">_and_draw(<span class="hljs-params">begin</span>(<span class="hljs-params">vb</span>)</span>,<span class="hljs-keyword">end</span>(vb));&#125;</code></pre></div><p>Here, I assume that Blob is some graphical type with operations draw() and rotate() and that Container is some container type. The standard-library list (std::list) has member functions begin() and end() to help the user traverse its sequence of elements. That’s nice and classical OOP. But what if Container is something that does not support the C++ standard library’s notion of iterating over a half-open sequence, [b:e)? Something that does not have begin() and end() members? Well, I have never seen something container-like, that I couldn’t traverse, so we can define free-standing begin() and end() with appropriate semantics. The standard library provides that for C-style arrays, so if Container is a C-style array, the problem is solved – and C-style arrays are still very common.<br>在这段代码里，我假设 Bolb 是一个图像类型，带有draw() and rotate()，Container 是任意的容器类型。标准库的 list 有2个成员函数 begin() end() ,可以用于函数 user 遍历它序列中元素。这是典型的 面向对象编程。但是，如果类型 Container 不支持 c++ 标准里半开区间的迭代概念呢？或者没有 begin() end()的成员呢？当然，我从没见过容器类型不能遍历，那么我们可以自定义合适的 begin() end().标准库为 c 风格的数组提供了上面的成员，所以即便 Container 是c 风格的数组，问题也可以解决，c 风格的数组仍然常用。</p><h4 id="Adaptation"><a href="#Adaptation" class="headerlink" title="Adaptation"></a>Adaptation</h4><p>适用性</p><p>Consider a harder case: What if Container holds pointers to objects and has a different model for access and traversal? For example, assume that you are supposed to access a Container like this<br>思考一个复杂的情况，如果 Container 存储对象的指针，有一套不同访问和遍历方式。举例，假设你可以这样访问 Container 的元素</p><div class="hljs"><pre><code class="hljs coq"><span class="hljs-keyword">for</span> (<span class="hljs-built_in">auto</span> p = c.<span class="hljs-built_in">first</span>(); p!=nullptr; p=c.next()) &#123; /* <span class="hljs-built_in">do</span> something <span class="hljs-built_in">with</span> *p */&#125;</code></pre></div><p>This style is not uncommon. We can map it to a [b:e) sequence like this<br>这种样式不常见，我们将区间指针做映射像下面这样</p><div class="hljs"><pre><code class="hljs elm"><span class="hljs-title">template</span>&lt;typename <span class="hljs-type">T</span>&gt; struct <span class="hljs-type">Iter</span> &#123;  <span class="hljs-type">T</span>* current;  <span class="hljs-type">Container</span>&lt;<span class="hljs-type">T</span>&gt;&amp; c;&#125;; <span class="hljs-title">template</span>&lt;typename <span class="hljs-type">T</span>&gt; <span class="hljs-type">Iter</span>&lt;<span class="hljs-type">T</span>&gt; begin(<span class="hljs-type">Container</span>&lt;<span class="hljs-type">T</span>&gt;&amp; c) &#123; return <span class="hljs-type">Iter</span>&lt;<span class="hljs-type">T</span>&gt;&#123;c.first(),c&#125;; &#125;<span class="hljs-title">template</span>&lt;typename <span class="hljs-type">T</span>&gt; <span class="hljs-type">Iter</span>&lt;<span class="hljs-type">T</span>&gt; end(<span class="hljs-type">Container</span>&lt;<span class="hljs-type">T</span>&gt;&amp; c)   &#123; return <span class="hljs-type">Iter</span>&lt;<span class="hljs-type">T</span>&gt;&#123;nullptr&#125;; &#125;<span class="hljs-title">template</span>&lt;typename <span class="hljs-type">T</span>&gt; <span class="hljs-type">Iter</span>&lt;<span class="hljs-type">T</span>&gt; operator++(<span class="hljs-type">Iter</span>&lt;<span class="hljs-type">T</span>&gt; p)  &#123; p.current = c.next(); return this; &#125;<span class="hljs-title">template</span>&lt;typename <span class="hljs-type">T</span>&gt; <span class="hljs-type">T</span>*      operator*(<span class="hljs-type">Iter</span>&lt;<span class="hljs-type">T</span>&gt; p)   &#123; return p.current; &#125;</code></pre></div><p>Note that this is modification is nonintrusive: I did not have to make changes to Container or some Container class hierarchy to map Container into the model of traversal supported by the C++ standard library. It is a form of adaptation, rather than a form of refactoring.<br>注意这个修改是无关紧要的，我并没有为了把容器映射成c++ 标准库支持的迭代的模型而改写容器或容器类的层次机构。这只是一种改写的形式并不算重构。</p><p>I chose this example to show that these generic programming techniques are not restricted to the standard library (in which they are pervasive). Also, for most common definitions of “object oriented,” they are not object-oriented.<br>我选择这个例子是为了说明泛型编程技术并不只在标准库中广泛使用。对于一些很普通的面向对象的定义，其实他们并不是面向对象的</p><p>The idea that C++ code must be object-oriented (meaning use hierarchies and virtual functions everywhere) can be seriously damaging to performance. That view of OOP is great if you need run-time resolution of a set of types. I use it often for that. However, it is relatively rigid (not every related type fits into a hierarchy) and a virtual function call inhibits inlining (and that can cost you a factor of 50 in speed in simple and important cases).<br>c++ 必须是面向对象（层次结构和虚函数的滥用）的想法会严重危害到性能评价。如果你需要运行时解决一组类型时，OOP是非常棒的。我经常这样用。但是它相对也比较死板（不是所有相关的类型都刚好嵌入同一层次结构）而且虚函数会抑制内联（在处理简单重要的工作时，这回大大增加耗时）</p><h3 id="Myth-3-“For-reliable-software-you-need-Garbage-Collection”"><a href="#Myth-3-“For-reliable-software-you-need-Garbage-Collection”" class="headerlink" title="Myth 3: “For reliable software, you need Garbage Collection”"></a>Myth 3: “For reliable software, you need Garbage Collection”</h3><p>作为可以信赖的软件，垃圾回收机制不可少</p><p>Garbage collection does a good, but not perfect, job at reclaiming unused memory. It is not a panacea. Memory can be retained indirectly and many resources are not plain memory. Consider:<br>在回收未使用的内存上，垃圾回收机制做得很好，但不完美，它并不是万能的。内存可以被间接保留而且许多资源并不是简单的内存问题。</p><div class="hljs"><pre><code class="hljs angelscript"><span class="hljs-comment">// take input from file iname and produce output on file oname</span><span class="hljs-comment">//从文件 iname 读入，输出到文件 oname</span><span class="hljs-keyword">class</span> <span class="hljs-symbol">Filter</span> &#123; <span class="hljs-keyword">public</span>:  Filter(<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp; iname, <span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp; oname); <span class="hljs-comment">// constructor</span>  ~Filter();                                        <span class="hljs-comment">// destructor</span>  <span class="hljs-comment">// ...</span><span class="hljs-keyword">private</span>:  ifstream <span class="hljs-keyword">is</span>;  ofstream os;  <span class="hljs-comment">// ...</span>&#125;;</code></pre></div><p>This Filter’s constructor opens two files. That done, the Filter performs some task on input from its input file producing output on its output file. The task could be hardwired into Filter, supplied as a lambda, or provided as a function that could be provided by a derived class overriding a virtual function. Those details are not important in a discussion of resource management. We can create Filters like this:<br>Filter 类的构造函数打开2个文件，然后执行读入输入文件、输入结果保存到输出文件的任务。这些任务可能包括硬连接 Filter，提供 lambda 表达式，或者提供一个覆盖派生类虚函数的函数。讨论资源管理的这些细节并不重要。我们可以这样创建 Filter 对象。</p><div class="hljs"><pre><code class="hljs pgsql"><span class="hljs-type">void</span> <span class="hljs-keyword">user</span>()&#123;  <span class="hljs-keyword">Filter</span> flt &#123;“books”,”authors”&#125;;  <span class="hljs-keyword">Filter</span>* p = <span class="hljs-built_in">new</span> <span class="hljs-keyword">Filter</span>&#123;“novels”,”favorites”&#125;;  // use flt <span class="hljs-keyword">and</span> *p  <span class="hljs-keyword">delete</span> p;&#125;</code></pre></div><p>From a resource management point of view, the problem here is how to guarantee that the files are closed and the resources associated with the two streams are properly reclaimed for potential re-use.<br>从资源管理的角度看，问题在于如何保证文件已经正确关闭以及与2个流对象关联的资源如何重新使用</p><p>The conventional solution in languages and systems relying on garbage collection is to eliminate the delete (which is easily forgotten, leading to leaks) and the destructor (because garbage collected languages rarely have destructors and “finalizers” are best avoided because they can be logically tricky and often damage performance). A garbage collector can reclaim all memory, but we need user actions (code) to close the files and to release any non-memory resources (such as locks) associated with the streams. Thus memory is automatically (and in this case perfectly) reclaimed, but the management of other resources is manual and therefore open to errors and leaks.<br>对于依赖垃圾回收机制的语言和系统来说，方便的方法就是根除 delete（容易被忘记，导致溢出） 和 析构（垃圾回收机制的语言很少使用析构，finalizers 也最好避免因为它们逻辑古怪并且常常会影响性能）。垃圾回收器可以重用所有内存，但是需要用户手动关闭文件并释放与流对象相关的所有非内存资源。内存被自动回收了，但其他资源需要手动操作，那么就会带来报错和溢出的风险。</p><p>The common and recommended C++ approach is to rely on destructors to ensure that resources are reclaimed. Typically, such resources are acquired in a constructor leading to the awkward name “Resource Acquisition Is Initialization” (RAII) for this simple and general technique. In user(), the destructor for flt  implicitly calls the destructors for the streams is and os. These constructors in turn close the files and release the resources associated with the streams. The delete would do the same for *p.<br>c++通常推荐使用析构去确保资源被回收。通常，构造使用的这些资源来自RAII（获得资源就是初始化）这一简单普通的技术。在函数 user 中，flt 的析构隐式调用is 和os 流对象的析构。这些析构（原文 constructors，构造？）依次关闭文件释放流对象关联的资源。 delete 对指针同样这么做。</p><p>Experienced users of modern C++ will have noticed that user() is rather clumsy and unnecessarily error-prone. This would be better:<br>有 c++11 经验的用户可能已经注意到 user 函数相当笨拙并有出错的可能，这么写应该更好：</p><div class="hljs"><pre><code class="hljs arcade"><span class="hljs-keyword">void</span> user2()&#123;  <span class="hljs-built_in">Filter</span> flt &#123;“books”,”authors”&#125;;  unique_ptr&lt;<span class="hljs-built_in">Filter</span>&gt; p &#123;<span class="hljs-keyword">new</span> <span class="hljs-built_in">Filter</span>&#123;“novels”,”favorites”&#125;&#125;;  <span class="hljs-comment">// use flt and *p</span>&#125;</code></pre></div><p>Now *p will be implicitly released whenever user() is exited. The programmer cannot forget to do so. The unique_ptr is a standard-library class designed to ensure resource release without runtime or space overheads compared to the use of built-in “naked” pointers.<br>现在无论 user 何时退出，指针p指向的内存资源都会隐式释放。程序员应该记住这个方法，与内置指针不同，unique_ptr是一套可以保证资源释放后没有运行时和空间开销的标准库。</p><p>However, we can still see the new, this solution is a bit verbose (the type Filter is repeated), and separating the construction of the ordinary pointer (using new) and the smart pointer (here, unique_ptr) inhibits some significant optimizations. We can improve this by using a C++14 helper function make_unique that constructs an object of a specified type and returns a unique_ptr to it:<br>但是，我们仍然发现 new 的存在，新的方案有点啰嗦（Filter类型重复了），而且这种普通指针和智能指针的分隔结构掩盖了我们代码优化的意义（我觉得原文应该是这个意思），我们可以使用 c++14提供的函数继续优化，函数 make_unique 构造指定类型的对象，然后返回其unique_ptr</p><div class="hljs"><pre><code class="hljs arcade"><span class="hljs-keyword">void</span> user3()&#123;  <span class="hljs-built_in">Filter</span> flt &#123;“books”,”authors”&#125;;  auto p = make_unique&lt;<span class="hljs-built_in">Filter</span>&gt;(“novels”,”favorites”);  <span class="hljs-comment">// use flt and *p</span>&#125;</code></pre></div><p>Unless we really needed the second Filter to have pointer semantics (which is unlikely) this would be better still:<br>除非我们真的需要第二个Filter 对象的指针，否则下面的代码更好。</p><div class="hljs"><pre><code class="hljs arcade"><span class="hljs-keyword">void</span> user3()&#123;  <span class="hljs-built_in">Filter</span> flt &#123;“books”,”authors”&#125;;  <span class="hljs-built_in">Filter</span> flt2 &#123;“novels”,”favorites”&#125;;  <span class="hljs-comment">// use flt and flt2</span>&#125;</code></pre></div><p>This last version is shorter, simpler, clearer, and faster than the original.<br>最后一个版本最好，简单简洁快速。<br>But what does Filter’s destructor do? It releases the resources owned by a Filter; that is, it closes the files (by invoking their destructors). In fact, that is done implicitly, so unless something else is needed for Filter, we could eliminate the explicit mention of the Filter destructor and let the compiler handle it all. So, what I would have written was just:<br>但是 Filter 析构应该做些什么呢？释放一个 Filter 对象的资源；就是关闭文件（通过调用流对象的析构），实际上，这些是隐式完成的，除非对于 Filter 还要额外做些什么，否则我们不会显式定义其析构，都交给编译器默认生成。所以我只要这样写就可以了：</p><div class="hljs"><pre><code class="hljs angelscript"><span class="hljs-keyword">class</span> <span class="hljs-symbol">Filter</span> &#123; <span class="hljs-comment">// take input from file iname and produce output on file oname</span><span class="hljs-keyword">public</span>:  Filter(<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp; iname, <span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp; oname);  <span class="hljs-comment">// ...</span><span class="hljs-keyword">private</span>:  ifstream <span class="hljs-keyword">is</span>;  ofstream os;  <span class="hljs-comment">// ...</span>&#125;; <span class="hljs-built_in">void</span> user3()&#123;  Filter flt &#123;“books”,”authors”&#125;;  Filter flt2 &#123;“novels”,”favorites”&#125;;  <span class="hljs-comment">// use flt and flt2</span>&#125;</code></pre></div><p>This happens to be simpler than what you would write in most garbage collected languages (e.g., Java or C#) and it is not open to leaks caused by forgetful programmers. It is also faster than the obvious alternatives (no spurious use of the free/dynamic store and no need to run a garbage collector). Typically, RAII also decreases the resource retention time relative to manual approaches.<br>这比那些支持垃圾回收的语言写起来更简洁，对于健忘的程序员，也不会导致溢出。显然也比其他可选方案快很多（无需模拟自由、动态内存的存储，无需运行垃圾回收机制）。相对于手动操作，RAII 也降低了资源滞留的时间。<br>This is my ideal for resource management. It handles not just memory, but general (non-memory) resources, such as file handles, thread handles, and locks. But is it really general? How about objects that needs to be passed around from function to function? What about objects that don’t have an obvious single owner?<br>这是我理想的资源管理方法，不仅用于内存，还可以用于普通资源像文件句柄，线程句柄，锁等等。但它真的通用了吗？如果对象需要在函数间传递呢？如果对象没有一个明确的单一所属呢？</p><h4 id="Transferring-Ownership-move"><a href="#Transferring-Ownership-move" class="headerlink" title="Transferring Ownership: move"></a>Transferring Ownership: move</h4><p>所有权的移交：move</p><p>Let us first consider the problem of moving objects around from scope to scope. The critical question is how to get a lot of information out of a scope without serious overhead from copying or error-prone pointer use. The traditional approach is to use a pointer:<br>我们先来思考一下在域间移动对象的问题。关键点在于在不避免拷贝或易错指针等重大开销的情况下怎么在域外获取其信息。传统方法是使用指针：</p><div class="hljs"><pre><code class="hljs smali">X* make_X()&#123;  X* p =<span class="hljs-built_in"> new </span>X:  // ...<span class="hljs-built_in"> fill </span>X .. <span class="hljs-built_in"> return </span>p;&#125; void user()&#123;  X* q = make_X();  // ... use *q ...  delete q;&#125;</code></pre></div><p>Now who is responsible for deleting the object? In this simple case, obviously the caller of make_X() is, but in general the answer is not obvious. What if make_X() keeps a cache of objects to minimize allocation overhead? What if user() passed the pointer to some other_user()? The potential for confusion is large and leaks are not uncommon in this style of program.<br>现在谁负责指针的删除工作呢？在上例中，显然是 make_X 的调用者，但通常答案并不明确。如果为了降低开销，make_X 需要对象的缓存呢？如果 user 将指针传递给其他 other_user 呢？在这种编程风格中，极易混乱和溢出。</p><p>I could use a shared_ptr or a unique_ptr to be explicit about the ownership of the created object. For example:<br>我可以使用 shared_ptr 或者 unique_ptr 显式的表明已有对象的归属。举例：</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-built_in">unique_ptr</span>&lt;X&gt; <span class="hljs-title">make_X</span><span class="hljs-params">()</span></span>;</code></pre></div><p>But why use a pointer (smart or not) at all? Often, I don’t want a pointer and often a pointer would distract from the conventional use of an object. For example, a Matrix addition function creates a new object (the sum) from two arguments, but returning a pointer would lead to seriously odd code:<br>但是为嘛非要用指针（智能或非智能）呢？通常我也不想用指针，和传统的使用对象比较，返回指针有点多余（看下面好像是这个意思），比如说，Matrix 类型的加法函数，计算2个参数的和，但却返回一个指针，这看起来好奇怪。</p><div class="hljs"><pre><code class="hljs julia">unique_ptr&lt;<span class="hljs-built_in">Matrix</span>&gt; operator+(<span class="hljs-keyword">const</span> <span class="hljs-built_in">Matrix</span>&amp; a, <span class="hljs-keyword">const</span> <span class="hljs-built_in">Matrix</span>&amp; b);<span class="hljs-built_in">Matrix</span> res = *(a+b);</code></pre></div><p>That * is needed to get the sum, rather than a pointer to it. What I really want in many cases is an object, rather than a pointer to an object. Most often, I can easily get that. In particular, small objects are cheap to copy and I wouldn’t dream of using a pointer:<br>那个解引用应该是一个结果，而不是指向结果的指针。多数情况下，我只要一个对象，而不是指针。尤其是那些小的类型，只要简单的copy 就好，根本不用考虑指针。</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">sqrt</span><span class="hljs-params">(<span class="hljs-keyword">double</span>)</span></span>; <span class="hljs-comment">// a square root function</span><span class="hljs-keyword">double</span> s2 = <span class="hljs-built_in">sqrt</span>(<span class="hljs-number">2</span>); <span class="hljs-comment">// get the square root of 2</span></code></pre></div><p>On the other hand, objects holding lots of data are typically handles to most of that data. Consider istream, string, vector, list, and thread. They are all just a few words of data ensuring proper access to potentially large amounts of data. Consider again the Matrix addition. What we want is<br>另一方面，拥有许多数据的类型，一般也会有处理这些数据的操作，像 istream, string, vector, list, thread.它们只用几个简单的数据操作命令就保证了对大量数据的访问，再看回 Matrix 的加法函数，我们想要的是：</p><div class="hljs"><pre><code class="hljs stata"><span class="hljs-keyword">Matrix</span> operator+(<span class="hljs-keyword">const</span> <span class="hljs-keyword">Matrix</span>&amp; a, <span class="hljs-keyword">const</span> <span class="hljs-keyword">Matrix</span>&amp; b); <span class="hljs-comment">// return the sum of a and b</span><span class="hljs-keyword">Matrix</span> r = x+y;</code></pre></div><p>We can easily get that.<br>简单的得到结果</p><div class="hljs"><pre><code class="hljs smali">Matrix operator+(const Matrix&amp; a,<span class="hljs-built_in"> const </span>Matrix&amp; b)&#123;  Matrix res;  // ...<span class="hljs-built_in"> fill </span>res with element sums ... <span class="hljs-built_in"> return </span>res;&#125;</code></pre></div><p>By default, this copies the elements of res into r, but since res is just about to be destroyed and the memory holding its elements is to be freed, there is no need to copy: we can “steal” the elements. Anybody could have done that since the first days of C++, and many did, but it was tricky to implement and the technique was not widely understood. C++11 directly supports “stealing the representation” from a handle in the form of move operations that transfer ownership. Consider a simple 2-D Matrix of doubles:<br>默认情况下，这会拷贝 res 中的成员到 r,但是只要 res 销毁了，其成员占有的内存就会被释放，有一种不需要 copy 的方法,我们可以“偷”。从接触 c++的第一天起，很多人都想过这么干，但这种方法很难实现而且技术不容易被普遍接受。c++11直接支持“窃取信息”，通过move操作形式的句柄移交所有权，看一下二维双重 Matrix 的例子：</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Matrix</span> &#123;</span>  <span class="hljs-keyword">double</span>* elem; <span class="hljs-comment">// pointer to elements</span>  <span class="hljs-keyword">int</span> nrow;     <span class="hljs-comment">// number of rows</span>  <span class="hljs-keyword">int</span> ncol;     <span class="hljs-comment">// number of columns</span><span class="hljs-keyword">public</span>:  Matrix(<span class="hljs-keyword">int</span> nr, <span class="hljs-keyword">int</span> nc)                  <span class="hljs-comment">// constructor: allocate elements</span>    :elem&#123;<span class="hljs-keyword">new</span> <span class="hljs-keyword">double</span>[nr*nc]&#125;, nrow&#123;nr&#125;, ncol&#123;nc&#125;  &#123;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;nr*nc; ++i) elem[i]=<span class="hljs-number">0</span>; <span class="hljs-comment">// initialize elements</span>  &#125;   Matrix(<span class="hljs-keyword">const</span> Matrix&amp;);                  <span class="hljs-comment">// copy constructor</span>  Matrix <span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> Matrix&amp;);        <span class="hljs-comment">// copy assignment</span>   Matrix(Matrix&amp;&amp;);                       <span class="hljs-comment">// move constructor</span>  Matrix <span class="hljs-keyword">operator</span>=(Matrix&amp;&amp;);             <span class="hljs-comment">// move assignment</span>   ~Matrix() &#123; <span class="hljs-keyword">delete</span>[] elem; &#125;            <span class="hljs-comment">// destructor: free the elements</span> <span class="hljs-comment">// …</span>&#125;;</code></pre></div><p>A copy operation is recognized by its reference (&amp;) argument. Similarly, a move operation is recognized by its rvalue reference (&amp;&amp;) argument. A move operation is supposed to “steal” the representation and leave an “empty object” behind. For Matrix, that means something like this:<br>通过判断参数是左值引用或右值引用来区别 copy 和 move 移动。move “窃取信息”后，源对象就成了“空壳”。拿 Matrix 来说，就是这样的：</p><div class="hljs"><pre><code class="hljs delphi">Matrix::Matrix(Matrix&amp;&amp; a)                   <span class="hljs-comment">// move constructor</span>  :nrow<span class="hljs-comment">&#123;a.nrow&#125;</span>, ncol<span class="hljs-comment">&#123;a.ncol&#125;</span>, elem<span class="hljs-comment">&#123;a.elem&#125;</span>  <span class="hljs-comment">// “steal” the representation “窃取资源”</span><span class="hljs-comment">&#123;</span><span class="hljs-comment">  a.elem = nullptr;                          // leave “nothing” behind 置空源对象</span><span class="hljs-comment">&#125;</span></code></pre></div><p>That’s it! When the compiler sees the return res; it realizes that res is soon to be destroyed. That is, res will not be used after the return. Therefore it applies the move constructor, rather than the copy constructor to transfer the return value. In particular, for<br>就这么简单！当编译器执行到 “return res;”,会意识到 res 很快就会被销毁。那样的话，在 return 后，res 就不能使用了。于是，编译器使用 move 构造而不是 copy 构造转移返回值。</p><div class="hljs"><pre><code class="hljs ebnf"><span class="hljs-attribute">Matrix r</span> = a+b;</code></pre></div><p>the res inside operator+() becomes empty – giving the destructor a trivial task – and res’s elements are now owned by r. We have managed to get the elements of the result – potentially megabytes of memory – out of the function (operator+()) and into the caller’s variable. We have done that at a minimal cost (probably four word assignments).<br>特别注意的是，此时 operator+() 中的 res 已经空了，留下一点析构的善后工作，res 所有的元素现在归 r 所有。我们已经将operator+ 中的结果（或许有几兆）转移到调用者的变量中了，我们只用了一点成本，可能只是4行赋值语句。</p><p>Expert C++ users have pointed out that there are cases where a good compiler can eliminate the copy on return completely (in this case saving the four word moves and the destructor call). However, that is implementation dependent, and I don’t like the performance of my basic programming techniques to depend on the degree of cleverness of individual compilers. Furthermore, a compiler that can eliminate the copy, can as easily eliminate the move. What we have here is a simple, reliable, and general way of eliminating complexity and cost of moving a lot of information from one scope to another.<br>已经有专业用户指出，某些情况下，好的编译器可以清除返回的 copy 信息（这中情况下，会保存4行 move 操作和析构调用）。然而这是对现实的依赖，我不喜欢由个别编译器的智能程度来决定我的基础编程能力的性能。而且能清除 copy 的编译器肯定能清除 move. 我们现在有一套简单可行通用的方法去消除域间移动大数据时带来的复杂性和开销。</p><p>Often, we don’t even need to define all those copy and move operations. If a class is composed out of members that behave as desired, we can simply rely on the operations generated by default. Consider:<br>通常，我们不必定义所有的 copy move 操作，如果一个类缺少所需的成员操作，我们可以依赖默认生成的操作。</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Matrix</span> &#123;</span>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">double</span>&gt; elem; <span class="hljs-comment">// elements</span>    <span class="hljs-keyword">int</span> nrow;            <span class="hljs-comment">// number of rows</span>    <span class="hljs-keyword">int</span> ncol;            <span class="hljs-comment">// number of columns</span><span class="hljs-keyword">public</span>:    Matrix(<span class="hljs-keyword">int</span> nr, <span class="hljs-keyword">int</span> nc)    <span class="hljs-comment">// constructor: allocate elements</span>      :elem(nr*nc), nrow&#123;nr&#125;, ncol&#123;nc&#125;    &#123; &#125;     <span class="hljs-comment">// ...</span>&#125;;</code></pre></div><p>This version of Matrix behaves like the version above except that it copes slightly better with errors and has a slightly larger representation (a vector is usually three words).<br>这个版本很像上面的，除了对错误稍微的处理和更多的描述（没看明白这句啥意思）</p><p>What about objects that are not handles? If they are small, like an int or a complex<double>, don’t worry. Otherwise, make them handles or return them using “smart” pointers, such as unique_ptr and shared_ptr. Don’t mess with “naked” new and delete operations.<br>那些不是句柄的对象呢？如果他们像 int 那么小，或者 complex<double>，不要担心。使用智能指针处理或返回他们，不要单纯的使用 new delete.</p><p>Unfortunately, a Matrix like the one I used in the example is not part of the ISO C++ standard library, but several are available (open source and commercial). For example, search the Web for “Origin Matrix Sutton” and see Chapter 29 of my The C++ Programming Language (Fourth Edition) [11] for a discussion of the design of such a matrix.<br>不幸的是，上面使用的 Matrix 并不是标准库里的，但是很多都可用。在网上搜索“Origin Matrix Sutton”，你可以看见在我的书The C++ Programming Language (Fourth Edition)的第29章在讨论如何设计这样的一个矩阵。</p><h4 id="Shared-Ownership-shared-ptr"><a href="#Shared-Ownership-shared-ptr" class="headerlink" title="Shared Ownership: shared_ptr"></a>Shared Ownership: shared_ptr</h4><p>共享所有</p><p>In discussions about garbage collection it is often observed that not every object has a unique owner. That means that we have to be able ensure that an object is destroyed/freed when the last reference to it disappears. In the model here, we have to have a mechanism to ensure that an object is destroyed when its last owner is destroyed. That is, we need a form of shared ownership. Say, we have a synchronized queue, a sync_queue, used to communicate between tasks. A producer and a consumer are each given a pointer to the sync_queue:<br>在讨论垃圾回收机制时，常常观察到不是所有的对象都有唯一的所有者。这就意味着当最后一个引用销毁后，我们必须确保该对象正确销毁释放。在这个例子中，我们必须有一套机制以保证最后一个所有者销毁后，该对象也会被销毁。我们需要一套所有权共享机制。这里，我们有一个用于任务间通讯的同步队列 sync_queue，提供者和使用者同时拥有指向 sync_queue 指针：</p><div class="hljs"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">startup</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;  sync_queue* p  = <span class="hljs-keyword">new</span> sync_queue&#123;<span class="hljs-number">200</span>&#125;;  <span class="hljs-comment">// trouble ahead!</span>  thread t1 &#123;task1,iqueue,p&#125;;  <span class="hljs-comment">// task1 reads from *iqueue and writes to *p</span>  thread t2 &#123;task2,p,oqueue&#125;;  <span class="hljs-comment">// task2 reads from *p and writes to *oqueue</span>  t1.<span class="hljs-built_in">detach</span>();  t2.<span class="hljs-built_in">detach</span>();&#125;</code></pre></div><p>I assume that task1, task2, iqueue, and oqueue have been suitably defined elsewhere and apologize for letting the thread outlive the scope in which they were created (using detatch()). Also, you may imagine pipelines with many more tasks and sync_queues. However, here I am only interested in one question: “Who deletes the sync_queue created in startup()?” As written, there is only one good answer: “Whoever is the last to use the sync_queue.” This is a classic motivating case for garbage collection. The original form of garbage collection was counted pointers: maintain a use count for the object and when the count is about to go to zero delete the object. Many languages today rely on a variant of this idea and C++11 supports it in the form of shared_ptr. The example becomes:<br>我假设 task1 task2 iqueue oqueue 已经在其他地方定义，通过使用 detatch() 使线程的生命周期比它所在的域更长。你可能想到了多任务管道 和 sync_queues。可是在这里，我只对一件事感兴趣：谁删除了 startup() 中创建的sync_queue。只有一个正确的答案，那就是 sync_queue 最后的使用者。这是一个典型的垃圾回收机制的案列。垃圾回收的原型是计数指针：记录被使用的对象数，当计数为 0 时，删除对象。许多语言都是以这个原型演变来的，c++11中使用 shared_ptr 的形式 ，例子变为：</p><div class="hljs"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">startup</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;  <span class="hljs-keyword">auto</span> p = make_shared&lt;sync_queue&gt;(<span class="hljs-number">200</span>);  <span class="hljs-comment">// make a sync_queue and return a stared_ptr to it</span>  thread t1 &#123;task1,iqueue,p&#125;;  <span class="hljs-comment">// task1 reads from *iqueue and writes to *p</span>  thread t2 &#123;task2,p,oqueue&#125;;  <span class="hljs-comment">// task2 reads from *p and writes to *oqueue</span>  t1.<span class="hljs-built_in">detach</span>();  t2.<span class="hljs-built_in">detach</span>();&#125;</code></pre></div><p>Now the destructors for task1 and task2 can destroy their shared_ptrs (and will do so implicitly in most good designs) and the last task to do so will destroy the sync_queue.<br>现在 task1 task2 的析构函数可以销毁他们的 shared_ptr（在多数好的设计中，这会做得很隐蔽），最后一个这个做得会销毁 sync_queue 对象。</p><p>This is simple and reasonably efficient. It does not imply a complicated run-time system with a garbage collector. Importantly, it does not just reclaim the memory associated with the sync_queue. It reclaims the synchronization object (mutex, lock, or whatever) embedded in the sync_queue to mange the synchronization of the two threads running the two tasks. What we have here is again not just memory management, it is general resource management. That “hidden” synchronization object is handled exactly as the file handles and stream buffers were handled in the earlier example.<br>这简单合理高效。这不不是说一个复杂的运行系统一定要一个垃圾回收器。他不仅仅可以回收与 sync_queue 关联的内存，还能回收sync_queue中用于管理不同任务的多线程同步性的同步对象（互斥，锁等），不仅管理内存，还可以管理资源。隐藏的同步对象可以精确处理前面例子中的文件句柄和流句柄。</p><p>We could try to eliminate the use of shared_ptr by introducing a unique owner in some scope that encloses the tasks, but doing so is not always simple, so C++11 provides both unique_ptr (for unique ownership) and shared_ptr (for shared ownership).<br>我们可以尝试通过引入唯一所有者在封装的域中淘汰 shared_ptr 。但这并不简单，所以 c++11 同时提供了 unique_ptr 和 shared_ptr。</p><h4 id="Type-safety"><a href="#Type-safety" class="headerlink" title="Type safety"></a>Type safety</h4><p>类型安全</p><p>Here, I have only addressed garbage collection in connection with resource management. It also has a role to play in type safety. As long as we have an explicit delete operation, it can be misused. For example:</p><p>这里，我只谈到了和资源管理相关的垃圾回收机制，它同样在类型安全中起了重要作用。只要我们显式使用 delete 操作，就可能出现失误。例如：</p><div class="hljs"><pre><code class="hljs reasonml">X* p = <span class="hljs-keyword">new</span> X;X* q = p;delete p;<span class="hljs-comment">// ...</span> <span class="hljs-comment">// the memory that held *p may have been re-used </span> <span class="hljs-comment">// p 指向的内存已经被回收了</span>q-&gt;<span class="hljs-keyword">do</span><span class="hljs-constructor">_something()</span>;</code></pre></div><p>Don’t do that. Naked deletes are dangerous – and unnecessary in general/user code. Leave deletes inside resource management classes, such as string, ostream, thread, unique_ptr, and shared_ptr. There, deletes are carefully matched with news and harmless.<br>千万不要那么做。在一般的用户代码中，delete 的使用的危险多余的。在 string ostream thread unique_ptr shared_ptr 的资源管理类中，不要使用 delete。因此小心配合 new 使用 delete 以确保无害。</p><h4 id="Summary-Resource-Management-Ideals"><a href="#Summary-Resource-Management-Ideals" class="headerlink" title="Summary: Resource Management Ideals"></a>Summary: Resource Management Ideals</h4><p>总结：资源管理理念</p><p>For resource management, I consider garbage collection a last choice, rather than “the solution” or an ideal:<br>对于资源管理，我会把作为最后的选择，而不是解决方案或理念</p><p>Use appropriate abstractions that recursively and implicitly handle their own resources. Prefer such objects to be scoped variables.<br>作用域变量对象优先使用合适的抽象递归地隐式的处理它们的资源。</p><p>When you need pointer/reference semantics, use “smart pointers” such as unique_ptr and shared_ptr to represent ownership.<br>当你需要指针或引用时，使用像 unique_ptr shared_ptr 的智能指针表示其所有关系。</p><p>If everything else fails (e.g., because your code is part of a program using a mess of pointers without a language supported strategy for resource management and error handling), try to handle non-memory resources “by hand” and plug in a conservative garbage collector to handle the almost inevitable memory leaks.<br>如果所有方法都失败了，（比如，你在没有资源管理策略和错误处理支持的语言代码中使用了大量指针），尝试手动处理非内存资源并插入一套垃圾回收机制去处理不可避免的内存溢出。</p><p>Is this strategy perfect? No, but it is general and simple. Traditional garbage-collection based strategies are not perfect either, and they don’t directly address non-memory resources.<br>这种策略完美吗？不，但它简单实用。基于传统垃圾回收的策略并不完美，它并不能直接解决非内存资源的问题。</p><h3 id="Myth-4-“For-efficiency-you-must-write-low-level-code”"><a href="#Myth-4-“For-efficiency-you-must-write-low-level-code”" class="headerlink" title="Myth 4: “For efficiency, you must write low-level code”"></a>Myth 4: “For efficiency, you must write low-level code”</h3><p>为了效率，你必须编写底层代码</p><p>Many people seem to believe that efficient code must be low level. Some even seem to believe that low-level code is inherently efficient (“If it’s that ugly, it must be fast! Someone must have spent a lot of time and ingenuity to write that!”). You can, of course, write efficient code using low-level facilities only, and some code has to be low-level to deal directly with machine resources. However, do measure to see if your efforts were worthwhile; modern C++ compilers are very effective and modern machine architectures are very tricky. If needed, such low-level code is typically best hidden behind an interface designed to allow more convenient use. Often, hiding the low level code behind a higher-level interface also enables better optimizations (e.g., by insulating the low-level code from “insane” uses). Where efficiency matters, first try to achieve it by expressing the desired solution at a high level, don’t dash for bits and pointers.<br>许多人认为底层的代码一定是高效的。甚至有人认为底层代码天生就是高效的（如果它很丑陋，那一定很高效。一定有人花了大量时间和精力去优化它）。当然你可以用底层代码写出高效的代码，有时为了直接处理硬件资源不得不使用底层代码。但是，你要评估下它值不值得：现代的c++ 编译器非常高效，同时现在的硬件架构也非常复杂。如果有需要的话，像这样的底层代码往往为了方便使用被设计成接口。通常，通过高层接口隐藏底层代码会带来更好的优化（比如避免底层代码的滥用）。需要效率的时候，首先尝试在高层接口中去实现，而不要乱用位和指针。</p><h4 id="C’s-qsort"><a href="#C’s-qsort" class="headerlink" title="C’s qsort()"></a>C’s qsort()</h4><p>c语言的 qsort()</p><p>Consider a simple example. If you want to sort a set of floating-point numbers in decreasing order, you could write a piece of code to do so. However, unless you have extreme requirements (e.g., have more numbers than would fit in memory), doing so would be most naïve. For decades, we have had library sort algorithms with acceptable performance characteristics. My least favorite is the ISO standard C library qsort():<br>考虑一个简单的例子。如果你要降序排列一组浮点数，你可以写一段代码实现它，但是除非必须要求那么做（内存受限），否则这么做太天真了。十年间，我们已经有了性能还不错的排序算法库。我最不喜欢 ios 标准库的 qsort 算法。</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">greater</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span>* p, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span>* q)</span>  <span class="hljs-comment">// three-way compare</span></span><span class="hljs-function"></span>&#123;  <span class="hljs-keyword">double</span> x = *(<span class="hljs-keyword">double</span>*)p;  <span class="hljs-comment">// get the double value stored at the address p</span>  <span class="hljs-keyword">double</span> y = *(<span class="hljs-keyword">double</span>*)q;  <span class="hljs-keyword">if</span> (x&gt;y) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;  <span class="hljs-keyword">if</span> (x&lt;y) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">do_my_sort</span><span class="hljs-params">(<span class="hljs-keyword">double</span>* p, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> n)</span></span><span class="hljs-function"></span>&#123;  qsort(p,n,<span class="hljs-keyword">sizeof</span>(*p),greater);&#125; <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;  <span class="hljs-keyword">double</span> a[<span class="hljs-number">500000</span>];  <span class="hljs-comment">// ... fill a ...</span>  do_my_sort(a,<span class="hljs-keyword">sizeof</span>(a)/<span class="hljs-keyword">sizeof</span>(*a));  <span class="hljs-comment">// pass pointer and number of elements</span>  <span class="hljs-comment">// ...</span>&#125;</code></pre></div><p>If you are not a C programmer or if you have not used qsort recently, this may require some explanation; qsort takes four arguments<br>如果你不是c 程序员，或者没用过 qsort 的话，可能需要解释下，qsort 接受 4 个参数：<br>A pointer to a sequence of bytes<br>数据指针<br>The number of elements<br>数据元素个数<br>The size of an element stored in those bytes<br>一个元素的大小<br>A function comparing two elements passed as pointers to their first bytes<br>一个函数，接受 2个参数，分别指向2个元素的首地址</p><p>Note that this interface throws away information. We are not really sorting bytes. We are sorting doubles, but qsort doesn’t know that so that we have to supply information about how to compare doubles and the number of bytes used to hold a double. Of course, the compiler already knows such information perfectly well. However, qsort’s low-level interface prevents the compiler from taking advantage of type information. Having to state simple information explicitly is also an opportunity for errors. Did I swap qsort()’s two integer arguments? If I did, the compiler wouldn’t notice. Did my compare() follow the conventions for a C three-way compare?<br>注意，这个接口漏掉了什么。我们并不是真的要对字节排序。我们想对浮点数排序，但 qsort 不知道，所以我们不得不提供一些信息，包括怎么比较浮点数和保存浮点数需要的字节数。当然，编译器已经知道这些信息就再好不过了，但 qsort 的底层接口阻止编译器使用类型信息。不得不显式的表示信息也增加了出错的几率。我是不是写错了 qsort 中的2个参数，即使我错了，编译器也不会发现。我的比较函数有没有遵循 c 语言的 three-way 比较规则（什么时候返回1，-1，0）</p><p>If you look at an industrial strength implementation of qsort (please do), you will notice that it works hard to compensate for the lack of information. For example, swapping elements expressed as a number of bytes takes work to do as efficiently as a swap of a pair of doubles. The expensive indirect calls to the comparison function can only be eliminated if the compiler does constant propagation for pointers to functions.<br>如果你看过一个 qsort 的实现，你会发现它会努力去弥补信息缺少带来的问题。比如，交换用字节数表示的元素时尽量做到和交换浮点数一样高效。如果编译器用常量指针做参数传递给函数会降低间接调用比较函数时的开销。</p><h4 id="C-’s-sort"><a href="#C-’s-sort" class="headerlink" title="C++’s sort()"></a>C++’s sort()</h4><p>c++ 的 sort()</p><p>Compare qsort() to its C++ equivalent, sort():<br>比较2个等价版本</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">do_my_sort</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">double</span>&gt;&amp; v)</span></span><span class="hljs-function"></span>&#123;  sort(v,[](<span class="hljs-keyword">double</span> x, <span class="hljs-keyword">double</span> y) &#123; <span class="hljs-keyword">return</span> x&gt;y; &#125;);  <span class="hljs-comment">// sort v in decreasing order</span>&#125; <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;  <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">double</span>&gt; vd;  <span class="hljs-comment">// ... fill vd ...</span>  do_my_sort(v);  <span class="hljs-comment">// ...</span>&#125;</code></pre></div><p>Less explanation is needed here. A vector knows its size, so we don’t have to explicitly pass the number of elements. We never “lose” the type of elements, so we don’t have to deal with element sizes. By default, sort() sorts in increasing order, so I have to specify the comparison criteria, just as I did for qsort(). Here, I passed it as a lambda expression comparing two doubles using &gt;. As it happens, that lambda is trivially inlined by all C++ compilers I know of, so the comparison really becomes just a greater-than machine operation; there is no (inefficient) indirect function call.<br>这里不用太多解释。vector 知道自己的大小，我们不再需要显式传递元素的数量。我们不会漏掉元素的类型，所以也不用处理元素占用字节。默认情况下，sort 执行升序排列，所以必须指定比较规则像 qsort 那样。在这里，我传递一个 lambda 表达式，使用 &gt; 比较2个浮点数。据我所知所有的编译器执行 lambda 表达式时都是简单的内联，这样，比较变成了大于号的机器操作，没有低效的间接函数调用。</p><p>I used a container version of sort() to avoid being explicit about the iterators. That is, to avoid having to write:<br>我使用了容器版本的 sort ，为了避免显式使用迭代器。避免像下面这样写：</p><div class="hljs"><pre><code class="hljs arduino"><span class="hljs-built_in">std</span>::sort(v.<span class="hljs-built_in">begin</span>(),v.<span class="hljs-built_in">end</span>(),[](<span class="hljs-keyword">double</span> x, <span class="hljs-keyword">double</span> y) &#123; <span class="hljs-keyword">return</span> x&gt;y; &#125;);</code></pre></div><p>I could go further and use a C++14 comparison object:<br>我可以更进一步，使用 c++14版本的对象：</p><div class="hljs"><pre><code class="hljs lisp">sort(<span class="hljs-name">v</span>,greater&lt;&gt;())<span class="hljs-comment">; // sort v in decreasing order</span></code></pre></div><p>Which version is faster? You can compile the qsort version as C or C++ without any performance difference, so this is really a comparison of programming styles, rather than of languages. The library implementations seem always to use the same algorithm for sort and qsort, so it is a comparison of programming styles, rather than of different algorithms. Different compilers and library implementations give different results, of course, but for each implementation we have a reasonable reflection of the effects of different levels of abstraction.<br>哪个版本更快？你可以用 c 或 c++ 编译 qsort,它们没有效率的差别，所以这只是编程风格的比较，而不是语言的比较。对于 sort 和 qsort 的库实现一直使用相同的算法，所以这也只是编程风格的比较，而不是算法。不同的编译器和库实现有不同的结果，当然，对于每一个实现，我们会理性的思考不同层次抽象的效果。</p><p>I recently ran the examples and found the sort() version 2.5 times  faster than the qsort() version. Your mileage will vary from compiler to compiler and from machine to machine, but I have never seen qsort beat sort. I have seen sort run 10 times faster than qsort. How come? The C++ standard-library sort is clearly at a higher level than qsort as well as more general and flexible. It is type safe and parameterized over the storage type, element type, and sorting criteria. There isn’t a pointer, cast, size, or a byte in sight. The C++ standard library STL, of which sort is a part, tries very hard not to throw away information. This makes for excellent inlining and good optimizations.<br>我最近运行实例，发现 sort 比 qsort 快 2.5倍。由于编译器机器环境的不同，结果不同，但我从见过 qsort 比 sort 快。我见过 sort 比 qsort 快 10倍，怎么来的？c++标准库 sort 和 qsort 相比，明显是更高层次的抽象，同时也更通用更灵活。它类型安全，使存储类型，元素类型，排序规则参数化，看不到指针， 类型转换，长度，字节等等。c++ 标准库 STL,包括 sort, 努力做到不丢失信息，这有利于更好的内联和优化。</p><p>Generality and high-level code can beat low-level code. It doesn’t always, of course, but the sort/qsort comparison is not an isolated example. Always start out with a higher-level, precise, and type safe version of the solution. Optimize (only) if needed.<br>通用性和高层次的代码比底层代码更优。当然，也不是总是，但 sort 和 qsort 并不是个例。总是从一个高层，精确，类型安全的版本着手解决，如果需要再优化。</p><h3 id="Myth-5-“C-is-for-large-complicated-programs-only”"><a href="#Myth-5-“C-is-for-large-complicated-programs-only”" class="headerlink" title="Myth 5: “C++ is for large, complicated, programs only”"></a>Myth 5: “C++ is for large, complicated, programs only”</h3><p>c++ 只是用于大型复杂的程序</p><p>C++ is a big language. The size of its definition is very similar to those of C# and Java. But that does not imply that you have to know every detail to use it or use every feature directly in every program. Consider an example using only foundational components from the standard library:<br>c++ 是一门大语言。它的定义大小和java c# 差不多。但那并不意味着你必须知道每一个使用细节或是在每一个程序中直接使用每一个特征。思考一个仅使用标准库基础组件的例子：</p><div class="hljs"><pre><code class="hljs reasonml">set&lt;<span class="hljs-built_in">string</span>&gt; get<span class="hljs-constructor">_addresses(<span class="hljs-params">istream</span>&amp; <span class="hljs-params">is</span>)</span>&#123;  set&lt;<span class="hljs-built_in">string</span>&gt; addr;  regex pat &#123; R<span class="hljs-string">"((\w+([.-]\w+)*)@(\w+([.-]\w+)*))"</span>&#125;; <span class="hljs-comment">// email address pattern</span>  smatch m;  for (<span class="hljs-built_in">string</span> s; getline(is,s); )                    <span class="hljs-comment">// read a line</span>    <span class="hljs-keyword">if</span> (regex<span class="hljs-constructor">_search(<span class="hljs-params">s</span>, <span class="hljs-params">m</span>, <span class="hljs-params">pat</span>)</span>)                     <span class="hljs-comment">// look for the pattern</span>      addr.insert(m<span class="hljs-literal">[<span class="hljs-number">0</span>]</span>);                             <span class="hljs-comment">// save address in set</span>  return addr;&#125;</code></pre></div><p>I assume you know regular expressions. If not, now may be a good time to read up on them. Note that I rely on move semantics to simply and efficiently return a potentially large set of strings. All standard-library containers provide move constructors, so there is no need to mess around with new.<br>假设你了解正则表达式。如果不会，现在或许是时候读一下了。注意，我依靠 move 语法对可能返回的大串字符进行简化优化。所有标准库容器都提供了移动构造函数，所以没必要用 new.</p><p>For this to work, I need to include the appropriate standard library components:<br>为了正常运行，我需要包含适当的标准库组件:</p><div class="hljs"><pre><code class="hljs autoit"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;string&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;set&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;sstream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;regex&gt;</span></span>using namespace std<span class="hljs-comment">;</span></code></pre></div><p>Let’s test it:<br>测试下：</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-built_in">istringstream</span> test &#123;  <span class="hljs-comment">// a stream initialized to a sting containing some addresses</span>  <span class="hljs-string">"asasasa\n"</span>  <span class="hljs-string">"bs@foo.com\n"</span>  <span class="hljs-string">"ms@foo.bar.com$aaa\n"</span>  <span class="hljs-string">"ms@foo.bar.com aaa\n"</span>  <span class="hljs-string">"asdf bs.ms@x\n"</span>  <span class="hljs-string">"$$bs.ms@x$$goo\n"</span>  <span class="hljs-string">"cft foo-bar.ff@ss-tt.vv@yy asas"</span>  <span class="hljs-string">"qwert\n"</span>&#125;; <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;  <span class="hljs-keyword">auto</span> addr = get_addresses(test);  <span class="hljs-comment">// get the email addresses</span>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; s : addr)              <span class="hljs-comment">// write out the addresses</span>    <span class="hljs-built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="hljs-string">'\n'</span>;&#125;</code></pre></div><p>This is just an example. It is easy to modify get_addresses() to take the regex pattern as an argument, so that it could find URLs or whatever. It is easy to modify get_addresses() to recognize more than one occurrence of a pattern in a line. After all, C++ is designed for flexibility and generality, but not every program has to be a complete library or application framework. However, the point here is that the task of extracting email addresses from a stream is simply expressed and easily tested.<br>这只是一个例子。只要简单的修改下 get_addresses， 将正则表达式作为参数，就可以查找 URLs 或其他，简单修改下就可以识别一行里更多的匹配。毕竟 c++ 是为便捷和通用而生，但并不是每一个程序都可以成为一个完整的库或应用框架。重点是对于从流中提取 email 地址这个任务可以简单实现和测试。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><blockquote><p> <a href="https://www.zhihu.com/question/38828701" target="_blank" rel="noopener">https://www.zhihu.com/question/38828701</a><br> <a href="https://blog.csdn.net/u013691335/article/details/43154875" target="_blank" rel="noopener">https://blog.csdn.net/u013691335/article/details/43154875</a></p></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>WDYDT-5-最近挺忙-Widget开发</title>
    <link href="/2018/07/09/WDYDT-5-%E6%9C%80%E8%BF%91%E6%8C%BA%E5%BF%99-Widget%E5%BC%80%E5%8F%91/"/>
    <url>/2018/07/09/WDYDT-5-%E6%9C%80%E8%BF%91%E6%8C%BA%E5%BF%99-Widget%E5%BC%80%E5%8F%91/</url>
    
    <content type="html"><![CDATA[<!-- abstract area --><p>最近挺忙，导致wdydt博客计划暂停，最近今天不是太忙了，喘口气。</p><a id="more"></a><p>其实加入我司以来，一直都不是特别忙。主要是“专业不对口”，最近有个APP widget开发的活，而且我们团队只剩我一个Android程序员了。</p><p>今天喜迎公司上市，穿上了“厚道”T恤。</p><p>最近的表现，老大也是满认可的，但是老大估计权利也不大，对我加薪帮助有限。但是我很穷，需要钱。</p><p>前天和女朋友去看了“药神”，很好，很感动。里边说的很对，有一种治不好的病，叫“穷病”。生活很残酷，有太多的无奈。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>WDYDT-4-别人疯狂时我恐惧，别人恐惧时我贪婪</title>
    <link href="/2018/06/21/WDYDT-4-%E5%88%AB%E4%BA%BA%E7%96%AF%E7%8B%82%E6%97%B6%E6%88%91%E6%81%90%E6%83%A7%EF%BC%8C%E5%88%AB%E4%BA%BA%E6%81%90%E6%83%A7%E6%97%B6%E6%88%91%E8%B4%AA%E5%A9%AA/"/>
    <url>/2018/06/21/WDYDT-4-%E5%88%AB%E4%BA%BA%E7%96%AF%E7%8B%82%E6%97%B6%E6%88%91%E6%81%90%E6%83%A7%EF%BC%8C%E5%88%AB%E4%BA%BA%E6%81%90%E6%83%A7%E6%97%B6%E6%88%91%E8%B4%AA%E5%A9%AA/</url>
    
    <content type="html"><![CDATA[<!-- abstract area --><blockquote><p>别人疯狂时我恐惧，别人恐惧时我贪婪。  – 巴菲特</p></blockquote><a id="more"></a><p>这几天看了看房价，感觉每个地方都不一样。</p><p>但是有几点我是相信的。</p><p>房地产税一定会出，应该是按人均面积计算，每人都有免征面积。<br>空置的房屋会被处理<br>房价应该会下跌，但是下跌的程度不大，或者横屏，长期还是看好的。<br>特朗普在搞事情，他想搞垮中国经济。宁愿自己受伤也要搞垮中国。</p><p>这几天的基金也赔了不少，长期斗争吧，适当减仓。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>WDYDT-3-AS搭建源码阅读环境改进</title>
    <link href="/2018/06/19/WDYDT-3-AS%E6%90%AD%E5%BB%BA%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%8E%AF%E5%A2%83%E6%94%B9%E8%BF%9B/"/>
    <url>/2018/06/19/WDYDT-3-AS%E6%90%AD%E5%BB%BA%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%8E%AF%E5%A2%83%E6%94%B9%E8%BF%9B/</url>
    
    <content type="html"><![CDATA[<!-- abstract area --><a id="more"></a><blockquote><p><a href="http://www.cnblogs.com/Lefter/p/4176991.html" target="_blank" rel="noopener">http://www.cnblogs.com/Lefter/p/4176991.html</a></p></blockquote><p>这个博客写的很明白了。</p><p>现在就是不能完成C++的代码跳转，我还没学完C++，继续学习C++吧</p><p>看了一下这个视频，感觉讲的还行，就是老师的风格有点无聊，（老师自己也这么说）。</p><blockquote><p>C++ 基础视频：<a href="http://edu.51cto.com//center/course/lesson/index?id=110557" target="_blank" rel="noopener">http://edu.51cto.com//center/course/lesson/index?id=110557</a></p></blockquote><p>今天学了C++的基本历史，编译器啥的，还有Qt的使用，应该以后都是在这个Qt上进行开发吧</p><p>有段指针的代码：</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> a = <span class="hljs-number">100</span>;   <span class="hljs-keyword">int</span> &amp;b = a; <span class="hljs-comment">// 引用</span>   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"a : "</span> &lt;&lt; a &lt;&lt; <span class="hljs-string">" &amp;a ： "</span> &lt;&lt; &amp;a &lt;&lt; <span class="hljs-built_in">endl</span>;   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"b : "</span> &lt;&lt; b &lt;&lt; <span class="hljs-string">" &amp;b ： "</span> &lt;&lt; &amp;b &lt;&lt; <span class="hljs-built_in">endl</span>;   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;   b = <span class="hljs-number">200</span>;  <span class="hljs-comment">// 修改引用的值</span>   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"a : "</span> &lt;&lt; a &lt;&lt; <span class="hljs-string">" &amp;a ： "</span> &lt;&lt; &amp;a &lt;&lt; <span class="hljs-built_in">endl</span>;   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"b : "</span> &lt;&lt; b &lt;&lt; <span class="hljs-string">" &amp;b ： "</span> &lt;&lt; &amp;b &lt;&lt; <span class="hljs-built_in">endl</span>;   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;   <span class="hljs-keyword">int</span> *c = &amp;a;   <span class="hljs-keyword">int</span> *&amp;d = c;  <span class="hljs-comment">// 指针的引用</span>   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"a : "</span> &lt;&lt; a &lt;&lt; <span class="hljs-string">" &amp;a ： "</span> &lt;&lt; &amp;a &lt;&lt; <span class="hljs-built_in">endl</span>;   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"b : "</span> &lt;&lt; b &lt;&lt; <span class="hljs-string">" &amp;b ： "</span> &lt;&lt; &amp;b &lt;&lt; <span class="hljs-built_in">endl</span>;   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"c : "</span> &lt;&lt; c &lt;&lt; <span class="hljs-string">" &amp;c ： "</span> &lt;&lt; &amp;c &lt;&lt; <span class="hljs-built_in">endl</span>;   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"d : "</span> &lt;&lt; d &lt;&lt; <span class="hljs-string">" &amp;d ： "</span> &lt;&lt; &amp;d &lt;&lt; <span class="hljs-built_in">endl</span>;   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;   *c = <span class="hljs-number">300</span>;  <span class="hljs-comment">// 通过指针修改变量的值</span>   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"a : "</span> &lt;&lt; a &lt;&lt; <span class="hljs-string">" &amp;a ： "</span> &lt;&lt; &amp;a &lt;&lt; <span class="hljs-built_in">endl</span>;   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"b : "</span> &lt;&lt; b &lt;&lt; <span class="hljs-string">" &amp;b ： "</span> &lt;&lt; &amp;b &lt;&lt; <span class="hljs-built_in">endl</span>;   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"c : "</span> &lt;&lt; c &lt;&lt; <span class="hljs-string">" &amp;c ： "</span> &lt;&lt; &amp;c &lt;&lt; <span class="hljs-built_in">endl</span>;   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"d : "</span> &lt;&lt; d &lt;&lt; <span class="hljs-string">" &amp;d ： "</span> &lt;&lt; &amp;d &lt;&lt; <span class="hljs-built_in">endl</span>;   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;   *d = <span class="hljs-number">400</span>;  <span class="hljs-comment">// 通过指针的引用修改变量的值</span>   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"a : "</span> &lt;&lt; a &lt;&lt; <span class="hljs-string">" &amp;a ： "</span> &lt;&lt; &amp;a &lt;&lt; <span class="hljs-built_in">endl</span>;   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"b : "</span> &lt;&lt; b &lt;&lt; <span class="hljs-string">" &amp;b ： "</span> &lt;&lt; &amp;b &lt;&lt; <span class="hljs-built_in">endl</span>;   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"c : "</span> &lt;&lt; c &lt;&lt; <span class="hljs-string">" &amp;c ： "</span> &lt;&lt; &amp;c &lt;&lt; <span class="hljs-built_in">endl</span>;   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"d : "</span> &lt;&lt; d &lt;&lt; <span class="hljs-string">" &amp;d ： "</span> &lt;&lt; &amp;d &lt;&lt; <span class="hljs-built_in">endl</span>;   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</code></pre></div><p>输出：</p><div class="hljs"><pre><code class="hljs yaml"><span class="hljs-attr">a :</span> <span class="hljs-number">100</span> <span class="hljs-string">&amp;a</span> <span class="hljs-string">：</span> <span class="hljs-number">0x7ffeee6709a8</span><span class="hljs-attr">b :</span> <span class="hljs-number">100</span> <span class="hljs-string">&amp;b</span> <span class="hljs-string">：</span> <span class="hljs-number">0x7ffeee6709a8</span><span class="hljs-attr">a :</span> <span class="hljs-number">200</span> <span class="hljs-string">&amp;a</span> <span class="hljs-string">：</span> <span class="hljs-number">0x7ffeee6709a8</span><span class="hljs-attr">b :</span> <span class="hljs-number">200</span> <span class="hljs-string">&amp;b</span> <span class="hljs-string">：</span> <span class="hljs-number">0x7ffeee6709a8</span><span class="hljs-attr">a :</span> <span class="hljs-number">200</span> <span class="hljs-string">&amp;a</span> <span class="hljs-string">：</span> <span class="hljs-number">0x7ffeee6709a8</span><span class="hljs-attr">b :</span> <span class="hljs-number">200</span> <span class="hljs-string">&amp;b</span> <span class="hljs-string">：</span> <span class="hljs-number">0x7ffeee6709a8</span><span class="hljs-attr">c :</span> <span class="hljs-number">0x7ffeee6709a8</span> <span class="hljs-string">&amp;c</span> <span class="hljs-string">：</span> <span class="hljs-number">0x7ffeee670998</span><span class="hljs-attr">d :</span> <span class="hljs-number">0x7ffeee6709a8</span> <span class="hljs-string">&amp;d</span> <span class="hljs-string">：</span> <span class="hljs-number">0x7ffeee670998</span><span class="hljs-attr">a :</span> <span class="hljs-number">300</span> <span class="hljs-string">&amp;a</span> <span class="hljs-string">：</span> <span class="hljs-number">0x7ffeee6709a8</span><span class="hljs-attr">b :</span> <span class="hljs-number">300</span> <span class="hljs-string">&amp;b</span> <span class="hljs-string">：</span> <span class="hljs-number">0x7ffeee6709a8</span><span class="hljs-attr">c :</span> <span class="hljs-number">0x7ffeee6709a8</span> <span class="hljs-string">&amp;c</span> <span class="hljs-string">：</span> <span class="hljs-number">0x7ffeee670998</span><span class="hljs-attr">d :</span> <span class="hljs-number">0x7ffeee6709a8</span> <span class="hljs-string">&amp;d</span> <span class="hljs-string">：</span> <span class="hljs-number">0x7ffeee670998</span><span class="hljs-attr">a :</span> <span class="hljs-number">400</span> <span class="hljs-string">&amp;a</span> <span class="hljs-string">：</span> <span class="hljs-number">0x7ffeee6709a8</span><span class="hljs-attr">b :</span> <span class="hljs-number">400</span> <span class="hljs-string">&amp;b</span> <span class="hljs-string">：</span> <span class="hljs-number">0x7ffeee6709a8</span><span class="hljs-attr">c :</span> <span class="hljs-number">0x7ffeee6709a8</span> <span class="hljs-string">&amp;c</span> <span class="hljs-string">：</span> <span class="hljs-number">0x7ffeee670998</span><span class="hljs-attr">d :</span> <span class="hljs-number">0x7ffeee6709a8</span> <span class="hljs-string">&amp;d</span> <span class="hljs-string">：</span> <span class="hljs-number">0x7ffeee670998</span></code></pre></div>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>WDYDT-2-编译ROM导入AS</title>
    <link href="/2018/06/15/WDYDT-2-%E7%BC%96%E8%AF%91ROM%E5%AF%BC%E5%85%A5AS/"/>
    <url>/2018/06/15/WDYDT-2-%E7%BC%96%E8%AF%91ROM%E5%AF%BC%E5%85%A5AS/</url>
    
    <content type="html"><![CDATA[<!-- abstract area --><p>昨天编了个ROM，今天又失败了，结果是让执行make update-api, 然后就好了。<br>今天还搞了个android.ipr,可以把Android的源代码导入到Android studio进行查看。</p><a id="more"></a><p>ROM的编译还是挺有意思的，搞了两天重要搞好了。</p><p>然后这几天都是在找看代码的方法，都是一些vim+ctags什么的，感觉有点难度，<br>然后看到一个用Android Studio搞得，果断搞了一下</p><blockquote><p>查考： <a href="https://www.jianshu.com/p/fb16fa459acf" target="_blank" rel="noopener">Android Studio导入android源码技巧</a></p></blockquote><p>然后就是Android studio打开巨慢，然后看了idegen下边的README，上边说要改heap size，然后改了一下</p><blockquote><p>heap size 修改： <a href="https://blog.csdn.net/QQxiaoqiang1573/article/details/72903237" target="_blank" rel="noopener">https://blog.csdn.net/QQxiaoqiang1573/article/details/72903237</a></p></blockquote><p>然后还可以改android.iml 里边的excludeFolder，只把自己关心的目录放进去，其他的都是用<excludeFolder url="file://$MODULE_DIR$/.repo" /><br>这种方式给exclude掉。</p><p>具体的效果我还没有试，节后吧，我是在公司的电脑上搞得，这几天要过节，希望我还能每天更新我的博客。</p><p>节日快乐！！</p><p>对了，今天还写了个脚本，用于生成WDYDT，代码如下：</p><div class="hljs"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span>number_path=<span class="hljs-string">"./number_wdydt"</span><span class="hljs-keyword">if</span> [ ! -f <span class="hljs-string">"<span class="hljs-variable">$number_path</span>"</span> ]; <span class="hljs-keyword">then</span>touch <span class="hljs-variable">$number_path</span><span class="hljs-built_in">echo</span> 1 &gt; <span class="hljs-variable">$number_path</span><span class="hljs-keyword">fi</span>number_wdydt=`cat <span class="hljs-variable">$number_path</span>`<span class="hljs-comment">#echo $number_wdydt</span><span class="hljs-built_in">let</span> number_wdydt+=1<span class="hljs-comment">#echo $number_wdydt</span><span class="hljs-comment">#echo $number_wdydt &gt; $number_path</span><span class="hljs-built_in">echo</span> <span class="hljs-string">"Gen this page:"</span><span class="hljs-built_in">echo</span> <span class="hljs-string">"WDYDT-<span class="hljs-variable">$number_wdydt</span>-$*"</span>hexo new <span class="hljs-string">"WDYDT-<span class="hljs-variable">$number_wdydt</span>-$*"</span></code></pre></div><p>本篇文章写了14分钟。</p>]]></content>
    
    
    
    <tags>
      
      <tag>WDYDT</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>WDYDT-1-第一篇</title>
    <link href="/2018/06/14/WDYDT-1-%E7%AC%AC%E4%B8%80%E7%AF%87/"/>
    <url>/2018/06/14/WDYDT-1-%E7%AC%AC%E4%B8%80%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<h1 id="WDYDT"><a href="#WDYDT" class="headerlink" title="WDYDT"></a>WDYDT</h1><p>WDYDT 就是 What did you do today? 今天你做了什么？</p><a id="more"></a><p>对于一个拖延症和自制力很差的人，我只能以这种方式来激励和监督自己完成自己定制的计划。</p><p>我的计划就是看Android源代码</p><p>Android源代码是一个很深的东西，覆盖面很广。</p><p>我打算先看C++的知识，以为我没有学过C++。</p><p>然后再看Linux内核的相关知识。</p><p>再看Linux在嵌入式设备上的应用。</p><p>然后开始读Android的源码，结合老罗的书、博客，和GitYuan的博客去读代码。</p><p>希望我能成功。</p><p>期限大约是7个月，大约是210天。</p><p>以后的每天都会有一些碎碎记。</p><p>今天我是学了C++的一些基本知识，发现有些修饰符和java还是有区别的，比如那个static，重新在函数里赋值竟然不会起作用，还是会记住以前的值。<br>还有一个thread_local，这个和Android的挺像，但是我还没用。还有一些运算符优先级的问题。</p><p>还学习了一些刷机的原理知识，有BootLoader和recovery，BootLoader就是fastboot，这个是在主板上的一段程序，类似于BIOS。</p><p>还看了一些repo的原理，还没看完，明天继续看。还要看Android编译的一些原理。</p><p>这些文字用了14分钟写完。</p>]]></content>
    
    
    
    <tags>
      
      <tag>WDYDT</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>工作两年半——你变了吗?</title>
    <link href="/2018/04/12/%E5%B7%A5%E4%BD%9C%E4%B8%A4%E5%B9%B4%E5%8D%8A%E2%80%94%E2%80%94%E4%BD%A0%E5%8F%98%E4%BA%86%E5%90%97/"/>
    <url>/2018/04/12/%E5%B7%A5%E4%BD%9C%E4%B8%A4%E5%B9%B4%E5%8D%8A%E2%80%94%E2%80%94%E4%BD%A0%E5%8F%98%E4%BA%86%E5%90%97/</url>
    
    <content type="html"><![CDATA[<p>2015年光棍节的时候，我来北京实习，到现在已经两年半了。时间过得好快，你还是当初的那个你吗。</p><a id="more"></a><h2 id="沉迷于手机"><a href="#沉迷于手机" class="headerlink" title="沉迷于手机"></a>沉迷于手机</h2><p>这是我的真实写照了，每天不管是上班时间，还是下班时间，我都离不开手机。说离不开并不是有多少事情需要通过手机进行处理，而是想玩手机，想看看脉脉、知乎、头条等等App，回到家一般打打王者，刷抖音，段子。但是大部分的时候，看这些东西并不会对我们有什么帮助，而我大部分时间看的也是一些搞笑的视频，这些肥皂剧版的信息对我来说很鸡肋，只能起到放松的作用，而我感觉我需要的不是放松，我需要的是斗志。</p><h2 id="一而再，再而三"><a href="#一而再，再而三" class="headerlink" title="一而再，再而三"></a>一而再，再而三</h2><p>说起沉迷手机的坏处，我也是早就知道了，自己狠狠心也会卸载这些软件，但是过不了多少时间，自己又会重新把这些软件装回来，还是管不住自己，还是战胜不了自己的心魔。</p><h2 id="爱好是什么东西，我有过吗"><a href="#爱好是什么东西，我有过吗" class="headerlink" title="爱好是什么东西，我有过吗"></a>爱好是什么东西，我有过吗</h2><p>我自己认为我这种情况就是自己寂寞导致的，说白了就是吃饱了没事干，然后无聊啊，但是精力过剩啊，睡不着，然后只能玩手机了，典型的宅男啊。想要摆脱这个，还是要培养自己的爱好，培养一个不用碰电脑和手机的爱好。或许自己有事干了，就不会这么无聊了。健身和看书吧，一个增强体格，一个丰富大脑。</p><h2 id="间歇性踌躇满志，持续性混吃等死"><a href="#间歇性踌躇满志，持续性混吃等死" class="headerlink" title="间歇性踌躇满志，持续性混吃等死"></a>间歇性踌躇满志，持续性混吃等死</h2><p>生活就是这样，三分钟热度，我一直都是这样，都说“贵在坚持”，坚持真的很难，当你想说坚持两个字的时候，可能你自己就想要放弃了，真正的努力可能不会想到坚持的概念，因为你一直想着你要做的事，坚持什么的想法，只能让自己产生一种厌倦的消极情绪。</p><h2 id="道理我都懂"><a href="#道理我都懂" class="headerlink" title="道理我都懂"></a>道理我都懂</h2><p>这个问题也是老生常谈了，“道理我都懂”，可能我只是懂表面意思。好多道理都是道听途说，虽然是别人总结的道理，但是肯定是积极的、有帮助的。我知道好多道理，但是好多道理都不是自己悟出来的，不深刻，自己也不会太执着。</p><h2 id="拖延症晚期"><a href="#拖延症晚期" class="headerlink" title="拖延症晚期"></a>拖延症晚期</h2><p>写这篇博客的时候，我差点都没写完，真是是拖延症晚期了。我感觉我这个人的效率还是蛮高的，但是效率高的时间大部分在任务deadline的前一天。以前在我上学的时候也是如此，作业一定是开学前的最后一天才写，而且很可能是晚上才写，‘晚上加班’的习惯可能从上小学就养成了。</p><h2 id="叹一下气，感觉很舒服"><a href="#叹一下气，感觉很舒服" class="headerlink" title="叹一下气，感觉很舒服"></a>叹一下气，感觉很舒服</h2><p>我最近发现，“唉~”一下，很舒服，我的同事也有这种感觉，这种感觉好像如释重负，又好像放弃了自己。负能量满满。<br>生活不应该这样，我应该变回那个充满朝气的自己，不服输，不放弃，执着的自己。</p>]]></content>
    
    
    
    <tags>
      
      <tag>计划</tag>
      
      <tag>生活</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>知乎的世说新语</title>
    <link href="/2018/03/19/%E7%9F%A5%E4%B9%8E%E7%9A%84%E4%B8%96%E8%AF%B4%E6%96%B0%E8%AF%AD/"/>
    <url>/2018/03/19/%E7%9F%A5%E4%B9%8E%E7%9A%84%E4%B8%96%E8%AF%B4%E6%96%B0%E8%AF%AD/</url>
    
    <content type="html"><![CDATA[<p>来自知乎大神的回复，抖机灵但是很有道理。</p><blockquote><p>PS： 一共是100条，但是第61条好像不见了。</p></blockquote><a id="more"></a><p>1、和女友分手后一直很不安，害怕她会变坏，胡乱约炮，各种放纵，怎么办？</p><blockquote><p>芝士就是力量：其他人的恶劣行径顶多是占着茅坑不拉屎，你这是出了厕所还想锁门。</p></blockquote><p>2、「滚床单」有哪些优雅的叫法？</p><blockquote><p>匿名用户：管鲍之交。</p></blockquote><p>3、你收到的最雷的表白语是什么？</p><blockquote><p>程冬冬：做我女朋友行不行，行就行，不行我再想想办法。</p></blockquote><p>4、暧昧是什么？</p><blockquote><p>苑小帅：暧昧=爱日未日</p></blockquote><p>5、如果给客户放 PPT 的时候突然蹦出来不雅图片，怎么办？</p><blockquote><p>刘熹坤：沉默半响，然后问：“大伙儿还困吗？——不困咱继续。。。”</p></blockquote><p>6、分手100天了，还没有走出来怎么办？</p><blockquote><p>韩重赞：替换文件永远比删除文件更彻底。</p></blockquote><p>7、为什么女生有「体香」，而男人没有？</p><blockquote><p>green grass：化妆品腌入味了→_→</p></blockquote><p>8、同龄人中不少人结婚生子了，对你有什么影响吗？</p><blockquote><p>匿名用户：对我没啥影响，对我妈影响比较大。</p></blockquote><p>9、男性更看重女人的身材、脸蛋还是思想？</p><blockquote><p>匿名用户：脸蛋和身材决定了我是否想去了解她的思想。思想决定了我是否会一票否决掉她的脸蛋和身材。</p></blockquote><p>10、初恋是不是用来练手的？</p><blockquote><p>wsivoky：放屁。单身才是用来练手的。</p></blockquote><p>11、健身会导致停经吗？</p><blockquote><p>yong cao：要看你和教练的关系…</p></blockquote><p>12、女孩子的胸到底有多软？摸着什么感觉？</p><blockquote><p>王丹：</p><p>本来以为题主是男的，心想卧槽，这可能是2015年最悲伤的问题了；</p><p>仔细一看题主是女的，卧槽，这真的是2015年最悲伤的问题了…</p></blockquote><p>13、女朋友和女性朋友有什么区别？</p><blockquote><p>James Swineson：中国人取名字有一个习惯：实际上缺什么，一定要在名字里补上，五行圆满才行。</p></blockquote><p>14、相爱三年的初恋女友，异地恋后初夜给了别人，如何调节？</p><blockquote><p>蒋大明：爱上一匹野马，头上都是草原。</p></blockquote><p>15、如何回答女生“你喜欢我什么”？</p><blockquote><p>匿名用户：</p></blockquote><blockquote><p>这不是有公式吗？<br>一个时间点+一件小事+形容润色+海誓山盟</p></blockquote><blockquote><p>如：四年前的一个早上，你忙碌着为我准备早餐，看着你的身影，我恍惚看到了天使，美极了，那时我便默默对自己说，这就是我要用一辈子去爱去疼的女人。<br>最后紧紧抱住她，不用多解释。</p></blockquote><p>16、没有女朋友是什么感受？</p><blockquote><p>Alvin：有一种怀才不遇的感觉。</p></blockquote><p>17、从小到大被十个人以上表白过是怎么样的体验？</p><blockquote><p>晓美焰：不是你喜欢的人向你表白都是一种负担</p></blockquote><p>18、浅睡眠的人，女朋友睡觉黏人怎么办？</p><blockquote><p>锦衣：小学时，每次没交作业，老师就罚我去擦黑板。并不是黑板不干净，而是因为我没交作业。</p></blockquote><p>19、如何回应女生向你表白？</p><blockquote><p>匿名用户：我靠，翻身的机会竟然不好好把握： 「你是一个好人。」.</p></blockquote><p>20、男朋友趁我睡着偷摸我，我应该如何看待以及怎么办？</p><blockquote><p>谢小龙：只是同居就摸你，等结婚了岂不要那个？这种男人不能要。</p></blockquote><p>21、为什么说「老实的男人容易出轨」？</p><blockquote><p>张不同：朋友圈四大哲理。太老实的男人容易出轨。不抽烟的女人都是婊子。做微商的姑娘月入数万。不上学的孩子都当总裁。</p></blockquote><p>22、暗恋一个人最心酸的事情是什么？</p><blockquote><p>匿名用户：为了不让别人看出来我对他特别好，我只能对每一个人都很好，tmd累死我了。</p></blockquote><p>23、怎么在外给男朋友面子？</p><blockquote><p>东南偏北：同学聚会有一次一起玩真心话大冒险。朋友问女朋友。有没有车震过。女朋友回答有。我心里想女朋友真给我面子。没有在同学面前暴露出我没有车。</p></blockquote><p>24、完美恋爱在你心中是怎样的，谁能设计一段这样的生活细节，对话、心理描写或情节？</p><blockquote><p>吳易易：奇怪，明明两个人，却过得比独处的时候还要自在。</p></blockquote><p>25、你会在意你的恋人有异性闺蜜吗？</p><blockquote><p>匿名用户：女人永远不会明白男人为什么怀疑她跟别的男人的友谊，因为男人太了解男人了！</p></blockquote><p>26、女友让我手写6万字的情书，怎么写？</p><blockquote><p>岳意贺：情书如下：亲爱的，以后在我们在一起的每一天，我都会给你一封写有“我爱你”三个字的情书，这样，等到从今天算起的第55年，你一定能读懂我那6万字的情深。</p></blockquote><p>27、喜欢上妓女怎么办？</p><blockquote><p>胡越：首先，要学会，断句。</p></blockquote><p>28、恋人之间应维持什么程度的忠诚？</p><blockquote><p>俄熊：其实我要求不高。如果不喜欢我了，在找别人之前，先跟我说一声就好了。</p></blockquote><p>29、明知女孩已有男朋友还去追求的男生通常是怎样的人？</p><blockquote><p>匿名用户：深谙投资之道，有男朋友的女孩，对他来说只有一个竞争对手；没有男朋友的女孩，对他来说有无数个竞争对手。</p></blockquote><p>30、女生第一次被男朋友牵手，一般会想什么？</p><blockquote><p>刘婷婷：艹，他手这么大，我的咪咪要嫌小了…</p></blockquote><p>31、在拥有爱情之前，男人和女人最好要知道什么？</p><blockquote><p>谌斌：假装爱一个你不爱的人，即是最大的不自爱。真实地爱一个不爱你的人，并不是丢脸。以爱来绑架一个不爱你的人，则是下作。</p></blockquote><p>32、你最佩服你老公什么？</p><blockquote><p>Yolin Guo：太能捉迷藏了，现在还没出现</p></blockquote><p>33、为什么别人有人追而你没有？</p><blockquote><p>应宝宝：那你扪心自问，如果把她们的男朋友给你，你要么？</p></blockquote><p>34、你同意「不以结婚为目的谈恋爱就是耍流氓」这个观点吗？</p><blockquote><p>廖良玮：不以恋爱为过程的结婚才是耍流氓。</p></blockquote><p>35、平时开玩笑开习惯了，结果跟女生表白人家以为我是开玩笑呢，怎么办？</p><blockquote><p>何太急：她才没误会呢只是她比较善良</p></blockquote><p>36、约会时发现女生的肩带露出来了该如何反应？</p><blockquote><p>张海富：拉起来，放开，啪，一声，特好玩。我忽然明白我为啥没女朋友了</p></blockquote><p>37、如何用最美妙的语句来形容暗恋？</p><blockquote><p>joelancat：不要看我 不要不看我 我变得不是我</p></blockquote><p>38、怎样说服老婆结婚不拍婚纱照？</p><blockquote><p>张可：你一个道具有什么资格叽叽歪歪的？配合就好了。</p></blockquote><p>39、你对现实低头，做过最无奈的一件事是什么？</p><blockquote><p>李少泽：她的手只有我的手四分之三那么大，但我还是没能抓住。</p></blockquote><p>40、情人节没情人怎么办？</p><blockquote><p>Ruah：家里没死人的难道还得在清明节前费劲弄死一个两个的么？ 没有就不过。</p></blockquote><p>41、走在路上被异性搭讪是什么感觉？</p><blockquote><p>王诺诺：国内：“我对英语不感兴趣不学瑜伽不试你们的美容产品身上没带6块钱手机和你一样也没电了。”国外：“我没入党退个毛。”</p></blockquote><p>42、拒绝了我的人是以什么心态偶尔来我空间的？</p><blockquote><p>田广泽：触屏手机就这点不好</p></blockquote><p>43、为什么追我的男生最多只能坚持追半年？</p><blockquote><p>魏道文：18岁的一年和28岁的一年是不一样长的。</p></blockquote><p>44、最让你心动的一句表白语是什么？</p><blockquote><p>费时墨：</p></blockquote><blockquote><p>忘了之前在哪里看到的了：</p></blockquote><blockquote><p>like bald guy.（女：我喜欢秃顶的男人。）</p></blockquote><blockquote><p>I‘m not bald.（男：我可不秃。）</p></blockquote><blockquote><p>I can wait.(女：我能等。)</p></blockquote><p>45、当我有话不直说的时候，为什么男友总是不明白我的心思？</p><blockquote><p>潘俣林：题主，你猜猜我的回答是什么？难道要我直接回答你才能明白？</p></blockquote><p>46、女生什么状态才体现出她已经爱上你了？</p><blockquote><p>余茉：我本满腔怒火，任谁这时候招我，我都会不计后果跟TA死磕。可是看到的竟然是你，所有愤懑都变成委屈，眼眶一下就湿润了。</p></blockquote><p>47、有女朋友时是什么样的感觉？</p><blockquote><p>郭少：奇怪，明明我是个穷小子，可为什么总觉得像是拥有了全世界…</p></blockquote><p>48、一个酷爱自拍的长得不错的妹子却几乎从来不在朋友圈里发照片，为什么？</p><blockquote><p>Kenneth：可能你不属于能看到她经常发自拍的那些个分组。</p></blockquote><p>49、追到女生后马上失去兴趣，怎么办？</p><blockquote><p>匿名用户：“诗人只有在吻到姑娘之前，才歌颂爱情。 他们得到一个女人之后，就开始歌颂自由。”</p></blockquote><p>50、如何优雅含蓄地告诉男生「我觉得你还不错，来追我吧」？</p><blockquote><p>徐微：没用的，我们男生也看脸。</p></blockquote><p>51、你在分手或者表白失败的一瞬间是什么感觉？</p><blockquote><p>黄嘉懿：原来“心痛”这个说法是真的！是生理性的！</p></blockquote><p>52、女生靠追，还是靠吸引？</p><blockquote><p>学博：我身边的一位挺优秀的女生发的朋友圈：到底有多少人到现在还是不明白，人和人之间想要保持长久舒适的关系，靠的是共性和吸引。而不是压迫，捆绑，奉承，和一味的付出以及道德式的自我感动。</p></blockquote><p>53、如何提高女朋友的智商？</p><blockquote><p>赵月：她不喜欢你的时候，智商自然就高起来了。</p></blockquote><p>54、女友被调戏应该怎么办？</p><blockquote><p>Nior：好好赚钱，以后在高档点的餐厅吃饭…</p></blockquote><p>55、有男朋友时是什么样的感觉？</p><blockquote><p>匿名用户：变得连矿泉水瓶都拧不开了</p></blockquote><p>56、如何恰当地回答「女友的三个经典问题」（我跟你妈同时落水你先救谁？如果有人给你一亿让你放弃我你怎么办？我跟前任谁漂亮？？）</p><blockquote><p>于中二：1、我妈。2、你都能问出第一个问题了那肯定选1亿了。3、你已经是我前任了。</p></blockquote><p>57、「不要和一个喜欢看书的女孩子谈恋爱。」这句话应该如何理解？</p><blockquote><p>张小放：我觉得后半句是：“就你这水平，迟早被甩，妥妥的。”</p></blockquote><p>58、你怎么看待相亲？</p><blockquote><p>源未觉醒：相亲这件种事唯一的价值就在于:当你见到相亲对象的那一刻，你就知道你自己在介绍人眼中是个什么货色了。</p></blockquote><p>59、为什么不能和前男友联系？</p><blockquote><p>teenieweenie：感情世界里最没用的四种东西：分手后的悔恨，不爱后的关怀，高高在上的自尊心，低情商的善良。</p></blockquote><p>60、第一次和女朋友出省旅游，应该注意什么？怎么准备？</p><blockquote><p>陳霖：算好经期！（学长只能帮你到这了。。。）</p></blockquote><p>62、你是从哪个细节发现女朋友出轨的？</p><blockquote><p>海上马超：那天回家她一抖被子说给我表演一个大变活人。</p></blockquote><p>63、前男友现任好丑，我应该高兴吗？</p><blockquote><p>匿名用户：他宁可要一个丑女人都不要你，姑娘长点心吧</p></blockquote><p>64、有个很聪明的女朋友是怎样的体验？</p><blockquote><p>诸葛不亮：拿朋友的手机给我女朋友打电话，一接通我还没开口她就知道叫亲爱的。</p></blockquote><p>65、前女友的新欢是个渣男，应该提醒她吗 ？</p><blockquote><p>chen hao：以圣人的标准要求别人，以贱人的标准要求自己。</p></blockquote><p>66、怎么看待女朋友的蓝颜？</p><blockquote><p>诗诗诗扬：蓝颜蓝颜，加点黄色就绿了</p></blockquote><p>67、热恋阶段，见到恋人时你想做的第一件事是什么？</p><blockquote><p>一一：笑。</p></blockquote><p>68、跟漂亮的女孩子谈恋爱是什么感觉？</p><blockquote><p>明小夷：我妈都觉得女朋友瞎了眼<del>~</del></p></blockquote><p>69、如何反驳「你单身说明你不优秀」？</p><blockquote><p>陈书：恰恰相反，我单身是说明你们还不够优秀。</p></blockquote><p>70、如何用一句话形容「心动」？</p><blockquote><p>张随便：想戴上最美的面具，又想卸下所有的伪装。</p></blockquote><p>71、和「女神」约会是一种什么样的体验？</p><blockquote><p>花爺：和女神约会，与考试、吵架，并称为三大事后总觉得没发挥好的事情。</p></blockquote><p>72、表白被拒绝时听过最狠的话是什么？</p><blockquote><p>匿名用户：「 轮奸也轮不到你 」</p></blockquote><p>73、向喜欢的女生表白被拒绝了，还是喜欢她，怎么办？</p><blockquote><p>邵鸽：也许你弄错了什么是表白，表白应该是最终胜利时的号角，而不应该是发起进攻的冲锋号。</p></blockquote><p>74、在书店如何跟女生搭讪？</p><blockquote><p>屠钱钱：你就说：……美女，喜欢书吗？美女说：喜欢……你就说：叔也喜欢你～</p></blockquote><p>75、有些女生拒绝改善形象，为了「在最差的状态下寻找真爱」，这种想法靠谱吗？</p><blockquote><p>匿名用户：如果你以最严苛的方式来定义真爱，那么真爱也会以最渺茫的概率来考验你。</p></blockquote><p>76、姑娘发短信说「我感冒了」，最好的回答是什么？</p><blockquote><p>Gay：开门。</p></blockquote><p>77、接吻技巧好说明一个人接吻经验丰富吗？</p><blockquote><p>马前卒：不一定，但能做出【技巧好】判断的人肯定经验丰富。</p></blockquote><p>78、如何成为一名优秀的女朋友？</p><blockquote><p>木木夕子：保护他内心的小男孩</p></blockquote><p>79、约妹子看电影时对影片的选择有分歧，该怎么办？</p><blockquote><p>Emileo：居然有分歧，看来你确实想看电影…</p></blockquote><p>80、为什么一群剩女都说找不到合适的，然后一群宅男还在叨叨没妹子？ 除相亲外，剩男怎么找到剩女？</p><blockquote><p>澜心：宅男说没妹子，就像独自站在荒凉的沙漠中，那是真没妹子。剩女说找不到合适的，就像站在自动售货机面前却没有喜欢的饮料，挑不出一个中意的。</p></blockquote><p>81、为什么找男朋友那么难？</p><blockquote><p>camen：没有一见钟情的资本，又缺少日久生情的条件</p></blockquote><p>82、女友跟前男友分手炮后怀孕了，我应该怎么办？</p><blockquote><p>匿名用户：谁污染，谁治理。谁开发，谁保护。</p></blockquote><p>83、男朋友假期一两个月不主动联系我，如何调教？</p><blockquote><p>于百威：大家回答得都太阴暗，什么劈腿变心从来没爱过你之类的，凡事要往好的方面想。我猜你男朋友应该是死了。</p></blockquote><p>84、如果恋爱不牵手，不接吻，不上床，就不是恋爱，爱一个人的表现真的要这些身体接触吗？</p><blockquote><p>苏莉安：当然了，不然你觉得为啥“爱情”和“受精”长那么像。</p></blockquote><p>85、如何拒绝不爱但很善良的男生？</p><blockquote><p>默默：不要在寂寞的时候找他。</p></blockquote><p>86、女人的必杀技是「你敢吼我」，男人的必杀技是什么？</p><blockquote><p>匿名用户：你要是这么想我也没办法。</p></blockquote><p>87、热恋是一种怎样的体验？</p><blockquote><p>岳师太：两个长得像猪一样的人，还怕对方被抢走……</p></blockquote><p>88、已经有女朋友了，但又遇到更喜欢的对象怎么办？</p><blockquote><p>匿名用户：想起一句话：不要相信在野党，执政之后都一样。</p></blockquote><p>89、女朋友总觉得别人的男朋友好，我该怎么办？</p><blockquote><p>李雨谦：成为别人的男朋友</p></blockquote><p>90、怎样拒绝女生的告白？</p><blockquote><p>王诺诺：对不起，我是个好人。</p></blockquote><p>91、喜欢上一个有女朋友的男生，该男生有表示想要一起睡，一起亲过也抱过，他有没有可能喜欢上自己？</p><blockquote><p>藤本烈：这样的男生可能会喜欢上你，但绝对不可能喜欢上你。</p></blockquote><p>92、为什么那么多人说自己寂寞、孤单、想找个男/女朋友，却还是单身？</p><blockquote><p>许甜甜：因为不仅自己丑，还嫌别人长得丑。</p></blockquote><p>93、如何追到女神？</p><blockquote><p>ScottDong：当你提到“女神”两个字，你已经输定了。</p></blockquote><p>94、接吻的时候女生的手在干什么？</p><blockquote><p>白源源：抓住他的胳膊，抓稳了，不然谁知道他要摸哪里!</p></blockquote><p>95、2b青年们能把情书写到什么水平？</p><blockquote><p>高山流囧：﹏ 、涐対沵旳那份情。╰★つ始终都割舍卜下 卍。**</p></blockquote><p>96、男朋友为什么在和我吃饭的时候玩手机？</p><blockquote><p>宇宙无敌小怪兽：可能他觉得吃饭的时候玩女朋友不太好</p></blockquote><p>97、淘宝居然有个业务叫「查男朋友忠诚度」，你会去试吗？</p><blockquote><p>alex an：手中的玻璃杯有多坚固？只有摔碎的那一刻你才知道。</p></blockquote><p>98、男生长相到底有多重要？</p><blockquote><p>燕子坞：高考是你这辈子最后一次不看长相的比赛了</p></blockquote><p>99、等一个不爱你的女生真的好吗？</p><blockquote><p>秋刀鱼：等一个不爱你的人，就像在机场等一艘船。</p></blockquote><p>100、为什么说「喜不喜欢和合不合适是两回事」？</p><blockquote><p>Hypnos：您没有买过鞋吗？</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>生活</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>存在即合理--TableLayout实现布局约束</title>
    <link href="/2018/03/02/%E5%AD%98%E5%9C%A8%E5%8D%B3%E5%90%88%E7%90%86-TableLayout%E5%AE%9E%E7%8E%B0%E5%9B%BE%E6%96%87%E6%B7%B7%E6%8E%92/"/>
    <url>/2018/03/02/%E5%AD%98%E5%9C%A8%E5%8D%B3%E5%90%88%E7%90%86-TableLayout%E5%AE%9E%E7%8E%B0%E5%9B%BE%E6%96%87%E6%B7%B7%E6%8E%92/</url>
    
    <content type="html"><![CDATA[<p>写android好久了，我都没怎么用过TableLayout，昨天小白问我一个布局问题，这个布局问题的描述为：线性布局防止右侧布局挤出去、图文混排效果、字少包裹内容 字多占满剩余、不知道怎么解释的效果。其实想实现的效果如下：<br><img src="/img/EAE885FA5952F0A84E0B924AC3126F6A.jpg" srcset="/img/loading.gif"><br>当标题文字很长的时候，应该显示出这样的效果：<br><img src="/img/5D9A84A5D02BCDC0D3860E75518A615D.jpg" srcset="/img/loading.gif"><br>我们想了好久都没找到合适的方法，不知道哪里来的灵感，我突然想起了被人们遗忘的TableLayout。</p><a id="more"></a><h2 id="TableLayout介绍"><a href="#TableLayout介绍" class="headerlink" title="TableLayout介绍"></a>TableLayout介绍</h2><h3 id="Tablelayout简介"><a href="#Tablelayout简介" class="headerlink" title="Tablelayout简介"></a>Tablelayout简介</h3><p>Tablelayout类以行和列的形式对控件进行管理，每一行为一个TableRow对象，或一个View控件。<br>当为TableRow对象时，可在TableRow下添加子控件，默认情况下，每个子控件占据一列。<br>当为View时，该View将独占一行。</p><h3 id="TableLayout行列数的确定"><a href="#TableLayout行列数的确定" class="headerlink" title="TableLayout行列数的确定"></a>TableLayout行列数的确定</h3><p>TableLayout的行数由开发人员直接指定，即有多少个TableRow对象（或View控件），就有多少行。<br>TableLayout的列数等于含有最多子控件的TableRow的列数。如第一TableRow含2个子控件，第二个TableRow含3个，第三个TableRow含4个，那么该TableLayout的列数为4.</p><h3 id="TableLayout可设置的属性详解"><a href="#TableLayout可设置的属性详解" class="headerlink" title="TableLayout可设置的属性详解"></a>TableLayout可设置的属性详解</h3><p>TableLayout可设置的属性包括全局属性及单元格属性。</p><h4 id="全局属性也即列属性，有以下3个参数："><a href="#全局属性也即列属性，有以下3个参数：" class="headerlink" title="全局属性也即列属性，有以下3个参数："></a>全局属性也即列属性，有以下3个参数：</h4><div class="hljs"><pre><code class="hljs dts"><span class="hljs-symbol">android:</span>stretchColumns    <span class="hljs-comment">// 设置可伸展的列。该列可以向行方向伸展，最多可占据一整行。</span><span class="hljs-symbol">android:</span>shrinkColumns     <span class="hljs-comment">// 设置可收缩的列。当该列子控件的内容太多，已经挤满所在行，那么该子控件的内容将往列方向显示。</span><span class="hljs-symbol">android:</span>collapseColumns     <span class="hljs-comment">// 设置要隐藏的列。</span></code></pre></div><p>示例：</p><div class="hljs"><pre><code class="hljs dts"><span class="hljs-symbol">android:</span>stretchColumns=<span class="hljs-string">"0"</span>       <span class="hljs-comment">// 第0列可伸展</span><span class="hljs-symbol">android:</span>shrinkColumns=<span class="hljs-string">"1,2"</span>      <span class="hljs-comment">// 第1,2列皆可收缩</span><span class="hljs-symbol">android:</span>collapseColumns=<span class="hljs-string">"*"</span>      <span class="hljs-comment">// 隐藏所有行</span></code></pre></div><p>说明：列可以同时具备stretchColumns及shrinkColumns属性，若此，那么当该列的内容N多时，将“多行”显示其内容。（这里不是真正的多行，而是系统根据需要自动调节该行的layout_height）</p><h4 id="单元格属性，有以下2个参数："><a href="#单元格属性，有以下2个参数：" class="headerlink" title="单元格属性，有以下2个参数："></a>单元格属性，有以下2个参数：</h4><div class="hljs"><pre><code class="hljs dts"><span class="hljs-symbol">android:</span>layout_column    <span class="hljs-comment">// 指定该单元格在第几列显示</span><span class="hljs-symbol">android:</span>layout_span       <span class="hljs-comment">// 指定该单元格占据的列数（未指定时，为1）</span></code></pre></div><p>示例：</p><div class="hljs"><pre><code class="hljs dts"><span class="hljs-symbol">android:</span>layout_column=<span class="hljs-string">"1"</span>    <span class="hljs-comment">// 该控件显示在第1列</span><span class="hljs-symbol">android:</span>layout_span=<span class="hljs-string">"2"</span>      <span class="hljs-comment">// 该控件占据2列</span></code></pre></div><p>说明：一个控件也可以同时具备这两个特性。</p><blockquote><p>以上介绍参考自：<a href="http://blog.csdn.net/justoneroad/article/details/6835915" target="_blank" rel="noopener">android:TableLayout表格布局详解</a></p></blockquote><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>话说回到刚开始的场景，我们希望实现的效果是这样：<br><img src="/img/EAE885FA5952F0A84E0B924AC3126F6A.jpg" srcset="/img/loading.gif"><br>当标题文字很长的时候，应该显示出这样的效果：<br><img src="/img/5D9A84A5D02BCDC0D3860E75518A615D.jpg" srcset="/img/loading.gif"></p><p>在使用RelativeLayout的布局方法时，当标题部分过长时，后面的icon会被挤出布局，导致icon显示不出来。<br>最后，我们使用了TableLayout的布局方式，其中使用shrinkColumns来指定第0列是可以收缩的。这样第1列就不会被挤掉。<br>具体布局代码如下：</p><div class="hljs"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">LinearLayout</span></span><span class="hljs-tag">    <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">"http://schemas.android.com/apk/res/android"</span></span><span class="hljs-tag">    <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">"match_parent"</span></span><span class="hljs-tag">    <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">"match_parent"</span></span><span class="hljs-tag">    <span class="hljs-attr">android:orientation</span>=<span class="hljs-string">"vertical"</span></span><span class="hljs-tag">    <span class="hljs-attr">android:paddingLeft</span>=<span class="hljs-string">"20dp"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">LinearLayout</span></span><span class="hljs-tag">        <span class="hljs-attr">android:id</span>=<span class="hljs-string">"@+id/ll_item_bd"</span></span><span class="hljs-tag">        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">"match_parent"</span></span><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">"40dp"</span></span><span class="hljs-tag">        <span class="hljs-attr">android:gravity</span>=<span class="hljs-string">"center_vertical"</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">ImageView</span></span><span class="hljs-tag">            <span class="hljs-attr">android:id</span>=<span class="hljs-string">"@+id/iv_flag"</span></span><span class="hljs-tag">            <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">"wrap_content"</span></span><span class="hljs-tag">            <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">"wrap_content"</span></span><span class="hljs-tag">            <span class="hljs-attr">android:src</span>=<span class="hljs-string">"@drawable/ic_action_info"</span>/&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">TableLayout</span></span><span class="hljs-tag">            <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">"0dp"</span></span><span class="hljs-tag">            <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">"wrap_content"</span></span><span class="hljs-tag">            <span class="hljs-attr">android:shrinkColumns</span>=<span class="hljs-string">"0"</span></span><span class="hljs-tag">            <span class="hljs-attr">android:layout_marginLeft</span>=<span class="hljs-string">"8dp"</span></span><span class="hljs-tag">            <span class="hljs-attr">android:layout_weight</span>=<span class="hljs-string">"1"</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">TableRow</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">TextView</span></span><span class="hljs-tag">                    <span class="hljs-attr">android:id</span>=<span class="hljs-string">"@+id/tv_patient_content"</span></span><span class="hljs-tag">                    <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">"wrap_content"</span></span><span class="hljs-tag">                    <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">"wrap_content"</span></span><span class="hljs-tag">                    <span class="hljs-attr">android:ellipsize</span>=<span class="hljs-string">"end"</span></span><span class="hljs-tag">                    <span class="hljs-attr">android:singleLine</span>=<span class="hljs-string">"true"</span></span><span class="hljs-tag">                    <span class="hljs-attr">android:text</span>=<span class="hljs-string">"这是一段很长很长很长很长很长很长的"</span></span><span class="hljs-tag">                    <span class="hljs-attr">android:textSize</span>=<span class="hljs-string">"18sp"</span>/&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">ImageView</span></span><span class="hljs-tag">                    <span class="hljs-attr">android:id</span>=<span class="hljs-string">"@+id/iv_exception"</span></span><span class="hljs-tag">                    <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">"16dp"</span></span><span class="hljs-tag">                    <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">"16dp"</span></span><span class="hljs-tag">                    <span class="hljs-attr">android:scaleType</span>=<span class="hljs-string">"fitXY"</span></span><span class="hljs-tag">                    <span class="hljs-attr">android:src</span>=<span class="hljs-string">"@drawable/ic_action_info"</span></span><span class="hljs-tag">                    <span class="hljs-attr">android:visibility</span>=<span class="hljs-string">"visible"</span>/&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">TableRow</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">TableLayout</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">TextView</span></span><span class="hljs-tag">            <span class="hljs-attr">android:id</span>=<span class="hljs-string">"@+id/tv_patient_complete"</span></span><span class="hljs-tag">            <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">"wrap_content"</span></span><span class="hljs-tag">            <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">"wrap_content"</span></span><span class="hljs-tag">            <span class="hljs-attr">android:layout_marginRight</span>=<span class="hljs-string">"20dp"</span></span><span class="hljs-tag">            <span class="hljs-attr">android:text</span>=<span class="hljs-string">"未完成"</span></span><span class="hljs-tag">            <span class="hljs-attr">android:textSize</span>=<span class="hljs-string">"16sp"</span>/&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">LinearLayout</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">View</span></span><span class="hljs-tag">        <span class="hljs-attr">android:id</span>=<span class="hljs-string">"@+id/line"</span></span><span class="hljs-tag">        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">"match_parent"</span></span><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">"1px"</span></span><span class="hljs-tag">        <span class="hljs-attr">android:background</span>=<span class="hljs-string">"#D8D8D8"</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">LinearLayout</span>&gt;</span></code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2018的上半年</title>
    <link href="/2018/02/24/2018%E7%9A%84%E4%B8%8A%E5%8D%8A%E5%B9%B4/"/>
    <url>/2018/02/24/2018%E7%9A%84%E4%B8%8A%E5%8D%8A%E5%B9%B4/</url>
    
    <content type="html"><![CDATA[<p>又要开始吹牛了<br>哈哈<br>乐此不疲</p><a id="more"></a><h2 id="回顾一下去年的计划"><a href="#回顾一下去年的计划" class="headerlink" title="回顾一下去年的计划"></a>回顾一下去年的计划</h2><p>去年主要是看书和增重，增重还可以，但是书看的不多。果然还是吃比较容易。hh</p><p>骑行的想法今年应该不会有了，主要是听说长时间骑行可能导致不孕不育。</p><h2 id="2018年上（农历）"><a href="#2018年上（农历）" class="headerlink" title="2018年上（农历）"></a>2018年上（农历）</h2><ol><li>保持身材</li><li>学驾照</li><li>理理财</li><li>Android的技术还要继续学</li><li>争取带女朋友回老家</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>计划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android面试题第二发</title>
    <link href="/2018/02/11/Android%E9%9D%A2%E8%AF%95%E9%A2%98%E7%AC%AC%E4%BA%8C%E5%8F%91/"/>
    <url>/2018/02/11/Android%E9%9D%A2%E8%AF%95%E9%A2%98%E7%AC%AC%E4%BA%8C%E5%8F%91/</url>
    
    <content type="html"><![CDATA[<p>Android大厂面试题锦集附答案(BAT TMD JD 小米)</p><blockquote><p>转载自: 2018-02-10 何时夕 安卓巴士Android开发者门户<br><a href="https://mp.weixin.qq.com/s?__biz=MzA3MjgwNDIzNQ==&amp;mid=2651942440&amp;idx=1&amp;sn=c1518479845e73a495fcc7f27593ce7f&amp;chksm=84fd7cccb38af5da737288d4b4ffe868d125e427a5caf7b4fdc005edf435c73eae68106f64f3&amp;mpshare=1&amp;scene=23&amp;srcid=0211LMUCPgy0HNWHurBeBLJV#rd" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MzA3MjgwNDIzNQ==&amp;mid=2651942440&amp;idx=1&amp;sn=c1518479845e73a495fcc7f27593ce7f&amp;chksm=84fd7cccb38af5da737288d4b4ffe868d125e427a5caf7b4fdc005edf435c73eae68106f64f3&amp;mpshare=1&amp;scene=23&amp;srcid=0211LMUCPgy0HNWHurBeBLJV#rd</a></p></blockquote><a id="more"></a><blockquote><p>上次写这篇文章的时候也差不多是一年前了，这一年我兜兜转转从android到java又回到android，校招面了很多大厂，阿里、京东、小米、头条、知乎、腾讯、有赞，也收获了几个offer。感谢大家的关注，让我在简书上面也混到了一个<strong>简书程序员优秀作者</strong>的称号，所以为了回馈大家，一篇<strong>最完全的android面经</strong>诞生了。这是我集合了牛客网、百度、简书等网站的<strong>几十篇面经</strong>和我自己面试的经历的合集，希望大家喜欢。<strong>(ps:里面当然会有纰漏，如果有问题欢迎大家留言或者加我QQ讨论)</strong>(pps:有<strong>简书</strong>的同学可以关注一波:<a href="https://www.jianshu.com/u/45661204c0d6" target="_blank" rel="noopener">何时夕</a>)</p></blockquote><h2 id="android事件分发机制，请详细说下整个流程"><a href="#android事件分发机制，请详细说下整个流程" class="headerlink" title="android事件分发机制，请详细说下整个流程"></a>android事件分发机制，请详细说下整个流程</h2><p><img src="http://upload-images.jianshu.io/upload_images/2911038-5349d6ebb32372da?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt="事件分发（面试）.png" title="事件分发（面试）.png"></p><h2 id="android-view绘制机制和加载过程，请详细说下整个流程"><a href="#android-view绘制机制和加载过程，请详细说下整个流程" class="headerlink" title="android view绘制机制和加载过程，请详细说下整个流程"></a>android view绘制机制和加载过程，请详细说下整个流程</h2><ul><li><p>1.ViewRootImpl会调用performTraversals(),其内部会调用performMeasure()、performLayout、performDraw()。</p></li><li><p>2.performMeasure()会调用最外层的ViewGroup的measure()–&gt;onMeasure(),ViewGroup的onMeasure()是抽象方法，但其提供了measureChildren()，这之中会遍历子View然后循环调用measureChild()这之中会用getChildMeasureSpec()+父View的MeasureSpec+子View的LayoutParam一起获取本View的MeasureSpec，然后调用子View的measure()到View的onMeasure()–&gt;setMeasureDimension(getDefaultSize(),getDefaultSize()),getDefaultSize()默认返回measureSpec的测量数值，所以继承View进行自定义的wrap_content需要重写。</p></li><li><p>3.performLayout()会调用最外层的ViewGroup的layout(l,t,r,b),本View在其中使用setFrame()设置本View的四个顶点位置。在onLayout(抽象方法)中确定子View的位置，如LinearLayout会遍历子View，循环调用setChildFrame()–&gt;子View.layout()。</p></li><li><p>4.performDraw()会调用最外层ViewGroup的draw():其中会先后调用background.draw()(绘制背景)、onDraw()(绘制自己)、dispatchDraw()(绘制子View)、onDrawScrollBars()(绘制装饰)。</p></li><li><p>5.MeasureSpec由2位SpecMode(UNSPECIFIED、EXACTLY(对应精确值和match_parent)、AT_MOST(对应warp_content))和30位SpecSize组成一个int,DecorView的MeasureSpec由窗口大小和其LayoutParams决定，其他View由父View的MeasureSpec和本View的LayoutParams决定。ViewGroup中有getChildMeasureSpec()来获取子View的MeasureSpec。</p></li><li><p>6.三种方式获取measure()后的宽高：</p><ul><li><p>1.Activity#onWindowFocusChange()中调用获取</p><ul><li><p>2.view.post(Runnable)将获取的代码投递到消息队列的尾部。</p></li><li><p>3.ViewTreeObservable.</p></li></ul></li></ul></li></ul><h2 id="android四大组件的加载过程，请详细介绍下"><a href="#android四大组件的加载过程，请详细介绍下" class="headerlink" title="android四大组件的加载过程，请详细介绍下"></a>android四大组件的加载过程，请详细介绍下</h2><ul><li>1.<a href="https://www.jianshu.com/p/f499afd8d0ab" target="_blank" rel="noopener">android四大组件的加载过程</a>:这是我总结的一篇博客</li></ul><h2 id="Activity的启动模式"><a href="#Activity的启动模式" class="headerlink" title="Activity的启动模式"></a>Activity的启动模式</h2><ul><li><p>1.standard:默认标准模式，每启动一个都会创建一个实例，</p></li><li><p>2.singleTop：栈顶复用，如果在栈顶就调用onNewIntent复用，从onResume()开始</p></li><li><p>3.singleTask：栈内复用，本栈内只要用该类型Activity就会将其顶部的activity出栈</p></li><li><p>4.singleInstance：单例模式，除了3中特性，系统会单独给该Activity创建一个栈，</p></li></ul><h2 id="A、B、C、D分别是四种Activity的启动模式，那么A-gt-B-gt-C-gt-D-gt-A-gt-B-gt-C-gt-D分别启动，最后的activity栈是怎么样的"><a href="#A、B、C、D分别是四种Activity的启动模式，那么A-gt-B-gt-C-gt-D-gt-A-gt-B-gt-C-gt-D分别启动，最后的activity栈是怎么样的" class="headerlink" title="A、B、C、D分别是四种Activity的启动模式，那么A-&gt;B-&gt;C-&gt;D-&gt;A-&gt;B-&gt;C-&gt;D分别启动，最后的activity栈是怎么样的"></a>A、B、C、D分别是四种Activity的启动模式，那么A-&gt;B-&gt;C-&gt;D-&gt;A-&gt;B-&gt;C-&gt;D分别启动，最后的activity栈是怎么样的</h2><ul><li><p>1.这个题目需要深入了解activity的启动模式</p></li><li><p>2.最后的答案是：两个栈，前台栈是只有D，后台栈从底至上是A、B、C</p></li></ul><h2 id="Activity缓存方法"><a href="#Activity缓存方法" class="headerlink" title="Activity缓存方法"></a>Activity缓存方法</h2><ul><li><p>1.配置改变导致Activity被杀死，横屏变竖屏：在onStop之前会调用onSaveInstanceState()保存数据在重建Activity之后，会在onStart()之后调用onRestoreInstanceState(),并把保存下来的Bundle传给onCreate()和它会默认重建Activity当前的视图，我们可以在onCreate()中，回复自己的数据。</p></li><li><p>2.内存不足杀掉Activity，优先级分别是：前台可见，可见非前台，后台。</p></li></ul><h2 id="Service的生命周期，两种启动方法，有什么区别"><a href="#Service的生命周期，两种启动方法，有什么区别" class="headerlink" title="Service的生命周期，两种启动方法，有什么区别"></a>Service的生命周期，两种启动方法，有什么区别</h2><ul><li><p>1.context.startService() -&gt;onCreate()- &gt;onStart()-&gt;Service running–&gt;(如果调用context.stopService() )-&gt;onDestroy() -&gt;Service shut down</p><ul><li><p>1.如果Service还没有运行，则调用onCreate()然后调用onStart()；</p><ul><li><p>2.如果Service已经运行，则只调用onStart()，所以一个Service的onStart方法可能会重复调用多次。</p></li><li><p>3.调用stopService的时候直接onDestroy，</p></li><li><p>4.如果是调用者自己直接退出而没有调用stopService的话，Service会一直在后台运行。该Service的调用者再启动起来后可以通过stopService关闭Service。</p></li></ul></li></ul></li><li><p>2.context.bindService()-&gt;onCreate()-&gt;onBind()-&gt;Service running–&gt;onUnbind() -&gt; onDestroy() -&gt;Service stop</p><ul><li><p>1.onBind将返回给客户端一个IBind接口实例，IBind允许客户端回调服务的方法，比如得到Service运行的状态或其他操作。</p><ul><li><p>2.这个时候会把调用者和Service绑定在一起，Context退出了,Service就会调用onUnbind-&gt;onDestroy相应退出。</p></li><li><p>3.所以调用bindService的生命周期为：onCreate –&gt; onBind(只一次，不可多次绑定) –&gt; onUnbind –&gt; onDestory。</p></li></ul></li></ul></li></ul><h2 id="怎么保证service不被杀死"><a href="#怎么保证service不被杀死" class="headerlink" title="怎么保证service不被杀死"></a>怎么保证service不被杀死</h2><ul><li><p>1.提升service优先级</p></li><li><p>2.提升service进程优先级</p></li><li><p>3.onDestroy方法里重启service</p></li></ul><h2 id="静态的Broadcast-和动态的有什么区别"><a href="#静态的Broadcast-和动态的有什么区别" class="headerlink" title="静态的Broadcast 和动态的有什么区别"></a>静态的Broadcast 和动态的有什么区别</h2><ul><li><p>1.动态的比静态的安全</p></li><li><p>2.静态在app启动的时候就初始化了 动态使用代码初始化</p></li><li><p>3.静态需要配置 动态不需要</p></li><li><p>4.生存期，静态广播的生存期可以比动态广播的长很多</p></li><li><p>5.优先级动态广播的优先级比静态广播高</p></li></ul><h2 id="1Intent可以传递哪些数据类型"><a href="#1Intent可以传递哪些数据类型" class="headerlink" title="1Intent可以传递哪些数据类型"></a>1Intent可以传递哪些数据类型</h2><ul><li><p>1.Serializable</p></li><li><p>2.charsequence: 主要用来传递String，char等</p></li><li><p>3.parcelable</p></li><li><p>4.Bundle</p></li></ul><h2 id="1Json有什么优劣势、解析的原理"><a href="#1Json有什么优劣势、解析的原理" class="headerlink" title="1Json有什么优劣势、解析的原理"></a>1Json有什么优劣势、解析的原理</h2><ul><li><p>1.JSON的速度要远远快于XML</p></li><li><p>2.JSON相对于XML来讲，数据的体积小</p></li><li><p>3.JSON对数据的描述性比XML较差</p></li><li><p>4.解析的基本原理是：词法分析</p></li></ul><h2 id="1一个语言的编译过程"><a href="#1一个语言的编译过程" class="headerlink" title="1一个语言的编译过程"></a>1一个语言的编译过程</h2><ul><li><p>1.词法分析：将一串文本按规则分割成最小的结构，关键字、标识符、运算符、界符和常量等。一般实现方法是自动机和正则表达式</p></li><li><p>2.语法分析：将一系列单词组合成语法树。一般实现方法有自顶向下和自底向上</p></li><li><p>3.语义分析：对结构上正确的源程序进行上下文有关性质的审查</p></li><li><p>4.目标代码生成</p></li><li><p>5.代码优化：优化生成的目标代码，</p></li></ul><h2 id="1动画有哪几类，各有什么特点"><a href="#1动画有哪几类，各有什么特点" class="headerlink" title="1动画有哪几类，各有什么特点"></a>1动画有哪几类，各有什么特点</h2><ul><li><p>1.动画的基本原理：其实就是利用插值器和估值器，来计算出各个时刻View的属性，然后通过改变View的属性来，实现View的动画效果。</p></li><li><p>2.View动画:只是影像变化，view的实际位置还在原来的地方。</p></li><li><p>3.帧动画是在xml中定义好一系列图片之后，使用AnimationDrawable来播放的动画。</p></li><li><p>4.View的属性动画：</p><ul><li><p>1.插值器：作用是根据时间的流逝的百分比来计算属性改变的百分比</p><ul><li>2.估值器：在1的基础上由这个东西来计算出属性到底变化了多少数值的类</li></ul></li></ul></li></ul><h2 id="1Handler、Looper消息队列模型，各部分的作用"><a href="#1Handler、Looper消息队列模型，各部分的作用" class="headerlink" title="1Handler、Looper消息队列模型，各部分的作用"></a>1Handler、Looper消息队列模型，各部分的作用</h2><ul><li><p>1.MessageQueue：读取会自动删除消息，单链表维护，在插入和删除上有优势。在其next()中会无限循环，不断判断是否有消息，有就返回这条消息并移除。</p></li><li><p>2.Looper：Looper创建的时候会创建一个MessageQueue，调用loop()方法的时候消息循环开始，loop()也是一个死循环，会不断调用messageQueue的next()，当有消息就处理，否则阻塞在messageQueue的next()中。当Looper的quit()被调用的时候会调用messageQueue的quit(),此时next()会返回null，然后loop()方法也跟着退出。</p></li><li><p>3.Handler：在主线程构造一个Handler，然后在其他线程调用sendMessage(),此时主线程的MessageQueue中会插入一条message，然后被Looper使用。</p></li><li><p>4.系统的主线程在ActivityThread的main()为入口开启主线程，其中定义了内部类Activity.H定义了一系列消息类型，包含四大组件的启动停止。</p></li><li><p>5.MessageQueue和Looper是一对一关系，Handler和Looper是多对一</p></li></ul><h2 id="1怎样退出终止App"><a href="#1怎样退出终止App" class="headerlink" title="1怎样退出终止App"></a>1怎样退出终止App</h2><ul><li>1.自己设置一个Activity的栈，然后一个个finish()</li></ul><h2 id="1Android-IPC-Binder原理"><a href="#1Android-IPC-Binder原理" class="headerlink" title="1Android IPC:Binder原理"></a>1Android IPC:Binder原理</h2><h3 id="1-在Activity和Service进行通讯的时候，用到了Binder。"><a href="#1-在Activity和Service进行通讯的时候，用到了Binder。" class="headerlink" title="1.在Activity和Service进行通讯的时候，用到了Binder。"></a>1.在Activity和Service进行通讯的时候，用到了Binder。</h3><ul><li>1.当属于同个进程我们可以继承Binder然后在Activity中对Service进行操作</li><li>2.当不属于同个进程，那么要用到AIDL让系统给我们创建一个Binder，然后在Activity中对远端的Service进行操作。</li></ul><h3 id="2-系统给我们生成的Binder："><a href="#2-系统给我们生成的Binder：" class="headerlink" title="2.系统给我们生成的Binder："></a>2.系统给我们生成的Binder：</h3><ul><li>1.Stub类中有:接口方法的id，有该Binder的标识，有asInterface(IBinder)(让我们在Activity中获取实现了Binder的接口，接口的实现在Service里，同进程时候返回Stub否则返回Proxy)，有onTransact()这个方法是在不同进程的时候让Proxy在Activity进行远端调用实现Activity操作Service</li><li>2.Proxy类是代理，在Activity端，其中有:IBinder mRemote(这就是远端的Binder)，两个接口的实现方法不过是代理最终还是要在远端的onTransact()中进行实际操作。</li><li>3.哪一端的Binder是副本，该端就可以被另一端进行操作，因为Binder本体在定义的时候可以操作本端的东西。所以可以在Activity端传入本端的Binder，让Service端对其进行操作称为Listener，可以用RemoteCallbackList这个容器来装Listener，防止Listener因为经历过序列化而产生的问题。</li><li>4.当Activity端向远端进行调用的时候，当前线程会挂起，当方法处理完毕才会唤醒。</li><li>5.如果一个AIDL就用一个Service太奢侈，所以可以使用Binder池的方式，建立一个AIDL其中的方法是返回IBinder，然后根据方法中传入的参数返回具体的AIDL。</li><li>6.IPC的方式有：Bundle（在Intent启动的时候传入，不过是一次性的），文件共享(对于SharedPreference是特例，因为其在内存中会有缓存)，使用Messenger(其底层用的也是AIDL，同理要操作哪端，就在哪端定义Messenger)，AIDL，ContentProvider(在本进程中继承实现一个ContentProvider，在增删改查方法中调用本进程的SQLite，在其他进程中查询)，Socket</li></ul><h2 id="1描述一次跨进程通讯"><a href="#1描述一次跨进程通讯" class="headerlink" title="1描述一次跨进程通讯"></a>1描述一次跨进程通讯</h2><ul><li>1.client、proxy、serviceManager、BinderDriver、impl、service</li><li>2.client发起一个请求service信息的Binder请求到BinderDriver中，serviceManager发现BinderDiriver中有自己的请求 然后将clinet请求的service的数据返回给client这样完成了一次Binder通讯</li><li>3.clinet获取的service信息就是该service的proxy，此时调用proxy的方法，proxy将请求发送到BinderDriver中，此时service的 Binder线程池循环发现有自己的请求，然后用impl就处理这个请求最后返回，这样完成了第二次Binder通讯</li><li>4.中间client可挂起，也可以不挂起，有一个关键字oneway可以解决这个</li></ul><h2 id="1android重要术语解释"><a href="#1android重要术语解释" class="headerlink" title="1android重要术语解释"></a>1android重要术语解释</h2><ul><li><p>1.ActivityManagerServices，简称AMS，服务端对象，负责系统中所有Activity的生命周期</p></li><li><p>2.ActivityThread，App的真正入口。当开启App之后，会调用main()开始运行，开启消息循环队列，这就是传说中的UI线程或者叫主线程。与ActivityManagerServices配合，一起完成Activity的管理工作</p></li><li><p>3.ApplicationThread，用来实现ActivityManagerService与ActivityThread之间的交互。在ActivityManagerService需要管理相关Application中的Activity的生命周期时，通过ApplicationThread的代理对象与ActivityThread通讯。</p></li><li><p>4.ApplicationThreadProxy，是ApplicationThread在服务器端的代理，负责和客户端的ApplicationThread通讯。AMS就是通过该代理与ActivityThread进行通信的。</p></li><li><p>5.Instrumentation，每一个应用程序只有一个Instrumentation对象，每个Activity内都有一个对该对象的引用。Instrumentation可以理解为应用进程的管家，ActivityThread要创建或暂停某个Activity时，都需要通过Instrumentation来进行具体的操作。</p></li><li><p>6.ActivityStack，Activity在AMS的栈管理，用来记录已经启动的Activity的先后关系，状态信息等。通过ActivityStack决定是否需要启动新的进程。</p></li><li><p>7.ActivityRecord，ActivityStack的管理对象，每个Activity在AMS对应一个ActivityRecord，来记录Activity的状态以及其他的管理信息。其实就是服务器端的Activity对象的映像。</p></li><li><p>8.TaskRecord，AMS抽象出来的一个“任务”的概念，是记录ActivityRecord的栈，一个“Task”包含若干个ActivityRecord。AMS用TaskRecord确保Activity启动和退出的顺序。如果你清楚Activity的4种launchMode，那么对这个概念应该不陌生。</p></li></ul><h2 id="1理解Window和WindowManager"><a href="#1理解Window和WindowManager" class="headerlink" title="1理解Window和WindowManager"></a>1理解Window和WindowManager</h2><ul><li><p>1.Window用于显示View和接收各种事件，Window有三种类型：应用Window(每个Activity对应一个Window)、子Window(不能单独存在，附属于特定Window)、系统window(Toast和状态栏)</p></li><li><p>2.Window分层级，应用Window在1-99、子Window在1000-1999、系统Window在2000-2999.WindowManager提供了增删改View三个功能。</p></li><li><p>3.Window是个抽象概念：每一个Window对应着一个View和ViewRootImpl，Window通过ViewRootImpl来和View建立联系，View是Window存在的实体，只能通过WindowManager来访问Window。</p></li><li><p>4.WindowManager的实现是WindowManagerImpl其再委托给WindowManagerGlobal来对Window进行操作，其中有四个List分别储存对应的View、ViewRootImpl、WindowManger.LayoutParams和正在被删除的View</p></li><li><p>5.Window的实体是存在于远端的WindowMangerService中，所以增删改Window在本端是修改上面的几个List然后通过ViewRootImpl重绘View，通过WindowSession(每个应用一个)在远端修改Window。</p></li><li><p>6.Activity创建Window：Activity会在attach()中创建Window并设置其回调(onAttachedToWindow()、dispatchTouchEvent()),Activity的Window是由Policy类创建PhoneWindow实现的。然后通过Activity#setContentView()调用PhoneWindow的setContentView。</p></li></ul><h2 id="2Bitmap的处理"><a href="#2Bitmap的处理" class="headerlink" title="2Bitmap的处理"></a>2Bitmap的处理</h2><ul><li><p>1.当使用ImageView的时候，可能图片的像素大于ImageView，此时就可以通过BitmapFactory.Option来对图片进行压缩，inSampleSize表示缩小2^(inSampleSize-1)倍。</p></li><li><p>2.BitMap的缓存：</p><ul><li><p>1.使用LruCache进行内存缓存。</p><ul><li><p>2.使用DiskLruCache进行硬盘缓存。</p></li><li><p>3.实现一个ImageLoader的流程：同步异步加载、图片压缩、内存硬盘缓存、网络拉取</p><ul><li><p>1.同步加载只创建一个线程然后按照顺序进行图片加载</p><ul><li><p>2.异步加载使用线程池，让存在的加载任务都处于不同线程</p></li><li><p>3.为了不开启过多的异步任务，只在列表静止的时候开启图片加载</p></li></ul></li></ul></li></ul></li></ul></li></ul><h2 id="2如何实现一个网络框架-参考Volley"><a href="#2如何实现一个网络框架-参考Volley" class="headerlink" title="2如何实现一个网络框架(参考Volley)"></a>2如何实现一个网络框架(参考Volley)</h2><ul><li><p>1.缓存队列,以url为key缓存内容可以参考Bitmap的处理方式，这里单独开启一个线程。</p></li><li><p>2.网络请求队列，使用线程池进行请求。</p></li><li><p>3.提供各种不同类型的返回值的解析如String，Json，图片等等。</p></li></ul><h2 id="2ClassLoader的基础知识"><a href="#2ClassLoader的基础知识" class="headerlink" title="2ClassLoader的基础知识"></a>2ClassLoader的基础知识</h2><ul><li><p>1.双亲委托：一个ClassLoader类负责加载这个类所涉及的所有类，在加载的时候会判断该类是否已经被加载过，然后会递归去他父ClassLoader中找。</p></li><li><p>2.可以动态加载Jar通过URLClassLoader</p></li><li><p>3.ClassLoader 隔离问题 JVM识别一个类是由：ClassLoader id+PackageName+ClassName。</p></li><li><p>4.加载不同Jar包中的公共类：</p><ul><li><p>1.让父ClassLoader加载公共的Jar，子ClassLoader加载包含公共Jar的Jar，此时子ClassLoader在加载公共Jar的时候会先去父ClassLoader中找。(只适用Java)</p><ul><li><p>2.重写加载包含公共Jar的Jar的ClassLoader，在loadClass中找到已经加载过公共Jar的ClassLoader，也就是把父ClassLoader替换掉。(只适用Java)</p></li><li><p>3.在生成包含公共Jar的Jar时候把公共Jar去掉。</p></li></ul></li></ul></li></ul><h2 id="2插件化框架描述：dynamicLoadApk为例子"><a href="#2插件化框架描述：dynamicLoadApk为例子" class="headerlink" title="2插件化框架描述：dynamicLoadApk为例子"></a>2插件化框架描述：dynamicLoadApk为例子</h2><ul><li><p>1.可以通过DexClassLoader来对apk中的dex包进行加载访问</p></li><li><p>2.如何加载资源是个很大的问题，因为宿主程序中并没有apk中的资源，所以调用R资源会报错，所以这里使用了Activity中的实现ContextImpl的getAssets()和getResources()再加上反射来实现。</p></li><li><p>3.由于系统启动Activity有很多初始化动作要做，而我们手动反射很难完成，所以可以采用接口机制，将Activity的大部分生命周期提取成接口，然后通过代理Activity去调用插件Activity的生命周期。同时如果像增加一个新生命周期方法的时候，只需要在接口中和代理中声明一下就行。</p></li><li><p>4.缺点：</p><ul><li><p>1.慎用this，因为在apk中使用this并不代表宿主中的activity，当然如果this只是表示自己的接口还是可以的。除此之外可以使用that代替this。</p><ul><li><p>2.不支持Service和静态注册的Broadcast</p></li><li><p>3.不支持LaunchMode和Apk中Activity的隐式调用。</p></li></ul></li></ul></li></ul><h2 id="2热修复：Andfix为例子"><a href="#2热修复：Andfix为例子" class="headerlink" title="2热修复：Andfix为例子"></a>2热修复：Andfix为例子</h2><ul><li><p>1.大致原理：apkpatch将两个apk做一次对比，然后找出不同的部分。可以看到生成的apatch了文件，后缀改成zip再解压开，里面有一个dex文件。通过jadx查看一下源码，里面就是被修复的代码所在的类文件,这些更改过的类都加上了一个_CF的后缀，并且变动的方法都被加上了一个叫@MethodReplace的annotation，通过clazz和method指定了需要替换的方法。然后客户端sdk得到补丁文件后就会根据annotation来寻找需要替换的方法。最后由JNI层完成方法的替换。</p></li><li><p>2.无法添加新类和新的字段、补丁文件很容易被反编译、加固平台可能会使热补丁功能失效</p></li></ul><h2 id="2线程同步的问题，常用的线程同步"><a href="#2线程同步的问题，常用的线程同步" class="headerlink" title="2线程同步的问题，常用的线程同步"></a>2线程同步的问题，常用的线程同步</h2><ul><li><p>1.sycn：保证了原子性、可见性、有序性</p></li><li><p>2.锁：保证了原子性、可见性、有序性</p><ul><li><p>1.自旋锁:可以使线程在没有取得锁的时候，不被挂起，而转去执行一个空循环。</p><div class="hljs"><pre><code>*   1.优点:线程被挂起的几率减少，线程执行的连贯性加强。用于对于锁竞争不是很激烈，锁占用时间很短的并发线程。    *   2.缺点:过多浪费CPU时间，有一个线程连续两次试图获得自旋锁引起死锁</code></pre></div></li><li><p>2.阻塞锁:没得到锁的线程等待或者挂起，Sycn、Lock</p><ul><li><p>3.可重入锁:一个线程可多次获取该锁，Sycn、Lock</p></li><li><p>4.悲观锁:每次去拿数据的时候都认为别人会修改，所以会阻塞全部其他线程 Sycn、Lock</p></li><li><p>5.乐观锁:每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。cas</p></li><li><p>6.显示锁和内置锁:显示锁用Lock来定义、内置锁用synchronized。</p></li><li><p>7.读-写锁:为了提高性能，Java提供了读</p></li></ul></li></ul></li><li><p>3.volatile</p><ul><li><p>1.只能保证可见性，不能保证原子性</p><ul><li>2.自增操作有三步，此时多线程写会出现问题</li></ul></li></ul></li><li><p>4.cas</p><ul><li><p>1.操作:内存值V、旧的预期值A、要修改的值B，当且仅当预期值A和内存值V相同时，将内存值修改为B并返回true，否则什么都不做并返回false。</p><ul><li><p>2.解释:本地副本为A，共享内存为V，线程A要把V修改成B。某个时刻线程A要把V修改成B，如果A和V不同那么就表示有其他线程在修改V，此时就表示修改失败，否则表示没有其他线程修改，那么把V改成B。</p></li><li><p>3.局限:如果V被修改成V1然后又被改成V，此时cas识别不出变化，还是认为没有其他线程在修改V，此时就会有问题</p></li><li><p>4.局限解决:将V带上版本。</p></li></ul></li></ul></li><li><p>5.线程不安全到底是怎么回事：</p><ul><li><p>1.一个线程写，多个线程读的时候，会造成写了一半就去读</p><ul><li>2.多线程写，会造成脏数据</li></ul></li></ul></li></ul><h2 id="2Asynctask和线程池，GC相关（怎么判断哪些内存该GC，GC算法）"><a href="#2Asynctask和线程池，GC相关（怎么判断哪些内存该GC，GC算法）" class="headerlink" title="2Asynctask和线程池，GC相关（怎么判断哪些内存该GC，GC算法）"></a>2Asynctask和线程池，GC相关（怎么判断哪些内存该GC，GC算法）</h2><ul><li><p>1.Asynctask：异步任务类，单线程线程池+Handler</p></li><li><p>2.线程池：</p><ul><li><p>1.ThreadPoolExecutor：通过Executors可以构造单线程池、固定数目线程池、不固定数目线程池。</p><ul><li>2.ScheduledThreadPoolExecutor：可以延时调用线程或者延时重复调度线程。</li></ul></li></ul></li><li><p>3.GC相关：重要</p><ul><li><p>1.搜索算法：</p><div class="hljs"><pre><code>*   1.引用计数    *   2.图搜索，可达性分析</code></pre></div></li><li><p>2.回收算法：</p><div class="hljs"><pre><code>*   1.标记清除复制：用于青年代    *   2.标记整理：用于老年代</code></pre></div></li><li><p>3.堆分区：</p><div class="hljs"><pre><code>*   1.青年区eden 80%、survivor1 10%、survivor2 10%    *   2.老年区</code></pre></div></li><li><p>4.虚拟机栈分区：</p><div class="hljs"><pre><code>*   1.局部变量表    *   2.操作数栈    *   3.动态链接    *   4.方法返回地址</code></pre></div></li><li><p>5.GC Roots:</p><div class="hljs"><pre><code>*   1.虚拟机栈(栈桢中的本地变量表)中的引用的对象    *   2.方法区中的类静态属性引用的对象    *   3.方法区中的常量引用的对象    *   4.本地方法栈中JNI的引用的对象</code></pre></div></li></ul></li></ul><h2 id="2网络"><a href="#2网络" class="headerlink" title="2网络"></a>2网络</h2><ul><li><p>1.ARP协议:在IP以太网中，当一个上层协议要发包时，有了该节点的IP地址，ARP就能提供该节点的MAC地址。</p></li><li><p>2.HTTP HTTPS的区别:</p><ul><li><p>1.HTTPS使用TLS(SSL)进行加密</p><ul><li><p>2.HTTPS缺省工作在TCP协议443端口</p></li><li><p>3.它的工作流程一般如以下方式:</p><ul><li><p>1.完成TCP三次同步握手</p><ul><li><p>2.客户端验证服务器数字证书，通过，进入步骤3</p></li><li><p>3.DH算法协商对称加密算法的密钥、hash算法的密钥</p></li><li><p>4.SSL安全加密隧道协商完成</p></li><li><p>5.网页以加密的方式传输，用协商的对称加密算法和密钥加密，保证数据机密性；用协商的hash算法进行数据完整性保护，保证数据不被篡改</p></li></ul></li></ul></li></ul></li><li><p>3.http请求包结构，http返回码的分类，400和500的区别</p><div class="hljs"><pre><code>*   1.包结构：        *   1.请求：请求行、头部、数据            *   2.返回：状态行、头部、数据</code></pre></div><ul><li>2.http返回码分类：1到5分别是，消息、成功、重定向、客户端错误、服务端错误</li></ul></li><li><p>4.Tcp</p><div class="hljs"><pre><code>*   1.可靠连接，三次握手，四次挥手        *   1.三次握手：防止了服务器端的一直等待而浪费资源，例如只是两次握手，如果s确认之后c就掉线了，那么s就会浪费资源                *   1.syn-c = x，表示这消息是x序号                    *   2.ack-s = x + 1，表示syn-c这个消息接收成功。syn-s = y，表示这消息是y序号。                    *   3.ack-c = y + 1，表示syn-s这条消息接收成功</code></pre></div><ul><li><p>2.四次挥手：TCP是全双工模式</p><div class="hljs"><pre><code>*   1.fin-c = x , 表示现在需要关闭c到s了。ack-c = y,表示上一条s的消息已经接收完毕    *   2.ack-s = x + 1，表示需要关闭的fin-c消息已经接收到了，同意关闭    *   3.fin-s = y + 1，表示s已经准备好关闭了，就等c的最后一条命令    *   4.ack-c = y + 1，表示c已经关闭，让s也关闭</code></pre></div></li><li><p>3.滑动窗口，停止等待、后退N、选择重传</p><div class="hljs"><pre><code>*   4.拥塞控制，慢启动、拥塞避免、加速递减、快重传快恢复</code></pre></div></li></ul></li></ul></li></ul><h2 id="2数据库性能优化：索引和事务，需要找本专门的书大概了解一下"><a href="#2数据库性能优化：索引和事务，需要找本专门的书大概了解一下" class="headerlink" title="2数据库性能优化：索引和事务，需要找本专门的书大概了解一下"></a>2数据库性能优化：索引和事务，需要找本专门的书大概了解一下</h2><h2 id="213-APK打包流程和其内容"><a href="#213-APK打包流程和其内容" class="headerlink" title="213.APK打包流程和其内容"></a>213.APK打包流程和其内容</h2><ul><li><p>1.流程</p><ul><li><p>1.aapt生成R文件</p><div class="hljs"><pre><code>*   2.aidl生成java文件    *   3.将全部java文件编译成class文件    *   4.将全部class文件和第三方包合并成dex文件    *   5.将资源、so文件、dex文件整合成apk    *   6.apk签名    *   7.apk字节对齐</code></pre></div></li></ul></li><li><p>2.内容：so、dex、asset、资源文件</p></li></ul><h2 id="3网络劫持的类型原理：可以百度一下了解一下具体概念"><a href="#3网络劫持的类型原理：可以百度一下了解一下具体概念" class="headerlink" title="3网络劫持的类型原理：可以百度一下了解一下具体概念"></a>3网络劫持的类型原理：可以百度一下了解一下具体概念</h2><ul><li><p>1.DNS劫持、欺骗、污染</p></li><li><p>2.http劫持：重定向、注入js，http注入、报文扩展</p></li></ul><h2 id="3java类加载过程："><a href="#3java类加载过程：" class="headerlink" title="3java类加载过程："></a>3java类加载过程：</h2><ul><li><p>1.加载时机：创建实例、访问静态变量或方法、反射、加载子类之前</p></li><li><p>2.验证：验证文件格式、元数据、字节码、符号引用的正确性</p></li><li><p>3.加载：根据全类名获取文件字节流、将字节流转化为静态储存结构放入方法区、生成class对象</p></li><li><p>4.准备：在堆上为静态变量划分内存</p></li><li><p>5.解析：将常量池中的符号引用转换为直接引用</p></li><li><p>6.初始化：初始化静态变量</p></li><li><p>7.书籍推荐：<strong>深入理解java虚拟机</strong>，博客推荐：<a href="https://www.jianshu.com/p/bc6d1770d92c" target="_blank" rel="noopener">Java/Android阿里面试JVM部分理解</a></p></li></ul><h2 id="3retrofit的了解"><a href="#3retrofit的了解" class="headerlink" title="3retrofit的了解"></a>3retrofit的了解</h2><ul><li><p>1.动态代理创建一个接口的代理类</p></li><li><p>2.通过反射解析每个接口的注解、入参构造http请求</p></li><li><p>3.获取到返回的http请求，使用Adapter解析成需要的返回值。</p></li></ul><h2 id="3bundle的数据结构，如何存储"><a href="#3bundle的数据结构，如何存储" class="headerlink" title="3bundle的数据结构，如何存储"></a>3bundle的数据结构，如何存储</h2><ul><li><p>1.键值对储存</p></li><li><p>2.传递的数据可以是boolean、byte、int、long、float、double、string等基本类型或它们对应的数组，也可以是对象或对象数组。</p></li><li><p>3.当Bundle传递的是对象或对象数组时，必须实现Serializable 或Parcelable接口</p></li></ul><h2 id="3listview内点击buttom并移动的事件流完整拦截过程："><a href="#3listview内点击buttom并移动的事件流完整拦截过程：" class="headerlink" title="3listview内点击buttom并移动的事件流完整拦截过程："></a>3listview内点击buttom并移动的事件流完整拦截过程：</h2><ul><li><p>1.点下按钮的时候：</p><ul><li><p>1.产生了一个down事件，activity–&gt;phoneWindow–&gt;ViewGroup–&gt;ListView–&gt;botton,中间如果有重写了拦截方法，则事件被该view拦截可能消耗。</p><ul><li><p>2.没拦截，事件到达了button，这个过程中建立了一条事件传递的view链表</p></li><li><p>3.到button的dispatch方法–&gt;onTouch–&gt;view是否可用–&gt;Touch代理</p></li></ul></li></ul></li><li><p>2.移动点击按钮的时候:</p><ul><li><p>1.产生move事件，listView中会对move事件做拦截</p><ul><li><p>2.此时listView会将该滑动事件消费掉</p></li><li><p>3.后续的滑动事件都会被listView消费掉</p></li></ul></li></ul></li><li><p>3.手指抬起来时候：前面建立了一个view链表，listView的父view在获取事件的时候，会直接取链表中的listView让其进行事件消耗。</p></li></ul><h2 id="3service的意义：不需要界面，在后台执行的程序"><a href="#3service的意义：不需要界面，在后台执行的程序" class="headerlink" title="3service的意义：不需要界面，在后台执行的程序"></a>3service的意义：不需要界面，在后台执行的程序</h2><h2 id="3android的IPC通信方式，线程（进程间）通信机制有哪些"><a href="#3android的IPC通信方式，线程（进程间）通信机制有哪些" class="headerlink" title="3android的IPC通信方式，线程（进程间）通信机制有哪些"></a>3android的IPC通信方式，线程（进程间）通信机制有哪些</h2><ul><li><p>1.ipc通信方式：binder、contentprovider、socket</p></li><li><p>2.操作系统进程通讯方式：共享内存、socket、管道</p></li></ul><h2 id="3操作系统进程和线程的区别"><a href="#3操作系统进程和线程的区别" class="headerlink" title="3操作系统进程和线程的区别"></a>3操作系统进程和线程的区别</h2><ul><li><p>1.简而言之,一个程序至少有一个进程,一个进程至少有一个线程.</p></li><li><p>2.线程的划分尺度小于进程，使得多线程程序的并发性高。</p></li><li><p>3.另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。</p></li><li><p>4.多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配</p></li></ul><h2 id="3HashMap的实现过程：Capacity就是buckets的数目，Load-factor就是buckets填满程度的最大比例。如果对迭代性能要求很高的话不要把capacity设置过大，也不要把load-factor设置过小。"><a href="#3HashMap的实现过程：Capacity就是buckets的数目，Load-factor就是buckets填满程度的最大比例。如果对迭代性能要求很高的话不要把capacity设置过大，也不要把load-factor设置过小。" class="headerlink" title="3HashMap的实现过程：Capacity就是buckets的数目，Load factor就是buckets填满程度的最大比例。如果对迭代性能要求很高的话不要把capacity设置过大，也不要把load factor设置过小。"></a>3HashMap的实现过程：Capacity就是buckets的数目，Load factor就是buckets填满程度的最大比例。如果对迭代性能要求很高的话不要把capacity设置过大，也不要把load factor设置过小。</h2><ul><li><p>1.简单来说HashMap就是一个会自动扩容的<strong>数组链表</strong></p></li><li><p>2.put过程</p><ul><li><p>1.对key的hashCode()做hash，然后再计算index;</p><ul><li><p>2.如果没碰撞直接放到bucket里；</p></li><li><p>3.如果碰撞了，以链表的形式存在buckets后；</p></li><li><p>4.如果碰撞导致链表过长(大于等于TREEIFY_THRESHOLD)，就把链表转换成红黑树；</p></li><li><p>5.如果节点已经存在就替换old value(保证key的唯一性)</p></li><li><p>6.如果bucket满了(超过load factor*current capacity)，就要resize。</p></li></ul></li></ul></li><li><p>3.resize：当put时，如果发现目前的bucket占用程度已经超过了Load Factor所希望的比例，那么就会发生resize。在resize的过程，简单的说就是把bucket扩充为2倍，之后重新计算index，把节点再放到新的bucket中</p></li><li><p>4.get过程</p><ul><li><p>1.根据key的hash算出数组下表</p><ul><li>2.使用equals遍历链表进行比较</li></ul></li></ul></li></ul><h2 id="3mvc、mvp、mvvm："><a href="#3mvc、mvp、mvvm：" class="headerlink" title="3mvc、mvp、mvvm："></a>3mvc、mvp、mvvm：</h2><ul><li><p>1.mvc:数据、View、Activity，View将操作反馈给Activity，Activitiy去获取数据，数据通过观察者模式刷新给View。循环依赖</p><ul><li><p>1.Activity重，很难单元测试</p><ul><li>2.View和Model耦合严重</li></ul></li></ul></li><li><p>2.mvp:数据、View、Presenter，View将操作给Presenter，Presenter去获取数据，数据获取好了返回给Presenter，Presenter去刷新View。PV，PM双向依赖</p><ul><li><p>1.接口爆炸</p><ul><li>2.Presenter很重</li></ul></li></ul></li><li><p>3.mvvm:数据、View、ViewModel，View将操作给ViewModel，ViewModel去获取数据，数据和界面绑定了，数据更新界面更新。</p><ul><li><p>1.viewModel的业务逻辑可以单独拿来测试</p><ul><li><p>2.一个view 对应一个 viewModel 业务逻辑可以分离，不会出现全能类</p></li><li><p>3.数据和界面绑定了，不用写垃圾代码，但是复用起来不舒服</p></li></ul></li></ul></li></ul><h2 id="4java的线程如何实现"><a href="#4java的线程如何实现" class="headerlink" title="4java的线程如何实现"></a>4java的线程如何实现</h2><ul><li><p>1.Thread继承</p></li><li><p>2.Runnale</p></li><li><p>3.Future</p></li><li><p>4.线程池</p></li></ul><h2 id="4ArrayList-如何删除重复的元素或者指定的元素；"><a href="#4ArrayList-如何删除重复的元素或者指定的元素；" class="headerlink" title="4ArrayList 如何删除重复的元素或者指定的元素；"></a>4ArrayList 如何删除重复的元素或者指定的元素；</h2><ul><li><p>1.删除重复：Set</p></li><li><p>2.删除指定：迭代器</p></li></ul><h2 id="4如何设计在-UDP-上层保证-UDP-的可靠性传输；"><a href="#4如何设计在-UDP-上层保证-UDP-的可靠性传输；" class="headerlink" title="4如何设计在 UDP 上层保证 UDP 的可靠性传输；"></a>4如何设计在 UDP 上层保证 UDP 的可靠性传输；</h2><ul><li><p>1.简单来讲，要使用UDP来构建可靠的面向连接的数据传输，就要实现类似于TCP协议的超时重传，有序接受，应答确认，滑动窗口流量控制等机制,等于说要在传输层的上一层（或者直接在应用层）实现TCP协议的可靠数据传输机制。</p></li><li><p>2.比如使用UDP数据包+序列号，UDP数据包+时间戳等方法，在服务器端进行应答确认机制，这样就会保证不可靠的UDP协议进行可靠的数据传输。</p></li><li><p>3.基于udp的可靠传输协议有：RUDP、RTP、UDT</p></li></ul><h2 id="4Java-中内部类为什么可以访问外部类"><a href="#4Java-中内部类为什么可以访问外部类" class="headerlink" title="4Java 中内部类为什么可以访问外部类"></a>4Java 中内部类为什么可以访问外部类</h2><ul><li>1.因为内部类创建的时候，需要外部类的对象，在内部类对象创建的时候会把外部类的引用传递进去</li></ul><h2 id="4设计移动端的联系人存储与查询的功能，要求快速搜索联系人，可以用到哪些数据结构？数据库索引，平衡二叉树-B树、红黑树"><a href="#4设计移动端的联系人存储与查询的功能，要求快速搜索联系人，可以用到哪些数据结构？数据库索引，平衡二叉树-B树、红黑树" class="headerlink" title="4设计移动端的联系人存储与查询的功能，要求快速搜索联系人，可以用到哪些数据结构？数据库索引，平衡二叉树(B树、红黑树)"></a>4设计移动端的联系人存储与查询的功能，要求快速搜索联系人，可以用到哪些数据结构？数据库索引，平衡二叉树(B树、红黑树)</h2><h2 id="4红黑树特点"><a href="#4红黑树特点" class="headerlink" title="4红黑树特点"></a>4红黑树特点</h2><ul><li><p>1.root节点和叶子节点是黑色</p></li><li><p>2.红色节点后必须为黑色节点</p></li><li><p>3.从root到叶子每条路径的黑节点数量相同</p></li></ul><h2 id="4linux异步和同步i-o"><a href="#4linux异步和同步i-o" class="headerlink" title="4linux异步和同步i/o:"></a>4linux异步和同步i/o:</h2><ul><li><p>1.同步：对于client，client一直等待，但是client不挂起：主线程调用</p></li><li><p>2.异步：对于client，client发起请求，service好了再回调client：其他线程调用，调用完成之后进行回调</p></li><li><p>3.阻塞：对于service，在准备io的时候会将service端挂起，直至准备完成然后唤醒service：bio</p></li><li><p>3.非阻塞：对于service，在准备io的时候不会将service端挂起，而是service一直去轮询判断io是否准备完成，准备完成了就进行操作：nio、linux的select、poll、epoll</p></li><li><p>4.多路复用io：非阻塞io的一种优化，java nio，用一个线程去轮询多个 io端口是否可用，如果一个可用就通知对应的io请求，这使用一个线程轮询可以大大增强性能。</p><ul><li><p>1.我可以采用 多线程+ 阻塞IO 达到类似的效果，但是由于在多线程 + 阻塞IO 中，每个socket对应一个线程，这样会造成很大的资源占用。</p><ul><li>2.而在多路复用IO中，轮询每个socket状态是内核在进行的，这个效率要比用户线程要高的多。</li></ul></li></ul></li><li><p>5.异步io：aio，用户线程完全不感知io的进行，所有操作都交给内核，io完成之后内核通知用户线程。</p><ul><li><p>1.这种io才是异步的，2、3、4都是同步io，因为内核进行数据拷贝的过程都会让用户线程阻塞。</p><ul><li>2.异步IO是需要操作系统的底层支持，也就是内核支持，Java 7中，提供了Asynchronous IO</li></ul></li></ul></li></ul><h2 id="4ConcurrentHashMap内部实现，HashTable的实现被废弃的原因"><a href="#4ConcurrentHashMap内部实现，HashTable的实现被废弃的原因" class="headerlink" title="4ConcurrentHashMap内部实现，HashTable的实现被废弃的原因:"></a>4ConcurrentHashMap内部实现，HashTable的实现被废弃的原因:</h2><ul><li><p>1.HashTable容器在竞争激烈的并发环境下表现出效率低下的原因，是因为所有访问HashTable的线程都必须竞争同一把锁，那假如容器里有多把锁，每一把锁用于锁容器其中一部分数据，那么当多线程访问容器里不同数据段的数据时，线程间就不会存在锁竞争，从而可以有效的提高并发访问效率，这就是ConcurrentHashMap所使用的锁分段技术，首先将数据分成一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问。</p></li><li><p>2.ConcurrentHashMap是由Segment数组结构和HashEntry数组结构组成。Segment是一种可重入锁ReentrantLock，在ConcurrentHashMap里扮演锁的角色，HashEntry则用于存储键值对数据。一个ConcurrentHashMap里包含一个Segment数组，Segment的结构和HashMap类似，是一种数组和链表结构， 一个Segment里包含一个HashEntry数组，每个HashEntry是一个链表结构的元素，每个Segment守护者一个HashEntry数组里的元素,当对HashEntry数组的数据进行修改时，必须首先获得它对应的Segment锁。</p></li></ul><h2 id="4HandlerThread是什么"><a href="#4HandlerThread是什么" class="headerlink" title="4HandlerThread是什么"></a>4HandlerThread是什么</h2><ul><li>1.MessageQueue + Looper + Handler</li></ul><h2 id="4IntentService是什么"><a href="#4IntentService是什么" class="headerlink" title="4IntentService是什么"></a>4IntentService是什么</h2><ul><li>1.含有HandlerThread的Service，可以多次startService()来多次在子线程中进行 onHandlerIntent()的调用。</li></ul><h2 id="5class和dex"><a href="#5class和dex" class="headerlink" title="5class和dex"></a>5class和dex</h2><ul><li><p>1.dvm执行的是dex格式文件，jvm执行的是class文件，android程序编译完之后生产class文件。然后dex工具会把class文件处理成dex文件，然后把资源文件和.dex文件等打包成apk文件。</p></li><li><p>2.dvm是基于寄存器的虚拟机，而jvm执行是基于虚拟栈的虚拟机。寄存器存取速度比栈快的多，dvm可以根据硬件实现最大的优化，比较适合移动设备。</p></li><li><p>3.class文件存在很多的冗余信息，dex工具会去除冗余信息，并把所有的class文件整合到dex文件中。减少了I/O操作，提高了类的查找速度</p></li></ul><h2 id="5内存泄漏"><a href="#5内存泄漏" class="headerlink" title="5内存泄漏"></a>5内存泄漏</h2><ul><li><p>1.其他线程持有一个Listener，Listener操作activity。那么在线程么有完毕的时候，activity关闭了，原本是要被回收的但是，不能被回收。</p></li><li><p>2.例如Handler导致的内存泄漏，Handler就相当于Listener。</p></li><li><p>3.在activity关闭的时候注意停止线程，或者将Listener的注册取消</p></li><li><p>3.使用弱引用，这样即使Listener持有了activity，在GC的时候还是会被回收</p></li><li><p>4.工具:LeakCanary</p></li></ul><h2 id="5过度绘制、卡顿优化"><a href="#5过度绘制、卡顿优化" class="headerlink" title="5过度绘制、卡顿优化:"></a>5过度绘制、卡顿优化:</h2><ul><li><p>1.过度绘制：</p><ul><li><p>1.移除Window默认的Background：getWidow.setBackgroundDrawable(null);</p><ul><li><p>2.移除XML布局文件中非必需的Background</p></li><li><p>3.减少布局嵌套(扁平化的一个体现，减少View数的深度，也就减少了View树的遍历时间，渲染的时候，前后期的工作，总是按View树结点来)</p></li><li><p>4.在引入布局文件里面，最外层可以用merge替代LinearLayout,RelativeLayout，这样把子UI元素直接衔接在include位置</p></li><li><p>5.工具：HierarchyViewer 查看视图层级</p></li></ul></li></ul></li><li><p>2.卡顿优化：16ms数据更新</p></li></ul><h2 id="5apk瘦身"><a href="#5apk瘦身" class="headerlink" title="5apk瘦身:"></a>5apk瘦身:</h2><ul><li><p>1.classes.dex：通过代码混淆，删掉不必要的jar包和代码实现该文件的优化</p></li><li><p>2.资源文件：通过Lint工具扫描代码中没有使用到的静态资源</p></li><li><p>3.图片资源：使用tinypng和webP，下面详细介绍图片资源优化的方案,矢量图</p></li><li><p>4.SO文件将不用的去掉，目前主流app一般只放一个arm的so包</p></li></ul><h2 id="5ANR的形成，各个组件上出现ARN的时间限制是多少"><a href="#5ANR的形成，各个组件上出现ARN的时间限制是多少" class="headerlink" title="5ANR的形成，各个组件上出现ARN的时间限制是多少"></a>5ANR的形成，各个组件上出现ARN的时间限制是多少</h2><ul><li><p>1.只要是主线程耗时的操作就会ARN  如io</p></li><li><p>2.broadcast超时时间为10秒  按键无响应的超时时间为5秒 前台service无响应的超时时间为20秒，后台service为200秒</p></li></ul><h2 id="5Serializable和Parcelable-的区别"><a href="#5Serializable和Parcelable-的区别" class="headerlink" title="5Serializable和Parcelable 的区别"></a>5Serializable和Parcelable 的区别</h2><ul><li><p>1.P 消耗内存小</p></li><li><p>2.网络传输用S  程序内使用P</p></li><li><p>3.S将数据持久化方便</p></li><li><p>4.S使用了反射 容易触发垃圾回收 比较慢</p></li></ul><h2 id="5Sharedpreferences源码简述"><a href="#5Sharedpreferences源码简述" class="headerlink" title="5Sharedpreferences源码简述"></a>5Sharedpreferences源码简述</h2><ul><li><p>1.储存于硬盘上的xml键值对，数据多了会有性能问题</p></li><li><p>2.ContextImpl记录着SharedPreferences的重要数据，文件路径和实例的键值对</p></li><li><p>3.在xml文件全部内加载到内存中之前，读取操作是阻塞的，在xml文件全部内加载到内存中之后，是直接读取内存中的数据</p></li><li><p>4.apply因为是异步的没有返回值, commit是同步的有返回值能知道修改是否提交成功</p></li><li><p>5.多并发的提交commit时，需等待正在处理的commit数据更新到磁盘文件后才会继续往下执行，从而降低效率; 而apply只是原子更新到内存，后调用apply函数会直接覆盖前面内存数据，从一定程度上提高很多效率。 3.edit()每次都是创建新的EditorImpl对象.</p></li><li><p>6.博客推荐：<strong><a href="https://www.jianshu.com/p/102f25cf64e3" target="_blank" rel="noopener">全面剖析SharedPreferences</a></strong></p></li></ul><h2 id="5操作系统如何管理内存的："><a href="#5操作系统如何管理内存的：" class="headerlink" title="5操作系统如何管理内存的："></a>5操作系统如何管理内存的：</h2><ul><li><p>1.使用寄存器进行将进程地址和物理内存进行映射</p></li><li><p>2.虚拟内存进行内存映射到硬盘上增大内存</p></li><li><p>3.虚拟内存是进行内存分页管理</p></li><li><p>4.页表实现分页，就是 页+地址偏移。</p></li><li><p>5.如果程序的内存在硬盘上，那么就需要用页置换算法来将其调入内存中：先进先出、最近未使用最少等等</p></li><li><p>6.博客推荐：<strong><a href="https://www.jianshu.com/p/aecff59430fa" target="_blank" rel="noopener">现代操作系统部分章节笔记</a></strong></p></li></ul><h2 id="5浏览器输入地址到返回结果发生了什么"><a href="#5浏览器输入地址到返回结果发生了什么" class="headerlink" title="5浏览器输入地址到返回结果发生了什么"></a>5浏览器输入地址到返回结果发生了什么</h2><ul><li><p>1.DNS解析</p></li><li><p>2.TCP连接</p></li><li><p>3.发送HTTP请求</p></li><li><p>4.服务器处理请求并返回HTTP报文</p></li><li><p>5.浏览器解析渲染页面</p></li><li><p>6.连接结束</p></li></ul><h2 id="5java泛型类型擦除发生在什么时候，通配符有什么需要注意的。"><a href="#5java泛型类型擦除发生在什么时候，通配符有什么需要注意的。" class="headerlink" title="5java泛型类型擦除发生在什么时候，通配符有什么需要注意的。"></a>5java泛型类型擦除发生在什么时候，通配符有什么需要注意的。</h2><ul><li><p>1.发生在编译的时候</p></li><li><p>2.PECS，extends善于提供精确的对象 A是B的子集，Super善于插入精确的对象 A是B的超集</p></li><li><p>3.博客推荐：<strong><a href="https://www.jianshu.com/p/4e4751b5bbbb" target="_blank" rel="noopener">Effective Java笔记（不含反序列化、并发、注解和枚举）</a></strong>、<strong><a href="https://www.jianshu.com/p/6006a3284f55" target="_blank" rel="noopener">android阿里面试java基础锦集</a></strong></p></li></ul><h2 id="6activity的生命周期"><a href="#6activity的生命周期" class="headerlink" title="6activity的生命周期"></a>6activity的生命周期</h2><ul><li><p>1.a启动b，后退键再到a的生命周期流程：a.create–&gt;a.start–&gt;a.resume–&gt;a.pause–&gt;b.create–&gt;b.start–&gt;b.resume–&gt;b界面绘制–&gt;a.stop–&gt;b.pause–&gt;b.stop–&gt;b.destroy–&gt;a.restart–&gt;a.start–&gt;a.resume</p></li><li><p>2.意外销毁会调用saveInstance，重新恢复的时候回调用restoreInstance。储存数据的时候使用了委托机制，从activity–&gt;window–&gt;viewGroup–&gt;view 会递归调用save来保持本view的数据，restore则是递归恢复本view数据。我们可以在里面做一些自己需要的数据操作。</p></li></ul><h2 id="6面试常考的算法"><a href="#6面试常考的算法" class="headerlink" title="6面试常考的算法"></a>6面试常考的算法</h2><ul><li><p>1.快排、堆排序为首的各种排序算法</p></li><li><p>2.链表的各种操作：判断成环、判断相交、合并链表、倒数K个节点、寻找成环节点</p></li><li><p>3.二叉树、红黑树、B树定义以及时间复杂度计算方式</p></li><li><p>4.动态规划、贪心算法、简单的图论</p></li><li><p>5.推荐书籍：<strong>算法导论</strong>，将图论之前的例子写一遍</p></li></ul><h2 id="6Launcher进程启动另外一个进程的过程：启动一个app"><a href="#6Launcher进程启动另外一个进程的过程：启动一个app" class="headerlink" title="6Launcher进程启动另外一个进程的过程：启动一个app"></a>6Launcher进程启动另外一个进程的过程：<a href="http://www.cnblogs.com/tiantianbyconan/p/5017056.html" target="_blank" rel="noopener">启动一个app</a></h2><h2 id="6开源框架源码"><a href="#6开源框架源码" class="headerlink" title="6开源框架源码"></a>6开源框架源码</h2><h3 id="1-Fresco"><a href="#1-Fresco" class="headerlink" title="1.Fresco"></a>1.Fresco</h3><h4 id="1-mvc框架："><a href="#1-mvc框架：" class="headerlink" title="1.mvc框架："></a>1.mvc框架：</h4><ul><li><p>1.Controller控制数据显示在Hierarchy中的Drawable的显隐</p></li><li><p>2.ImagePipeline在Controller中负责进行数据获取，返回的数据是CloseableImage</p></li><li><p>3.Drawee把除了初始化之外的操作全部交给Holder去做，Holder持有Controller和Hierarchy</p></li></ul><h4 id="2-Drawable层次以及绘制："><a href="#2-Drawable层次以及绘制：" class="headerlink" title="2.Drawable层次以及绘制："></a>2.Drawable层次以及绘制：</h4><ul><li><p>1.如果要绘制一次Drawable就调用invalidateSelf()来触发onDraw()</p></li><li><p>2.Drawable分为：容器类(保存一些Drawable)、自我绘制类(进度条)、图形变换类(scale、rotate、矩阵变换)、动画类(内部不断刷新，进行webp和gif的帧绘制)</p></li><li><p>3.ImagePipeline返回的CloseableImage是由一个个DrawableFactory解析成Drawable的</p></li><li><p>4.webp和gif动画是由jni代码解析的，然后其他静态图片是根据不同的android平台使用BitmapFactory来解析的</p></li></ul><h4 id="3-职责链模式"><a href="#3-职责链模式" class="headerlink" title="3.职责链模式"></a>3.职责链模式</h4><p>producer不做操作标n，表示只是提供一个consumer。获取图片–》解码图片缓存Producer–》后台线程Producer–》client图片处理producer(n)–》解码producer(n)–》旋转或剪裁producer(n)–》编码图片内存缓存producer–》读硬盘缓存producer–》写硬盘缓存producer(n)–》网络producer提供CloseableImage《–解码图片缓存consumer《–client图片处理consumer《–解码consumer《–旋转或剪裁consumer《–编码图片内存缓存consumer《–写硬盘缓存consumer《–图片数据</p><h4 id="4-内存缓存"><a href="#4-内存缓存" class="headerlink" title="4.内存缓存"></a>4.内存缓存</h4><ul><li><p>1.一个CountingLruMap保存已经没有被引用的缓存条目，一个CountingLruMap保存所有的条目包括没有引用的条目。每当缓存策略改变和一定时间缓存配置的更新的时候，就会将 待销毁条目Map中的条目一个个移除，直到缓存大小符合配置。</p></li><li><p>2.这里的引用计数是用Fresco组件实现的引用计数器。</p></li><li><p>3.缓存有一个代理类，用来追踪缓存的存取。</p></li><li><p>4.CountingLruMap是使用LinkedHashMap来储存数据的。</p></li></ul><h4 id="5-硬盘缓存"><a href="#5-硬盘缓存" class="headerlink" title="5.硬盘缓存"></a>5.硬盘缓存</h4><ul><li><p>1.DefaultDiskStorage使用Lru策略。</p></li><li><p>2.为了不让所有的文件集中在一个文件中，创建很多命名不同的文件夹，然后使用hash算法把缓存文件分散</p></li><li><p>3.DiskStorageCache封装了DefaultDiskStorage，不仅进行缓存存取追踪，并且其在内存里面维持着一个 &lt;key,value&gt; 的键值对，因为文件修改频繁，所有只是定时刷新，因此如果在内存中找不到，还要去硬盘中找一次。</p></li><li><p>4.删除硬盘的缓存只出现在硬盘数据大小超限的时候，此时同时也会删除缓存中的key，所以不会出现内存中有key，但是硬盘上没有的情况。</p></li><li><p>5.在插入硬盘数据的时候，采用的是插入器的形式。返回一个Inserter，在Inserter.writeData()中传入一个CallBack(里面封装了客户端插入数据的逻辑和文件引用)，让内部实现调用CallBack的逻辑来插入文件数据，前面写的文件后缀是.temp,只有调用commit()之后才会修改后缀，让文件对客户端可见。</p></li><li><p>6.使用了java提供的FileTreeVisitor来遍历文件</p></li></ul><h4 id="6-对象池"><a href="#6-对象池" class="headerlink" title="6.对象池"></a>6.对象池</h4><ul><li><p>1.使用数组来存储一个桶，桶内部是一个Queue。数组下标是数据申请内存的byte大小，桶内部的Queue存的是内存块的。所以数组使用的是稀疏数组</p></li><li><p>2.申请内存的方式有两种 1.java堆上开辟的内存 2.ashme 的本地内存中开辟的内存</p></li></ul><h4 id="7-设计模式"><a href="#7-设计模式" class="headerlink" title="7.设计模式"></a>7.设计模式</h4><p>Builder、职责链、观察者、代理、组合、享元、适配器、装饰者、策略、生产者消费者、提供者</p><h4 id="8-自定义计数引用：类似c-智能指针"><a href="#8-自定义计数引用：类似c-智能指针" class="headerlink" title="8.自定义计数引用：类似c++智能指针"></a>8.自定义计数引用：类似c++智能指针</h4><ul><li><p>1.使用一个静态IdentityHashMap &lt;储存需要被计数引用的对象,其被引用的次数&gt;</p></li><li><p>2.用SharedReference分装需要被计数引用的对象，提供一个销毁资源的销毁器，提供一个静态工厂方法来复制自己，复制一个引用计数加一。提供一个方法销毁自己，表示自己需要变成无人引用的对象了，此时引用计数减一。</p></li><li><p>3.引用计数归零，销毁器将销毁资源，如bitmap的recycle或者是jni内存调用jni方法归还内存。</p></li></ul><h4 id="9-博客推荐"><a href="#9-博客推荐" class="headerlink" title="9.博客推荐"></a>9.博客推荐</h4><p><strong><a href="https://www.jianshu.com/p/dbe01f9994d0" target="_blank" rel="noopener">Android Fresco源码文档翻译</a></strong><br><strong><a href="https://www.jianshu.com/p/ab2124764438" target="_blank" rel="noopener">从零开始撸一个Fresco之硬盘缓存</a></strong><br><strong><a href="https://www.jianshu.com/p/36663090b140" target="_blank" rel="noopener">从零开始撸一个Fresco之gif和Webp动画</a></strong><br><strong><a href="https://www.jianshu.com/p/ba0de15ce667" target="_blank" rel="noopener">从零开始撸一个Fresco之内存缓存</a></strong><br><strong><a href="https://www.jianshu.com/p/2dff47ae7666" target="_blank" rel="noopener">从零开始撸一个Fresco之总结</a></strong></p><h3 id="2-oKhttp："><a href="#2-oKhttp：" class="headerlink" title="2.oKhttp："></a>2.oKhttp：</h3><h4 id="1-同步和异步："><a href="#1-同步和异步：" class="headerlink" title="1.同步和异步："></a>1.同步和异步：</h4><ul><li><p>1.异步使用了Dispatcher来将存储在 Deque 中的请求分派给线程池中各个线程执行。</p></li><li><p>2.当任务执行完成后，无论是否有异常，finally代码段总会被执行，也就是会调用Dispatcher的finished函数，它将正在运行的任务Call从队列runningAsyncCalls中移除后，主动的把缓存队列向前走了一步。</p></li></ul><h4 id="2-连接池："><a href="#2-连接池：" class="headerlink" title="2.连接池："></a>2.连接池：</h4><ul><li><p>1.一个Connection封装了一个socket，ConnectionPool中储存s着所有的Connection，StreamAllocation是引用计数的一个单位</p></li><li><p>2.当一个请求获取一个Connection的时候要传入一个StreamAllocation，Connection中存着一个弱引用的StreamAllocation列表，每当上层应用引用一次Connection，StreamAllocation就会加一个。反之如果上层应用不使用了，就会删除一个。</p></li><li><p>3.ConnectionPool中会有一个后台任务定时清理StreamAllocation列表为空的Connection。5分钟时间，维持5个socket</p></li></ul><h4 id="3-选择路线与建立连接"><a href="#3-选择路线与建立连接" class="headerlink" title="3.选择路线与建立连接"></a>3.选择路线与建立连接</h4><ul><li><p>1.选择路线有两种方式：</p><ol><li>无代理，那么在本地使用DNS查找到ip，注意结果是数组，即一个域名有多个IP，这就是自动重连的来源</li><li>有代理HTTP：设置socket的ip为代理地址的ip，设置socket的端口为代理地址的端口</li><li>代理好处：HTTP代理会帮你在远程服务器进行DNS查询，可以减少DNS劫持。</li></ol></li></ul><h4 id="2-建立连接"><a href="#2-建立连接" class="headerlink" title="2.建立连接"></a>2.建立连接</h4><ul><li>1.连接池中已经存在连接，就从中取出(get)RealConnection，如果没有命中就进入下一步</li><li>2.根据选择的路线(Route)，调用Platform.get().connectSocket选择当前平台Runtime下最好的socket库进行握手</li><li>3.将建立成功的RealConnection放入(put)连接池缓存</li><li>4.如果存在TLS，就根据SSL版本与证书进行安全握手</li><li>5.构造HttpStream并维护刚刚的socket连接，管道建立完成</li></ul><h4 id="4-职责链模式"><a href="#4-职责链模式" class="headerlink" title="4.职责链模式"></a>4.职责链模式</h4><p>缓存、重试、建立连接等功能存在于拦截器中网络请求相关，主要是网络请求优化。网络请求的时候遇到的问题</p><h4 id="5-博客推荐"><a href="#5-博客推荐" class="headerlink" title="5.博客推荐"></a>5.博客推荐</h4><p><strong><a href="https://www.jianshu.com/p/60e5ebf0096a" target="_blank" rel="noopener">Android数据层架构的实现 上篇</a></strong><br><strong><a href="https://www.jianshu.com/p/5def7b42d223" target="_blank" rel="noopener">Android数据层架构的实现 下篇</a></strong></p><h3 id="3-okio"><a href="#3-okio" class="headerlink" title="3.okio"></a>3.okio</h3><h4 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h4><ul><li><p>1.sink：自己–》别人</p></li><li><p>2.source：别人–》自己</p></li><li><p>3.BufferSink：有缓存区域的sink</p></li><li><p>4.BufferSource：有缓存区域的source</p></li><li><p>5.Buffer：实现了3、4的缓存区域，内部有Segment的双向链表，在在转移数据的时候，只需要将指针转移指向就行</p></li></ul><h4 id="2-比java-io的好处："><a href="#2-比java-io的好处：" class="headerlink" title="2.比java io的好处："></a>2.比java io的好处：</h4><ul><li><p>1.减少内存申请和数据拷贝</p></li><li><p>2.类少，功能齐全，开发效率高</p></li></ul><h4 id="3-内部实现："><a href="#3-内部实现：" class="headerlink" title="3.内部实现："></a>3.内部实现：</h4><ul><li><p>1.Buffer的Segment双向链表，减少数据拷贝</p></li><li><p>2.Segment的内部byte数组的共享，减少数据拷贝</p></li><li><p>3.SegmentPool的共享和回收Segment</p></li><li><p>4.sink和source中被实际操作的其实是Buffer，Buffer可以充当sink和source</p></li><li><p>5.最终okio只是对java io的封装，所有操作都是基于java io 的&gt;</p></li></ul><p>写在最后:能看到这里的人,我挺佩服你的.这篇文章是我在<strong>头条</strong>面试之前整理的,最后<strong>80%</strong>的题目都命中了,所以祝你好运.</p>]]></content>
    
    
    
    <tags>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2018鸿洋博客总结</title>
    <link href="/2018/02/11/2018%E9%B8%BF%E6%B4%8B%E5%8D%9A%E5%AE%A2%E6%80%BB%E7%BB%93/"/>
    <url>/2018/02/11/2018%E9%B8%BF%E6%B4%8B%E5%8D%9A%E5%AE%A2%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p>微信号: hongyangAndroid</p><a id="more"></a><h2 id="面试相关"><a href="#面试相关" class="headerlink" title="面试相关"></a>面试相关</h2><p><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650824986&amp;idx=1&amp;sn=4aa18659de1c761e73e87805f1dfc88a&amp;chksm=80b7b584b7c03c926e547ed16d0675f3d625af236736b7e814d21600d40993ac6b41f10a1850&amp;scene=21#wechat_redirect" target="_blank" style="white-space: normal;">从一道面试题开始说起</a></p><p><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650824986&amp;idx=1&amp;sn=4aa18659de1c761e73e87805f1dfc88a&amp;chksm=80b7b584b7c03c926e547ed16d0675f3d625af236736b7e814d21600d40993ac6b41f10a1850&amp;scene=21#wechat_redirect" target="_blank" style="white-space: normal;"></a><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650824578&amp;idx=1&amp;sn=627d4789f1f17c0b8eb40efe993f048d&amp;chksm=80b78b1cb7c0020aab3a09502d1c22b48ce394aa06505f9dbc202c8f9cda07f3a12343710322&amp;scene=21#wechat_redirect" target="_blank" style="white-space: normal;">超详细Android面试的准备与经历分享 | 百度(offer)</a></p><p><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650824986&amp;idx=1&amp;sn=4aa18659de1c761e73e87805f1dfc88a&amp;chksm=80b7b584b7c03c926e547ed16d0675f3d625af236736b7e814d21600d40993ac6b41f10a1850&amp;scene=21#wechat_redirect" target="_blank" style="white-space: normal;"></a><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650824578&amp;idx=1&amp;sn=627d4789f1f17c0b8eb40efe993f048d&amp;chksm=80b78b1cb7c0020aab3a09502d1c22b48ce394aa06505f9dbc202c8f9cda07f3a12343710322&amp;scene=21#wechat_redirect" target="_blank" style="white-space: normal;"></a><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650824517&amp;idx=1&amp;sn=4336cd916cf069aad01606aad0fce6ef&amp;chksm=80b78bdbb7c002cdcd3adcf7aa493e0d4f1c594bc6806ba91e68fa55244c819c21ddc72fd87f&amp;scene=21#wechat_redirect" target="_blank" style="white-space: normal;">我的 Android 面试故事 | 13家面试记录</a></p><p><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650824986&amp;idx=1&amp;sn=4aa18659de1c761e73e87805f1dfc88a&amp;chksm=80b7b584b7c03c926e547ed16d0675f3d625af236736b7e814d21600d40993ac6b41f10a1850&amp;scene=21#wechat_redirect" target="_blank" style="white-space: normal;"></a><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650824578&amp;idx=1&amp;sn=627d4789f1f17c0b8eb40efe993f048d&amp;chksm=80b78b1cb7c0020aab3a09502d1c22b48ce394aa06505f9dbc202c8f9cda07f3a12343710322&amp;scene=21#wechat_redirect" target="_blank" style="white-space: normal;"></a><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650824517&amp;idx=1&amp;sn=4336cd916cf069aad01606aad0fce6ef&amp;chksm=80b78bdbb7c002cdcd3adcf7aa493e0d4f1c594bc6806ba91e68fa55244c819c21ddc72fd87f&amp;scene=21#wechat_redirect" target="_blank" style="white-space: normal;">我的2017总结的笔记</a></p><p><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650824517&amp;idx=1&amp;sn=4336cd916cf069aad01606aad0fce6ef&amp;chksm=80b78bdbb7c002cdcd3adcf7aa493e0d4f1c594bc6806ba91e68fa55244c819c21ddc72fd87f&amp;scene=21#wechat_redirect" target="_blank" style="white-space: normal;"><span style="color: rgb(96, 127, 166);"></span></a><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650824295&amp;idx=1&amp;sn=593dcb3f03c5afbec3d616dbf7afa930&amp;chksm=80b78af9b7c003ef872cdaa87e18891acdf62fd247e929b9715cbfea937ceb15600d77c136b1&amp;scene=21#wechat_redirect" target="_blank" style="white-space: normal;">2017 Android秋招面试总结 &amp;&amp; 面试资源推荐</a></p><p><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650824517&amp;idx=1&amp;sn=4336cd916cf069aad01606aad0fce6ef&amp;chksm=80b78bdbb7c002cdcd3adcf7aa493e0d4f1c594bc6806ba91e68fa55244c819c21ddc72fd87f&amp;scene=21#wechat_redirect" target="_blank" style="white-space: normal;"><span style="color: rgb(96, 127, 166);"></span></a><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650824295&amp;idx=1&amp;sn=593dcb3f03c5afbec3d616dbf7afa930&amp;chksm=80b78af9b7c003ef872cdaa87e18891acdf62fd247e929b9715cbfea937ceb15600d77c136b1&amp;scene=21#wechat_redirect" target="_blank" style="white-space: normal;"></a><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650824286&amp;idx=1&amp;sn=6263c302b508b14c23ac8a256291404a&amp;chksm=80b78ac0b7c003d6cf199e63781ab45b4e3a43555f9a81cbdcd019e473073151d762e6a70966&amp;scene=21#wechat_redirect" target="_blank" style="white-space: normal;">Android 茫茫9个月求职路 已拿满意offer</a></p><p><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650824286&amp;idx=1&amp;sn=6263c302b508b14c23ac8a256291404a&amp;chksm=80b78ac0b7c003d6cf199e63781ab45b4e3a43555f9a81cbdcd019e473073151d762e6a70966&amp;scene=21#wechat_redirect" target="_blank" style="white-space: normal;"></a><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650823839&amp;idx=1&amp;sn=0d4c8e50a4887c10ad1795873ed469bc&amp;chksm=80b78801b7c00117bd405f523457e220ad3201ce0633c41c028ba60fecb8824b705b4a74c9cc&amp;scene=21#wechat_redirect" target="_blank" style="white-space: normal;">Android工程师之Android面试大纲</a></p><p><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650823839&amp;idx=1&amp;sn=0d4c8e50a4887c10ad1795873ed469bc&amp;chksm=80b78801b7c00117bd405f523457e220ad3201ce0633c41c028ba60fecb8824b705b4a74c9cc&amp;scene=21#wechat_redirect" target="_blank" style="white-space: normal;"></a><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650822790&amp;idx=1&amp;sn=801199ba18f6c14cf82d5d8b01621270&amp;chksm=80b78c18b7c0050eacc29c74905998317a97526cd000b19d16be448abbafc095fda8f58e0623&amp;scene=21#wechat_redirect" target="_blank" style="white-space: normal;">（已拿offer）腾讯/百度/今日头条/美团2017Android开发实习生面经</a></p><h2 id="多媒体"><a href="#多媒体" class="headerlink" title="多媒体"></a>多媒体</h2><p><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650823616&amp;idx=1&amp;sn=7abd0fbb0de443110001e716c4dcd4f9&amp;chksm=80b78f5eb7c006486de7cfae258ecaef304dc767737156b4c13ed2b6d9fe057a045e3d08eca5&amp;scene=21#wechat_redirect" target="_blank">Android Camera2 使用总结</a></p><p><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650824442&amp;idx=1&amp;sn=0f539be1620a2b7c27004ede7c988c1c&amp;chksm=80b78a64b7c0037275d40a6aa52a4061f6247fbea9cdb3f58db59d484fe35671eda1e415c67e&amp;scene=21#wechat_redirect" target="_blank">Android 拍照自动识别手机号 | OCR</a></p><p><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650824442&amp;idx=1&amp;sn=0f539be1620a2b7c27004ede7c988c1c&amp;chksm=80b78a64b7c0037275d40a6aa52a4061f6247fbea9cdb3f58db59d484fe35671eda1e415c67e&amp;scene=21#wechat_redirect" target="_blank"></a><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650823227&amp;idx=1&amp;sn=e511fbdb5584461d238cf50735f29d3d&amp;chksm=80b78ea5b7c007b3c1d647004ec1a283b4a0ba360a3e581f8c5cb99158292e637f5c3515db2d&amp;scene=21#wechat_redirect" target="_blank">Android视频开发进阶（一）关于视频的那些术语</a></p><p><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650824442&amp;idx=1&amp;sn=0f539be1620a2b7c27004ede7c988c1c&amp;chksm=80b78a64b7c0037275d40a6aa52a4061f6247fbea9cdb3f58db59d484fe35671eda1e415c67e&amp;scene=21#wechat_redirect" target="_blank"></a><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650823227&amp;idx=1&amp;sn=e511fbdb5584461d238cf50735f29d3d&amp;chksm=80b78ea5b7c007b3c1d647004ec1a283b4a0ba360a3e581f8c5cb99158292e637f5c3515db2d&amp;scene=21#wechat_redirect" target="_blank"></a><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650823279&amp;idx=1&amp;sn=ab73c7f4e13bde34d951cb7a928ad321&amp;chksm=80b78ef1b7c007e7385d086d4cc125332f25d5904a85eece608b9e513d6c4d2a33edc1e74e21&amp;scene=21#wechat_redirect" target="_blank">Android视频开发进阶（二）MP4文件的解析</a></p><p><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650824442&amp;idx=1&amp;sn=0f539be1620a2b7c27004ede7c988c1c&amp;chksm=80b78a64b7c0037275d40a6aa52a4061f6247fbea9cdb3f58db59d484fe35671eda1e415c67e&amp;scene=21#wechat_redirect" target="_blank"></a><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650823227&amp;idx=1&amp;sn=e511fbdb5584461d238cf50735f29d3d&amp;chksm=80b78ea5b7c007b3c1d647004ec1a283b4a0ba360a3e581f8c5cb99158292e637f5c3515db2d&amp;scene=21#wechat_redirect" target="_blank"></a><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650823279&amp;idx=1&amp;sn=ab73c7f4e13bde34d951cb7a928ad321&amp;chksm=80b78ef1b7c007e7385d086d4cc125332f25d5904a85eece608b9e513d6c4d2a33edc1e74e21&amp;scene=21#wechat_redirect" target="_blank"></a><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650823173&amp;idx=1&amp;sn=8f8ec3570654bcfc2ef3ab7392e5387a&amp;chksm=80b78e9bb7c0078d65481072375b06811357c5e6202d0b87f1b23c2fe7f3b8237a5e2f534e17&amp;scene=21#wechat_redirect" target="_blank">用MediaPlayer+TextureView封装一个完美实现全屏、小窗口的视频播放器</a></p><p><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650824442&amp;idx=1&amp;sn=0f539be1620a2b7c27004ede7c988c1c&amp;chksm=80b78a64b7c0037275d40a6aa52a4061f6247fbea9cdb3f58db59d484fe35671eda1e415c67e&amp;scene=21#wechat_redirect" target="_blank"></a><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650823227&amp;idx=1&amp;sn=e511fbdb5584461d238cf50735f29d3d&amp;chksm=80b78ea5b7c007b3c1d647004ec1a283b4a0ba360a3e581f8c5cb99158292e637f5c3515db2d&amp;scene=21#wechat_redirect" target="_blank"></a><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650823279&amp;idx=1&amp;sn=ab73c7f4e13bde34d951cb7a928ad321&amp;chksm=80b78ef1b7c007e7385d086d4cc125332f25d5904a85eece608b9e513d6c4d2a33edc1e74e21&amp;scene=21#wechat_redirect" target="_blank"></a><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650823173&amp;idx=1&amp;sn=8f8ec3570654bcfc2ef3ab7392e5387a&amp;chksm=80b78e9bb7c0078d65481072375b06811357c5e6202d0b87f1b23c2fe7f3b8237a5e2f534e17&amp;scene=21#wechat_redirect" target="_blank"></a><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650823019&amp;idx=1&amp;sn=cae918090d68b034b873dec4be3fe8bb&amp;chksm=80b78df5b7c004e3fb83704cdfea974366c6c0bf2f87f5ac42fa2c174ab1d5357ab333ec5aa2&amp;scene=21#wechat_redirect" target="_blank">Android 仿火萤视频桌面 神奇的LiveWallPaper</a></p><p><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650824442&amp;idx=1&amp;sn=0f539be1620a2b7c27004ede7c988c1c&amp;chksm=80b78a64b7c0037275d40a6aa52a4061f6247fbea9cdb3f58db59d484fe35671eda1e415c67e&amp;scene=21#wechat_redirect" target="_blank"></a><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650823227&amp;idx=1&amp;sn=e511fbdb5584461d238cf50735f29d3d&amp;chksm=80b78ea5b7c007b3c1d647004ec1a283b4a0ba360a3e581f8c5cb99158292e637f5c3515db2d&amp;scene=21#wechat_redirect" target="_blank"></a><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650823279&amp;idx=1&amp;sn=ab73c7f4e13bde34d951cb7a928ad321&amp;chksm=80b78ef1b7c007e7385d086d4cc125332f25d5904a85eece608b9e513d6c4d2a33edc1e74e21&amp;scene=21#wechat_redirect" target="_blank"></a><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650823173&amp;idx=1&amp;sn=8f8ec3570654bcfc2ef3ab7392e5387a&amp;chksm=80b78e9bb7c0078d65481072375b06811357c5e6202d0b87f1b23c2fe7f3b8237a5e2f534e17&amp;scene=21#wechat_redirect" target="_blank"></a><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650823019&amp;idx=1&amp;sn=cae918090d68b034b873dec4be3fe8bb&amp;chksm=80b78df5b7c004e3fb83704cdfea974366c6c0bf2f87f5ac42fa2c174ab1d5357ab333ec5aa2&amp;scene=21#wechat_redirect" target="_blank"></a><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650822900&amp;idx=1&amp;sn=395ed65490fdaa11d98380c0fdec5378&amp;chksm=80b78c6ab7c0057ce63f353ddf80d7c25f43e1c598b37f4700469f97bcd879089bf1faa6e0fc&amp;scene=21#wechat_redirect" target="_blank">Android 实现"透明屏幕"</a></p><p><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650824442&amp;idx=1&amp;sn=0f539be1620a2b7c27004ede7c988c1c&amp;chksm=80b78a64b7c0037275d40a6aa52a4061f6247fbea9cdb3f58db59d484fe35671eda1e415c67e&amp;scene=21#wechat_redirect" target="_blank"></a><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650823227&amp;idx=1&amp;sn=e511fbdb5584461d238cf50735f29d3d&amp;chksm=80b78ea5b7c007b3c1d647004ec1a283b4a0ba360a3e581f8c5cb99158292e637f5c3515db2d&amp;scene=21#wechat_redirect" target="_blank"></a><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650823279&amp;idx=1&amp;sn=ab73c7f4e13bde34d951cb7a928ad321&amp;chksm=80b78ef1b7c007e7385d086d4cc125332f25d5904a85eece608b9e513d6c4d2a33edc1e74e21&amp;scene=21#wechat_redirect" target="_blank"></a><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650823173&amp;idx=1&amp;sn=8f8ec3570654bcfc2ef3ab7392e5387a&amp;chksm=80b78e9bb7c0078d65481072375b06811357c5e6202d0b87f1b23c2fe7f3b8237a5e2f534e17&amp;scene=21#wechat_redirect" target="_blank"></a><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650823019&amp;idx=1&amp;sn=cae918090d68b034b873dec4be3fe8bb&amp;chksm=80b78df5b7c004e3fb83704cdfea974366c6c0bf2f87f5ac42fa2c174ab1d5357ab333ec5aa2&amp;scene=21#wechat_redirect" target="_blank"></a><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650822900&amp;idx=1&amp;sn=395ed65490fdaa11d98380c0fdec5378&amp;chksm=80b78c6ab7c0057ce63f353ddf80d7c25f43e1c598b37f4700469f97bcd879089bf1faa6e0fc&amp;scene=21#wechat_redirect" target="_blank"></a><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650822596&amp;idx=1&amp;sn=80972db3e075aa9fb3e22a6dc16645fd&amp;chksm=80b7835ab7c00a4c805550fa13d57ac0562d1d2ec45e2d12d3b9c7b7f87ab3cebe9e4a2c4b91&amp;scene=21#wechat_redirect" target="_blank">Android语音识别之模糊匹配 特定需求的语音识别优化</a><br  /></p><h2 id="实战功能"><a href="#实战功能" class="headerlink" title="实战功能"></a>实战功能</h2><p><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650824809&amp;idx=1&amp;sn=b259de58bf43156bc3a2a505344a602b&amp;chksm=80b7b4f7b7c03de12bca2d2bfbb7ceefbe77c2e3732c7256be85563bd3dbf2dd8cd83b78792a&amp;scene=21#wechat_redirect" target="_blank">实战版本更新(okhttp3、service、notification)</a></p><p><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650824801&amp;idx=1&amp;sn=7dc9f9fcfe7c64f179d3e5d563f43b80&amp;chksm=80b7b4ffb7c03de9e557cfac6507e2642553ebce74448720af650dcf3883d933a2909b0615f9&amp;scene=21#wechat_redirect" target="_blank">滚动截屏，RecyclerView截屏，ScrollView截屏，ListView截屏</a></p><p><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650824801&amp;idx=1&amp;sn=7dc9f9fcfe7c64f179d3e5d563f43b80&amp;chksm=80b7b4ffb7c03de9e557cfac6507e2642553ebce74448720af650dcf3883d933a2909b0615f9&amp;scene=21#wechat_redirect" target="_blank"></a><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650824608&amp;idx=1&amp;sn=d9e6bf92824b83d871f0c9ee90a1399a&amp;chksm=80b78b3eb7c00228463e418beac0c7b06b331e404fff9d1a9b0d5fd4e11e8e80f16c34d21b31&amp;scene=21#wechat_redirect" target="_blank">有关Android应用桌面角标(BadgeNumber)实现的探讨</a></p><p><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650824801&amp;idx=1&amp;sn=7dc9f9fcfe7c64f179d3e5d563f43b80&amp;chksm=80b7b4ffb7c03de9e557cfac6507e2642553ebce74448720af650dcf3883d933a2909b0615f9&amp;scene=21#wechat_redirect" target="_blank"></a><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650824608&amp;idx=1&amp;sn=d9e6bf92824b83d871f0c9ee90a1399a&amp;chksm=80b78b3eb7c00228463e418beac0c7b06b331e404fff9d1a9b0d5fd4e11e8e80f16c34d21b31&amp;scene=21#wechat_redirect" target="_blank"></a><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650824589&amp;idx=1&amp;sn=78cd339b8cb3bc9a0694b09318ea0d53&amp;chksm=80b78b13b7c00205753d4e1ed9b0f07e321cd90efa4f44b1332fb9b8aeacef330709a7fe9fd9&amp;scene=21#wechat_redirect" target="_blank">Android 应用内悬浮控件实践总结</a></p><p><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650824589&amp;idx=1&amp;sn=78cd339b8cb3bc9a0694b09318ea0d53&amp;chksm=80b78b13b7c00205753d4e1ed9b0f07e321cd90efa4f44b1332fb9b8aeacef330709a7fe9fd9&amp;scene=21#wechat_redirect" target="_blank"></a><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650824442&amp;idx=1&amp;sn=0f539be1620a2b7c27004ede7c988c1c&amp;chksm=80b78a64b7c0037275d40a6aa52a4061f6247fbea9cdb3f58db59d484fe35671eda1e415c67e&amp;scene=21#wechat_redirect" target="_blank">探讨Android6.0及以上系统APP保活实现</a></p><p><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650824589&amp;idx=1&amp;sn=78cd339b8cb3bc9a0694b09318ea0d53&amp;chksm=80b78b13b7c00205753d4e1ed9b0f07e321cd90efa4f44b1332fb9b8aeacef330709a7fe9fd9&amp;scene=21#wechat_redirect" target="_blank"></a><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650824442&amp;idx=1&amp;sn=0f539be1620a2b7c27004ede7c988c1c&amp;chksm=80b78a64b7c0037275d40a6aa52a4061f6247fbea9cdb3f58db59d484fe35671eda1e415c67e&amp;scene=21#wechat_redirect" target="_blank"></a><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650824332&amp;idx=1&amp;sn=41f7085a302da7cc5cd2801c2fdbed54&amp;chksm=80b78a12b7c0030449290e0e538f8483a433084ed663c306010c6ec786f4dd67139a550d9c8a&amp;scene=21#wechat_redirect" target="_blank">可能是目前最精准的Android开源计步器</a></p><p><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650824589&amp;idx=1&amp;sn=78cd339b8cb3bc9a0694b09318ea0d53&amp;chksm=80b78b13b7c00205753d4e1ed9b0f07e321cd90efa4f44b1332fb9b8aeacef330709a7fe9fd9&amp;scene=21#wechat_redirect" target="_blank"></a><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650824442&amp;idx=1&amp;sn=0f539be1620a2b7c27004ede7c988c1c&amp;chksm=80b78a64b7c0037275d40a6aa52a4061f6247fbea9cdb3f58db59d484fe35671eda1e415c67e&amp;scene=21#wechat_redirect" target="_blank"></a><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650824332&amp;idx=1&amp;sn=41f7085a302da7cc5cd2801c2fdbed54&amp;chksm=80b78a12b7c0030449290e0e538f8483a433084ed663c306010c6ec786f4dd67139a550d9c8a&amp;scene=21#wechat_redirect" target="_blank"></a><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650824214&amp;idx=1&amp;sn=d34242daf162f3d4a086bbeb7b5b5716&amp;chksm=80b78a88b7c0039e4c41bf69830a170773b095b6c608ae54da78fd603d990f792500cbc51f6a&amp;scene=21#wechat_redirect" target="_blank">优雅的处理加载中(loading)、重试(retry)和无数据(empty)</a></p><p><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650824589&amp;idx=1&amp;sn=78cd339b8cb3bc9a0694b09318ea0d53&amp;chksm=80b78b13b7c00205753d4e1ed9b0f07e321cd90efa4f44b1332fb9b8aeacef330709a7fe9fd9&amp;scene=21#wechat_redirect" target="_blank"></a><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650824442&amp;idx=1&amp;sn=0f539be1620a2b7c27004ede7c988c1c&amp;chksm=80b78a64b7c0037275d40a6aa52a4061f6247fbea9cdb3f58db59d484fe35671eda1e415c67e&amp;scene=21#wechat_redirect" target="_blank"></a><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650824332&amp;idx=1&amp;sn=41f7085a302da7cc5cd2801c2fdbed54&amp;chksm=80b78a12b7c0030449290e0e538f8483a433084ed663c306010c6ec786f4dd67139a550d9c8a&amp;scene=21#wechat_redirect" target="_blank"></a><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650824214&amp;idx=1&amp;sn=d34242daf162f3d4a086bbeb7b5b5716&amp;chksm=80b78a88b7c0039e4c41bf69830a170773b095b6c608ae54da78fd603d990f792500cbc51f6a&amp;scene=21#wechat_redirect" target="_blank"></a><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650824147&amp;idx=1&amp;sn=1bd0b14bd1b62b3680c9c4bd92632bb6&amp;chksm=80b7894db7c0005b5b493ea08b184bb449d287c6572026baebac12a1e227dd2d44b3e162a077&amp;scene=21#wechat_redirect" target="_blank">一步步搞定Android换肤框架 从Debug 7.1.1源码开始</a></p><p><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650824147&amp;idx=1&amp;sn=1bd0b14bd1b62b3680c9c4bd92632bb6&amp;chksm=80b7894db7c0005b5b493ea08b184bb449d287c6572026baebac12a1e227dd2d44b3e162a077&amp;scene=21#wechat_redirect" target="_blank"></a><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650824049&amp;idx=1&amp;sn=ca25c9d32850b71b04f144e63b87e915&amp;chksm=80b789efb7c000f96078df7d69fa09806b4e3cebe9356b032f0179780e8edd0741a46558554d&amp;scene=21#wechat_redirect" target="_blank">将一个网站撸成App很简单,实战无接口写安卓巴士博客App端</a></p><p><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650824147&amp;idx=1&amp;sn=1bd0b14bd1b62b3680c9c4bd92632bb6&amp;chksm=80b7894db7c0005b5b493ea08b184bb449d287c6572026baebac12a1e227dd2d44b3e162a077&amp;scene=21#wechat_redirect" target="_blank"></a><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650824049&amp;idx=1&amp;sn=ca25c9d32850b71b04f144e63b87e915&amp;chksm=80b789efb7c000f96078df7d69fa09806b4e3cebe9356b032f0179780e8edd0741a46558554d&amp;scene=21#wechat_redirect" target="_blank"></a><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650824038&amp;idx=1&amp;sn=8fbc707c644c92d23c31ab5b314bc280&amp;chksm=80b789f8b7c000ee0fa8d5d81b5f44e3ab874358d653e30726ab735182c443ae35a7921ded27&amp;scene=21#wechat_redirect" target="_blank">轻松入门直播相关技术 带你从0搭建直播系统</a></p><p><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650824038&amp;idx=1&amp;sn=8fbc707c644c92d23c31ab5b314bc280&amp;chksm=80b789f8b7c000ee0fa8d5d81b5f44e3ab874358d653e30726ab735182c443ae35a7921ded27&amp;scene=21#wechat_redirect" target="_blank"></a><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650824003&amp;idx=1&amp;sn=76fbbd0d1e924714e52345df2f1ea7d0&amp;chksm=80b789ddb7c000cbb62742877937254cce5341e82bd8412635804090f2b6fe17e875c72f4728&amp;scene=21#wechat_redirect" target="_blank">基于开源项目搭建属于自己的技术堆栈</a></p><p><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650824003&amp;idx=1&amp;sn=76fbbd0d1e924714e52345df2f1ea7d0&amp;chksm=80b789ddb7c000cbb62742877937254cce5341e82bd8412635804090f2b6fe17e875c72f4728&amp;scene=21#wechat_redirect" target="_blank"></a><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650823751&amp;idx=1&amp;sn=ba705113f4b1083622df9762ccfbaea6&amp;chksm=80b788d9b7c001cfb65195b405bac1632af0bbc275b9b8e4b60f0f051d81e9717046dd2cc378&amp;scene=21#wechat_redirect" target="_blank">Android实现APP在线下载更新</a></p><p><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650823616&amp;idx=1&amp;sn=7abd0fbb0de443110001e716c4dcd4f9&amp;chksm=80b78f5eb7c006486de7cfae258ecaef304dc767737156b4c13ed2b6d9fe057a045e3d08eca5&amp;scene=21#wechat_redirect" target="_blank">实现传言中的黑科技——“1像素页面保活”</a></p><p><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650823616&amp;idx=1&amp;sn=7abd0fbb0de443110001e716c4dcd4f9&amp;chksm=80b78f5eb7c006486de7cfae258ecaef304dc767737156b4c13ed2b6d9fe057a045e3d08eca5&amp;scene=21#wechat_redirect" target="_blank"></a><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650823231&amp;idx=1&amp;sn=650093dfbdb04da12f2595f3f54676a9&amp;chksm=80b78ea1b7c007b7dd5a628dc324b6150a801b7209c9cbf3900e7f5930471f3b5177c3761195&amp;scene=21#wechat_redirect" target="_blank">Android 7.0 行为变更 通过FileProvider在应用间共享文件吧</a></p><p><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650823616&amp;idx=1&amp;sn=7abd0fbb0de443110001e716c4dcd4f9&amp;chksm=80b78f5eb7c006486de7cfae258ecaef304dc767737156b4c13ed2b6d9fe057a045e3d08eca5&amp;scene=21#wechat_redirect" target="_blank"></a><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650823231&amp;idx=1&amp;sn=650093dfbdb04da12f2595f3f54676a9&amp;chksm=80b78ea1b7c007b7dd5a628dc324b6150a801b7209c9cbf3900e7f5930471f3b5177c3761195&amp;scene=21#wechat_redirect" target="_blank"></a><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650822142&amp;idx=1&amp;sn=72d28a19eb26c51c6b8c4073e2671904&amp;chksm=80b78160b7c00876e3c17914767e758130306440a8b0e3e5791ed58a90e4e9b6d084d50a5d8f&amp;scene=21#wechat_redirect" target="_blank">Android 两行代码实现换肤 从appcompat-v7原理出发</a><br  /></p><h2 id="Gradle"><a href="#Gradle" class="headerlink" title="Gradle"></a>Gradle</h2><p><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650824805&amp;idx=1&amp;sn=d3102e022334b60305d42c2da317384d&amp;chksm=80b7b4fbb7c03ded87b2d366a3cab88752292ae850c94e52b16f343fc32ff9fedf541767136f&amp;scene=21#wechat_redirect" target="_blank">教你如何一套源码编译多个APP，不同的签名，包名，界面，字段...</a></p><p><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650824805&amp;idx=1&amp;sn=d3102e022334b60305d42c2da317384d&amp;chksm=80b7b4fbb7c03ded87b2d366a3cab88752292ae850c94e52b16f343fc32ff9fedf541767136f&amp;scene=21#wechat_redirect" target="_blank"></a><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650823843&amp;idx=1&amp;sn=b37cdf30f2e1938b0ac88cf4fc1eb331&amp;chksm=80b7883db7c0012bfd66cefc3669f25d3ebda8b840b592d7c7d439d0e730061735ecdebf0de6&amp;scene=21#wechat_redirect" target="_blank">Android 必备而又容易忽视的知识 &nbsp;Gradle的高级用法</a></p><p><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650823843&amp;idx=1&amp;sn=b37cdf30f2e1938b0ac88cf4fc1eb331&amp;chksm=80b7883db7c0012bfd66cefc3669f25d3ebda8b840b592d7c7d439d0e730061735ecdebf0de6&amp;scene=21#wechat_redirect" target="_blank"></a><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650822765&amp;idx=1&amp;sn=027fa74bd88050f34bbcf9d4bef5d39e&amp;chksm=80b78cf3b7c005e57306a46dd849da6912d5aee990438d0733b5e9c242481ff81b997d94c03c&amp;scene=21#wechat_redirect" target="_blank">Android 利用Gradle实现差异化构建</a></p><p><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650823843&amp;idx=1&amp;sn=b37cdf30f2e1938b0ac88cf4fc1eb331&amp;chksm=80b7883db7c0012bfd66cefc3669f25d3ebda8b840b592d7c7d439d0e730061735ecdebf0de6&amp;scene=21#wechat_redirect" target="_blank"></a><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650822765&amp;idx=1&amp;sn=027fa74bd88050f34bbcf9d4bef5d39e&amp;chksm=80b78cf3b7c005e57306a46dd849da6912d5aee990438d0733b5e9c242481ff81b997d94c03c&amp;scene=21#wechat_redirect" target="_blank"></a><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650822597&amp;idx=1&amp;sn=462b116f97623f239ecf667d3bdef446&amp;chksm=80b7835bb7c00a4d4cbc9f7e19829d9a99f3cf58c1bc43dace16ffec58c98668927c9fa8dcda&amp;scene=21#wechat_redirect" target="_blank"></a><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650822381&amp;idx=1&amp;sn=d38f210256276f3b759e4c23ccc7896d&amp;chksm=80b78273b7c00b656b6b6f54ac54d6735600f54139dbe21a138afcdedeea424ec4d5e35262de&amp;scene=21#wechat_redirect" target="_blank">Android 自己动手生成 Apk 了解Apk生成的种种细节</a><br  /></p><h2 id="模块化-amp-动态化-amp-架构"><a href="#模块化-amp-动态化-amp-架构" class="headerlink" title="模块化&amp;动态化&amp;架构"></a>模块化&amp;动态化&amp;架构</h2><p><span style="max-width: 100%;font-size: 16px;box-sizing: border-box !important;word-wrap: break-word !important;"><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650824936&amp;idx=1&amp;sn=3ff975672fe98f2e5f8a1fd3de5a42b7&amp;chksm=80b7b476b7c03d6062ffa49bfd204ce1870b70cee7e6bde1f2da1159654475f7bdec8bc578b6&amp;scene=21#wechat_redirect" target="_blank">美团猫眼电影android模块化实战</a></span></p><p><span style="max-width: 100%;font-size: 16px;box-sizing: border-box !important;word-wrap: break-word !important;"><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650824936&amp;idx=1&amp;sn=3ff975672fe98f2e5f8a1fd3de5a42b7&amp;chksm=80b7b476b7c03d6062ffa49bfd204ce1870b70cee7e6bde1f2da1159654475f7bdec8bc578b6&amp;scene=21#wechat_redirect" target="_blank"></a><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650824879&amp;idx=1&amp;sn=f7d6830cb10046ff61bb461a15353e34&amp;chksm=80b7b431b7c03d271d1d836b586a29f813d738d9b7774075f8b50e7ab0215052c3e075ab71c4&amp;scene=21#wechat_redirect" target="_blank">Android 混淆查缺补漏</a></span></p><p><span style="max-width: 100%;font-size: 16px;box-sizing: border-box !important;word-wrap: break-word !important;"><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650824879&amp;idx=1&amp;sn=f7d6830cb10046ff61bb461a15353e34&amp;chksm=80b7b431b7c03d271d1d836b586a29f813d738d9b7774075f8b50e7ab0215052c3e075ab71c4&amp;scene=21#wechat_redirect" target="_blank"></a><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650824549&amp;idx=1&amp;sn=e029b57fd8fb90e091df00b00c190c09&amp;chksm=80b78bfbb7c002edfc0e86514f00d5110ff4295dd14cb15c4e569d8c9de96aac0eecd4871545&amp;scene=21#wechat_redirect" target="_blank">Android 应用架构组件（Architecture Components）实践</a></span></p><p><span style="max-width: 100%;font-size: 16px;box-sizing: border-box !important;word-wrap: break-word !important;"><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650824549&amp;idx=1&amp;sn=e029b57fd8fb90e091df00b00c190c09&amp;chksm=80b78bfbb7c002edfc0e86514f00d5110ff4295dd14cb15c4e569d8c9de96aac0eecd4871545&amp;scene=21#wechat_redirect" target="_blank"></a><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650823777&amp;idx=1&amp;sn=e4e0b9a1e6a7d41849155d078f018a3a&amp;chksm=80b788ffb7c001e93e74a626b4306625d1619957992411268a4d15672f3f08c2722ae8042a2a&amp;scene=21#wechat_redirect" target="_blank">如何打造一个 Android 编译时注解框架</a></span></p><p><span style="max-width: 100%;font-size: 16px;box-sizing: border-box !important;word-wrap: break-word !important;"><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650824549&amp;idx=1&amp;sn=e029b57fd8fb90e091df00b00c190c09&amp;chksm=80b78bfbb7c002edfc0e86514f00d5110ff4295dd14cb15c4e569d8c9de96aac0eecd4871545&amp;scene=21#wechat_redirect" target="_blank"></a><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650823777&amp;idx=1&amp;sn=e4e0b9a1e6a7d41849155d078f018a3a&amp;chksm=80b788ffb7c001e93e74a626b4306625d1619957992411268a4d15672f3f08c2722ae8042a2a&amp;scene=21#wechat_redirect" target="_blank"></a><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650823736&amp;idx=1&amp;sn=1ae0d1c6616876078deb524e7cdf89e2&amp;chksm=80b788a6b7c001b01c6ee589f1f5c78eb25e2e4791591d1433049aa195219fb1f8d79da6fe21&amp;scene=21#wechat_redirect" target="_blank">Android插件化快速入门与实例解析（VirtualApk）</a></span></p><p><span style="max-width: 100%;font-size: 16px;box-sizing: border-box !important;word-wrap: break-word !important;"><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650824549&amp;idx=1&amp;sn=e029b57fd8fb90e091df00b00c190c09&amp;chksm=80b78bfbb7c002edfc0e86514f00d5110ff4295dd14cb15c4e569d8c9de96aac0eecd4871545&amp;scene=21#wechat_redirect" target="_blank"></a><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650823777&amp;idx=1&amp;sn=e4e0b9a1e6a7d41849155d078f018a3a&amp;chksm=80b788ffb7c001e93e74a626b4306625d1619957992411268a4d15672f3f08c2722ae8042a2a&amp;scene=21#wechat_redirect" target="_blank"></a><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650823736&amp;idx=1&amp;sn=1ae0d1c6616876078deb524e7cdf89e2&amp;chksm=80b788a6b7c001b01c6ee589f1f5c78eb25e2e4791591d1433049aa195219fb1f8d79da6fe21&amp;scene=21#wechat_redirect" target="_blank"></a><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650823732&amp;idx=1&amp;sn=07921ef85f0d989c706d3ae35eb0051a&amp;chksm=80b788aab7c001bce1e2e410491422df7c31cc5b89b04806b976de9667b2967689d65cf7bc12&amp;scene=21#wechat_redirect" target="_blank">Android 项目最新架构</a></span><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650823732&amp;idx=1&amp;sn=07921ef85f0d989c706d3ae35eb0051a&amp;chksm=80b788aab7c001bce1e2e410491422df7c31cc5b89b04806b976de9667b2967689d65cf7bc12&amp;scene=21#wechat_redirect" target="_blank" style="font-size: 16px;"></a></p><p><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650823685&amp;idx=1&amp;sn=6ce37ce7835c950cd1174a695f8e930c&amp;chksm=80b7889bb7c0018d0cf21d96315bebf3300cb7aa652da25ccd76564cdc8b5ad539955ee09530&amp;scene=21#wechat_redirect" target="_blank">Android注解快速入门和实用解析</a><br  /></p><p><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650823681&amp;idx=1&amp;sn=126ac4ef73ad6bf7c0df7d248e7cb685&amp;chksm=80b7889fb7c00189a4a1fca86048e03156fa24c12db8aad00d7df83c65db4db30f0835265070&amp;scene=21#wechat_redirect" target="_blank">Google新推Lifecycle-aware Components 源码分析</a></p><p><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650823681&amp;idx=1&amp;sn=126ac4ef73ad6bf7c0df7d248e7cb685&amp;chksm=80b7889fb7c00189a4a1fca86048e03156fa24c12db8aad00d7df83c65db4db30f0835265070&amp;scene=21#wechat_redirect" target="_blank"></a><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650823490&amp;idx=1&amp;sn=073d98a1de5837c33875e66a0ec05aa7&amp;chksm=80b78fdcb7c006cae47601546e8b2def5644b3ea9a30675faec129015f6366a2490e2ec500f1&amp;scene=21#wechat_redirect" target="_blank">封装并实现统一的图片加载架构</a></p><p><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650823681&amp;idx=1&amp;sn=126ac4ef73ad6bf7c0df7d248e7cb685&amp;chksm=80b7889fb7c00189a4a1fca86048e03156fa24c12db8aad00d7df83c65db4db30f0835265070&amp;scene=21#wechat_redirect" target="_blank"></a><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650823490&amp;idx=1&amp;sn=073d98a1de5837c33875e66a0ec05aa7&amp;chksm=80b78fdcb7c006cae47601546e8b2def5644b3ea9a30675faec129015f6366a2490e2ec500f1&amp;scene=21#wechat_redirect" target="_blank"></a><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650823488&amp;idx=1&amp;sn=2976c8ddc0c206149b14c527260f7766&amp;chksm=80b78fdeb7c006c8a9585db794c51e799049ec50d23c4d738c78d77454f6b0291227a00e2def&amp;scene=21#wechat_redirect" target="_blank">深度 | 滴滴插件化方案 VirtualApk 源码解析</a></p><p><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650823488&amp;idx=1&amp;sn=2976c8ddc0c206149b14c527260f7766&amp;chksm=80b78fdeb7c006c8a9585db794c51e799049ec50d23c4d738c78d77454f6b0291227a00e2def&amp;scene=21#wechat_redirect" target="_blank"></a><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650823120&amp;idx=1&amp;sn=0e55edb7ed4f22b826f890abe8fcfef5&amp;chksm=80b78d4eb7c0045895acf26bdecef22e0f807428cb3b06d881c4c1c5aa44ae1d85448b310839&amp;scene=21#wechat_redirect" target="_blank">Android 热修复 Tinker Gradle Plugin解析</a></p><h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><p><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650824585&amp;idx=1&amp;sn=c2d83d5877c5ab96c253cc191a922541&amp;chksm=80b78b17b7c00201c75cae32aa84552e1526a2bd64c89b5a634246f21d41a62cdc5ee5b5822f&amp;scene=21#wechat_redirect" target="_blank">全方位带你彻底搞懂Android内存泄露 | 案例分析</a></p><p><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650824585&amp;idx=1&amp;sn=c2d83d5877c5ab96c253cc191a922541&amp;chksm=80b78b17b7c00201c75cae32aa84552e1526a2bd64c89b5a634246f21d41a62cdc5ee5b5822f&amp;scene=21#wechat_redirect" target="_blank"></a><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650824552&amp;idx=1&amp;sn=a634748d786072ecb083e46f27362d87&amp;chksm=80b78bf6b7c002e09b949b7fbc14b9ae0eb97d8794aca6fa6d42f80afcd27d07947641bab083&amp;scene=21#wechat_redirect" target="_blank">必知必会 | Android 性能优化的方面方面都在这儿</a></p><p><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650824585&amp;idx=1&amp;sn=c2d83d5877c5ab96c253cc191a922541&amp;chksm=80b78b17b7c00201c75cae32aa84552e1526a2bd64c89b5a634246f21d41a62cdc5ee5b5822f&amp;scene=21#wechat_redirect" target="_blank"></a><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650824552&amp;idx=1&amp;sn=a634748d786072ecb083e46f27362d87&amp;chksm=80b78bf6b7c002e09b949b7fbc14b9ae0eb97d8794aca6fa6d42f80afcd27d07947641bab083&amp;scene=21#wechat_redirect" target="_blank"></a><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650824544&amp;idx=1&amp;sn=2fc3cc16806bd1ddd9902ccef2cd12f5&amp;chksm=80b78bfeb7c002e822314661aa0df8e8d7981fb2ff3bc362c129bbf2952a87ff59a6213b821c&amp;scene=21#wechat_redirect" target="_blank">手把手教你在Android Studio 3.0上分析内存泄漏</a></p><p><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650824585&amp;idx=1&amp;sn=c2d83d5877c5ab96c253cc191a922541&amp;chksm=80b78b17b7c00201c75cae32aa84552e1526a2bd64c89b5a634246f21d41a62cdc5ee5b5822f&amp;scene=21#wechat_redirect" target="_blank"></a><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650824552&amp;idx=1&amp;sn=a634748d786072ecb083e46f27362d87&amp;chksm=80b78bf6b7c002e09b949b7fbc14b9ae0eb97d8794aca6fa6d42f80afcd27d07947641bab083&amp;scene=21#wechat_redirect" target="_blank"></a><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650824544&amp;idx=1&amp;sn=2fc3cc16806bd1ddd9902ccef2cd12f5&amp;chksm=80b78bfeb7c002e822314661aa0df8e8d7981fb2ff3bc362c129bbf2952a87ff59a6213b821c&amp;scene=21#wechat_redirect" target="_blank"></a><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650824291&amp;idx=1&amp;sn=4ce785be687537ebcfd7b1baeb2fce62&amp;chksm=80b78afdb7c003eb23bd885751cec7623039d7dca902b71b1f83079745b2674bf9b606d8cc36&amp;scene=21#wechat_redirect" target="_blank">让 Support-Annotations帮你发现潜在的问题吧</a></p><p><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650823537&amp;idx=1&amp;sn=b9fe7c0bcc9c3b95f32e989b50fbc08a&amp;chksm=80b78fefb7c006f975c8f4cf4cd5e92a59a47eea1229b399838712e131e0c9513ed0fdecb294&amp;scene=21#wechat_redirect" target="_blank">Android 你可能忽略的提高敲代码效率的方式</a></p><p><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650823537&amp;idx=1&amp;sn=b9fe7c0bcc9c3b95f32e989b50fbc08a&amp;chksm=80b78fefb7c006f975c8f4cf4cd5e92a59a47eea1229b399838712e131e0c9513ed0fdecb294&amp;scene=21#wechat_redirect" target="_blank"></a><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650823229&amp;idx=1&amp;sn=f7fd7affe7b331b620492dc3b76ef07e&amp;chksm=80b78ea3b7c007b5e57ea8155a463e9fc22c9bd8c7e93df9a2de62678e3eea65f1153b6f1ce2&amp;scene=21#wechat_redirect" target="_blank">AndroidStudio 插件 之 Findbugs 安装与简单使用教程</a></p><p><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650823537&amp;idx=1&amp;sn=b9fe7c0bcc9c3b95f32e989b50fbc08a&amp;chksm=80b78fefb7c006f975c8f4cf4cd5e92a59a47eea1229b399838712e131e0c9513ed0fdecb294&amp;scene=21#wechat_redirect" target="_blank"></a><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650823229&amp;idx=1&amp;sn=f7fd7affe7b331b620492dc3b76ef07e&amp;chksm=80b78ea3b7c007b5e57ea8155a463e9fc22c9bd8c7e93df9a2de62678e3eea65f1153b6f1ce2&amp;scene=21#wechat_redirect" target="_blank"></a><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650823025&amp;idx=1&amp;sn=561e345e918900af610b1b10377934e8&amp;chksm=80b78defb7c004f90bc516ad9b5183d2d4f2f3e4972570e0040b0b8a72d7501f438b9d6a8fa6&amp;scene=21#wechat_redirect" target="_blank">Android性能优化-电量优化</a></p><p><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650823537&amp;idx=1&amp;sn=b9fe7c0bcc9c3b95f32e989b50fbc08a&amp;chksm=80b78fefb7c006f975c8f4cf4cd5e92a59a47eea1229b399838712e131e0c9513ed0fdecb294&amp;scene=21#wechat_redirect" target="_blank"></a><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650823229&amp;idx=1&amp;sn=f7fd7affe7b331b620492dc3b76ef07e&amp;chksm=80b78ea3b7c007b5e57ea8155a463e9fc22c9bd8c7e93df9a2de62678e3eea65f1153b6f1ce2&amp;scene=21#wechat_redirect" target="_blank"></a><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650823025&amp;idx=1&amp;sn=561e345e918900af610b1b10377934e8&amp;chksm=80b78defb7c004f90bc516ad9b5183d2d4f2f3e4972570e0040b0b8a72d7501f438b9d6a8fa6&amp;scene=21#wechat_redirect" target="_blank"></a><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650822597&amp;idx=1&amp;sn=462b116f97623f239ecf667d3bdef446&amp;chksm=80b7835bb7c00a4d4cbc9f7e19829d9a99f3cf58c1bc43dace16ffec58c98668927c9fa8dcda&amp;scene=21#wechat_redirect" target="_blank">Android性能优化-内存泄漏的8个Case</a></p><p><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650822284&amp;idx=1&amp;sn=d6b30ab442f417cbd992e784945c7799&amp;chksm=80b78212b7c00b049243a474933e7a3f356c8b6fca1e8d67a9fcf654cef095c0c28f6a51e31c&amp;scene=21#wechat_redirect" target="_blank">Android性能优化系列之App启动优化</a></p><p><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650822284&amp;idx=1&amp;sn=d6b30ab442f417cbd992e784945c7799&amp;chksm=80b78212b7c00b049243a474933e7a3f356c8b6fca1e8d67a9fcf654cef095c0c28f6a51e31c&amp;scene=21#wechat_redirect" target="_blank"></a><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650822272&amp;idx=1&amp;sn=a1d7956dd8437d4bb28e47fab814a7ed&amp;chksm=80b7821eb7c00b08eb8de256529a7cbd153ca1064612eef88fe912ba9ecb11763baacc279ccb&amp;scene=21#wechat_redirect" target="_blank">Android性能优化系列之内存优化</a></p><p><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650822284&amp;idx=1&amp;sn=d6b30ab442f417cbd992e784945c7799&amp;chksm=80b78212b7c00b049243a474933e7a3f356c8b6fca1e8d67a9fcf654cef095c0c28f6a51e31c&amp;scene=21#wechat_redirect" target="_blank"></a><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650822272&amp;idx=1&amp;sn=a1d7956dd8437d4bb28e47fab814a7ed&amp;chksm=80b7821eb7c00b08eb8de256529a7cbd153ca1064612eef88fe912ba9ecb11763baacc279ccb&amp;scene=21#wechat_redirect" target="_blank"></a><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650822205&amp;idx=1&amp;sn=6b8e78bc1d71eb79a199667cf132acf7&amp;chksm=80b782a3b7c00bb5c12437556fca68136c75409855e9252e395b545621319edf23959942b67c&amp;scene=21#wechat_redirect" target="_blank">Android UI性能优化 检测应用中的UI卡顿</a></p><p><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650822284&amp;idx=1&amp;sn=d6b30ab442f417cbd992e784945c7799&amp;chksm=80b78212b7c00b049243a474933e7a3f356c8b6fca1e8d67a9fcf654cef095c0c28f6a51e31c&amp;scene=21#wechat_redirect" target="_blank"></a><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650822272&amp;idx=1&amp;sn=a1d7956dd8437d4bb28e47fab814a7ed&amp;chksm=80b7821eb7c00b08eb8de256529a7cbd153ca1064612eef88fe912ba9ecb11763baacc279ccb&amp;scene=21#wechat_redirect" target="_blank"></a><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650822205&amp;idx=1&amp;sn=6b8e78bc1d71eb79a199667cf132acf7&amp;chksm=80b782a3b7c00bb5c12437556fca68136c75409855e9252e395b545621319edf23959942b67c&amp;scene=21#wechat_redirect" target="_blank"></a><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650822043&amp;idx=1&amp;sn=0c9c1a9382cc148799dc9f34a2c80cd4&amp;chksm=80b78105b7c00813773062b1a5632313d382b31d4e1720643bb65b324c377eacd5a8d84f4d3f&amp;scene=21#wechat_redirect" target="_blank">Android性能优化系列 之 apk瘦身</a><br  /></p><h2 id="RxJava"><a href="#RxJava" class="headerlink" title="RxJava"></a>RxJava</h2><p style="white-space: normal;"><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650824984&amp;idx=1&amp;sn=36a2d6b973fbb383f6d7201c844db9c3&amp;chksm=80b7b586b7c03c9088298ad3f0e138bc388c4497c050ab867288a149f4ea781ad4d40191d435&amp;scene=21#wechat_redirect" target="_blank">手把手带你入门神秘的 RxJava</a></p><p style="white-space: normal;"><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650824984&amp;idx=1&amp;sn=36a2d6b973fbb383f6d7201c844db9c3&amp;chksm=80b7b586b7c03c9088298ad3f0e138bc388c4497c050ab867288a149f4ea781ad4d40191d435&amp;scene=21#wechat_redirect" target="_blank"></a><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650824891&amp;idx=1&amp;sn=d86b4c2215247d78bfa0b60207ae2fe6&amp;chksm=80b7b425b7c03d336e240c7b885b5a326f3c589f22d40a17561938468963bb5321e8413d480c&amp;scene=21#wechat_redirect" target="_blank">这是一份全面 &amp; 详细 的RxJava操作符 使用攻略</a></p><p><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650823932&amp;idx=1&amp;sn=198b18f2f9359e2eee1ffc8703d31905&amp;chksm=80b78862b7c001741916c681d070ca3c1a58eef5632ea394797029d0335f312816afecf87e7d&amp;scene=21#wechat_redirect" target="_blank" style="white-space: normal;">RxJava2 学习资料推荐</a></p><p><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650823932&amp;idx=1&amp;sn=198b18f2f9359e2eee1ffc8703d31905&amp;chksm=80b78862b7c001741916c681d070ca3c1a58eef5632ea394797029d0335f312816afecf87e7d&amp;scene=21#wechat_redirect" target="_blank" style="white-space: normal;"></a></p><p><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650823617&amp;idx=1&amp;sn=09fce6bbdc139f7a29e0abb4a4d954a7&amp;chksm=80b78f5fb7c006490c394d1a44b06ca458109bd5c6b021b409642f921a7eb8d60d4c5f6dddea&amp;scene=21#wechat_redirect" target="_blank" style="white-space: normal;">这可能是最好的RxJava 2.x 教程（完结版）</a></p><p style="white-space: normal;"><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650823617&amp;idx=1&amp;sn=09fce6bbdc139f7a29e0abb4a4d954a7&amp;chksm=80b78f5fb7c006490c394d1a44b06ca458109bd5c6b021b409642f921a7eb8d60d4c5f6dddea&amp;scene=21#wechat_redirect" target="_blank"></a><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650823410&amp;idx=1&amp;sn=dfe80ee133db7bba43ed6d47579057bd&amp;chksm=80b78e6cb7c0077aaf10ae04c56a7c5c181b79d960e9cff9385744896e8f0be8c4d2138426ef&amp;scene=21#wechat_redirect" target="_blank">深度 | 重新理解响应式编程</a><br  /></p><h2 id="推荐类"><a href="#推荐类" class="headerlink" title="推荐类"></a>推荐类</h2><p><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650824776&amp;idx=1&amp;sn=8f1a97564cd88dbfea3163a41813eea1&amp;chksm=80b7b4d6b7c03dc0c33d7baa074e96cec9a467651a3d7cbe3b94c16910422294fffd4fb2ed90&amp;scene=21#wechat_redirect" target="_blank">回顾下今年使用过的好用的插件、工具等</a></p><p><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650824776&amp;idx=1&amp;sn=8f1a97564cd88dbfea3163a41813eea1&amp;chksm=80b7b4d6b7c03dc0c33d7baa074e96cec9a467651a3d7cbe3b94c16910422294fffd4fb2ed90&amp;scene=21#wechat_redirect" target="_blank"></a><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650824428&amp;idx=1&amp;sn=e60f266d234509148da3a1c79609e435&amp;chksm=80b78a72b7c003640d4584e809ab44cecc03530d03c69dbba3506eda6ec902543da29eeb6cdb&amp;scene=21#wechat_redirect" target="_blank">必会 | 手把手带你体验Android Studio 3.0的新功能</a></p><p><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650824776&amp;idx=1&amp;sn=8f1a97564cd88dbfea3163a41813eea1&amp;chksm=80b7b4d6b7c03dc0c33d7baa074e96cec9a467651a3d7cbe3b94c16910422294fffd4fb2ed90&amp;scene=21#wechat_redirect" target="_blank"></a><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650824428&amp;idx=1&amp;sn=e60f266d234509148da3a1c79609e435&amp;chksm=80b78a72b7c003640d4584e809ab44cecc03530d03c69dbba3506eda6ec902543da29eeb6cdb&amp;scene=21#wechat_redirect" target="_blank"></a><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650824382&amp;idx=1&amp;sn=a2268c41e5282d2919a75580755ef0ed&amp;chksm=80b78a20b7c00336f9d57c085135eacc5352c1032299451e75ba9b2384c1a4d863f8dafddf88&amp;scene=21#wechat_redirect" target="_blank">1024 送你几个用起来很爽的Studio插件</a></p><p><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650824776&amp;idx=1&amp;sn=8f1a97564cd88dbfea3163a41813eea1&amp;chksm=80b7b4d6b7c03dc0c33d7baa074e96cec9a467651a3d7cbe3b94c16910422294fffd4fb2ed90&amp;scene=21#wechat_redirect" target="_blank"></a><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650824428&amp;idx=1&amp;sn=e60f266d234509148da3a1c79609e435&amp;chksm=80b78a72b7c003640d4584e809ab44cecc03530d03c69dbba3506eda6ec902543da29eeb6cdb&amp;scene=21#wechat_redirect" target="_blank"></a><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650824382&amp;idx=1&amp;sn=a2268c41e5282d2919a75580755ef0ed&amp;chksm=80b78a20b7c00336f9d57c085135eacc5352c1032299451e75ba9b2384c1a4d863f8dafddf88&amp;scene=21#wechat_redirect" target="_blank"></a><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650824144&amp;idx=1&amp;sn=2d4efe56f044546eb192918452a1d4b1&amp;chksm=80b7894eb7c00058ac918296c5437c8d1d2d5fa9a7e8d4b66be10b946d003885ad9142f95257&amp;scene=21#wechat_redirect" target="_blank">推荐几个你应该知道的Studio插件</a></p><p><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650824144&amp;idx=1&amp;sn=2d4efe56f044546eb192918452a1d4b1&amp;chksm=80b7894eb7c00058ac918296c5437c8d1d2d5fa9a7e8d4b66be10b946d003885ad9142f95257&amp;scene=21#wechat_redirect" target="_blank"></a><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650823613&amp;idx=1&amp;sn=18944ce69ff51910622a9951a0d772ff&amp;chksm=80b78f23b7c006351d665b54fccb8759183e30bfb163d9a6f6d3c4507bef961819813d2d1a4e&amp;scene=21#wechat_redirect" target="_blank">开发App没有数据源？不存在的！国内值得关注的API集合</a></p><p><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650824144&amp;idx=1&amp;sn=2d4efe56f044546eb192918452a1d4b1&amp;chksm=80b7894eb7c00058ac918296c5437c8d1d2d5fa9a7e8d4b66be10b946d003885ad9142f95257&amp;scene=21#wechat_redirect" target="_blank"></a><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650823613&amp;idx=1&amp;sn=18944ce69ff51910622a9951a0d772ff&amp;chksm=80b78f23b7c006351d665b54fccb8759183e30bfb163d9a6f6d3c4507bef961819813d2d1a4e&amp;scene=21#wechat_redirect" target="_blank"></a><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650823558&amp;idx=1&amp;sn=3107518ffbbae93839dc7eadaab45e26&amp;chksm=80b78f18b7c0060e4721c9bb4959b521439672d13edb91279d4306aebfbb16d1d70b98ff9344&amp;scene=21#wechat_redirect" target="_blank">安卓开发中必备的那些神器APP</a></p><p><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650823558&amp;idx=1&amp;sn=3107518ffbbae93839dc7eadaab45e26&amp;chksm=80b78f18b7c0060e4721c9bb4959b521439672d13edb91279d4306aebfbb16d1d70b98ff9344&amp;scene=21#wechat_redirect" target="_blank">Android 你应该注意的开发规范</a></p><p><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650823558&amp;idx=1&amp;sn=3107518ffbbae93839dc7eadaab45e26&amp;chksm=80b78f18b7c0060e4721c9bb4959b521439672d13edb91279d4306aebfbb16d1d70b98ff9344&amp;scene=21#wechat_redirect" target="_blank"></a><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650825002&amp;idx=1&amp;sn=1ee33c018bc52408e99962c0515e0702&amp;chksm=80b7b5b4b7c03ca2fbc02c18cb2524d23dc431a2edbc1a1b6dacb7250967202efedc00c3bfe5&amp;scene=21#wechat_redirect" target="_blank">Android小技巧 提升开发效率</a></p><h2 id="常用控件"><a href="#常用控件" class="headerlink" title="常用控件"></a>常用控件</h2><p><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650824778&amp;idx=1&amp;sn=c7116f310e70a2403c5e5d88c724060b&amp;chksm=80b7b4d4b7c03dc2104af31ba115f88a276761d7e4b0fea10879d92698c45fadf3b0e117548b&amp;scene=21#wechat_redirect" target="_blank">用RecyclerView做一个小清新的Gallery效果</a></p><p><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650824778&amp;idx=1&amp;sn=c7116f310e70a2403c5e5d88c724060b&amp;chksm=80b7b4d4b7c03dc2104af31ba115f88a276761d7e4b0fea10879d92698c45fadf3b0e117548b&amp;scene=21#wechat_redirect" target="_blank"></a><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650824705&amp;idx=1&amp;sn=346c8bacea281cde8c30ae4a9f4b949d&amp;chksm=80b7b49fb7c03d899bfbbd8336edb57857a04b75b07b7e2f06a93eace02f1c9707b954900674&amp;scene=21#wechat_redirect" target="_blank">ViewPager 超详解：玩出十八般花样</a></p><p><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650824705&amp;idx=1&amp;sn=346c8bacea281cde8c30ae4a9f4b949d&amp;chksm=80b7b49fb7c03d899bfbbd8336edb57857a04b75b07b7e2f06a93eace02f1c9707b954900674&amp;scene=21#wechat_redirect" target="_blank"></a><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650824671&amp;idx=1&amp;sn=353eb05bfed2dd210106e0b4ab39a5db&amp;chksm=80b78b41b7c00257f7b5887fad7fa59ed19d81de9bd561b02d520d0692fe07d96aeae7627abe&amp;scene=21#wechat_redirect" target="_blank">用RecyclerView打造一个轮播图</a></p><p><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650824671&amp;idx=1&amp;sn=353eb05bfed2dd210106e0b4ab39a5db&amp;chksm=80b78b41b7c00257f7b5887fad7fa59ed19d81de9bd561b02d520d0692fe07d96aeae7627abe&amp;scene=21#wechat_redirect" target="_blank"></a><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650824615&amp;idx=1&amp;sn=7ccb5f8d4cfb1136bfa541d2dcd06e91&amp;chksm=80b78b39b7c0022fd3ce8fc7a1228aac72841c0228f9904ea5da472d9d985f99198dd124d18d&amp;scene=21#wechat_redirect" target="_blank">开发一款商业级Banner控件</a></p><p><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650824615&amp;idx=1&amp;sn=7ccb5f8d4cfb1136bfa541d2dcd06e91&amp;chksm=80b78b39b7c0022fd3ce8fc7a1228aac72841c0228f9904ea5da472d9d985f99198dd124d18d&amp;scene=21#wechat_redirect" target="_blank"></a><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650824505&amp;idx=1&amp;sn=f4a7e29103037a532491dd80ae4f75b9&amp;chksm=80b78ba7b7c002b1a6875ad118522916b988a352b44b6f59adf6f1ff391f8e54f55e5a9f7fd7&amp;scene=21#wechat_redirect" target="_blank">封装RecyclerView自动加载更多 &amp; 下拉刷新</a></p><p><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650824615&amp;idx=1&amp;sn=7ccb5f8d4cfb1136bfa541d2dcd06e91&amp;chksm=80b78b39b7c0022fd3ce8fc7a1228aac72841c0228f9904ea5da472d9d985f99198dd124d18d&amp;scene=21#wechat_redirect" target="_blank"></a><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650824505&amp;idx=1&amp;sn=f4a7e29103037a532491dd80ae4f75b9&amp;chksm=80b78ba7b7c002b1a6875ad118522916b988a352b44b6f59adf6f1ff391f8e54f55e5a9f7fd7&amp;scene=21#wechat_redirect" target="_blank"></a><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650824224&amp;idx=1&amp;sn=ff9adcb990e535c1c6ebe82982d94e77&amp;chksm=80b78abeb7c003a83eef585709baca77075541892c4dfdfeea91db478390123e983ca43af7e3&amp;scene=21#wechat_redirect" target="_blank">搞定 RecycleView 自动加载更多、侧滑菜单、添加头部底部</a></p><p><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650824615&amp;idx=1&amp;sn=7ccb5f8d4cfb1136bfa541d2dcd06e91&amp;chksm=80b78b39b7c0022fd3ce8fc7a1228aac72841c0228f9904ea5da472d9d985f99198dd124d18d&amp;scene=21#wechat_redirect" target="_blank"></a><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650824505&amp;idx=1&amp;sn=f4a7e29103037a532491dd80ae4f75b9&amp;chksm=80b78ba7b7c002b1a6875ad118522916b988a352b44b6f59adf6f1ff391f8e54f55e5a9f7fd7&amp;scene=21#wechat_redirect" target="_blank"></a><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650824224&amp;idx=1&amp;sn=ff9adcb990e535c1c6ebe82982d94e77&amp;chksm=80b78abeb7c003a83eef585709baca77075541892c4dfdfeea91db478390123e983ca43af7e3&amp;scene=21#wechat_redirect" target="_blank"></a><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650824132&amp;idx=1&amp;sn=1cf09caa325d83de12b73c615fc9613e&amp;chksm=80b7895ab7c0004c5cbb2175a3da302fc13d612762f56094f13b80e1334e7655dde1ad00083c&amp;scene=21#wechat_redirect" target="_blank">拒绝拖拽 &nbsp;使用ConstraintLayout优化你的布局吧</a></p><p><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650824132&amp;idx=1&amp;sn=1cf09caa325d83de12b73c615fc9613e&amp;chksm=80b7895ab7c0004c5cbb2175a3da302fc13d612762f56094f13b80e1334e7655dde1ad00083c&amp;scene=21#wechat_redirect" target="_blank"></a><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650824011&amp;idx=1&amp;sn=ac22841c0219e07f388fa15495819305&amp;chksm=80b789d5b7c000c38add9c73e87e21feb4956a7b4a2090e333df73bcc155dc67dd422c8cc7d6&amp;scene=21#wechat_redirect" target="_blank">RecyclerView 梳理：点击&amp;长按事件、分割线、拖曳排序、滑动删除</a></p><p><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650824011&amp;idx=1&amp;sn=ac22841c0219e07f388fa15495819305&amp;chksm=80b789d5b7c000c38add9c73e87e21feb4956a7b4a2090e333df73bcc155dc67dd422c8cc7d6&amp;scene=21#wechat_redirect" target="_blank"></a><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650823619&amp;idx=1&amp;sn=47377ebc3a14f28642c24c0097ac9581&amp;chksm=80b78f5db7c0064b6618c11567b11fe3f6c000f682571fdfd35676f37f9050679c5f14055a44&amp;scene=21#wechat_redirect" target="_blank">快速实现炫酷的ViewPager卡片效果</a></p><p><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650823619&amp;idx=1&amp;sn=47377ebc3a14f28642c24c0097ac9581&amp;chksm=80b78f5db7c0064b6618c11567b11fe3f6c000f682571fdfd35676f37f9050679c5f14055a44&amp;scene=21#wechat_redirect" target="_blank"></a><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650823560&amp;idx=1&amp;sn=b59844a2ef122d21d543a21833fe364b&amp;chksm=80b78f16b7c00600e54848fbe3a4fdd4599dfcce23dddc4709e4bd9c4d25d813bdfc82c05700&amp;scene=21#wechat_redirect" target="_blank">Android ConstraintLayout详解</a></p><p><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650823619&amp;idx=1&amp;sn=47377ebc3a14f28642c24c0097ac9581&amp;chksm=80b78f5db7c0064b6618c11567b11fe3f6c000f682571fdfd35676f37f9050679c5f14055a44&amp;scene=21#wechat_redirect" target="_blank"></a><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650823560&amp;idx=1&amp;sn=b59844a2ef122d21d543a21833fe364b&amp;chksm=80b78f16b7c00600e54848fbe3a4fdd4599dfcce23dddc4709e4bd9c4d25d813bdfc82c05700&amp;scene=21#wechat_redirect" target="_blank"></a><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650823491&amp;idx=1&amp;sn=3d31336ee22d8dd0fc28c42d86b1b780&amp;chksm=80b78fddb7c006cb54c1a246bd87a33078bf40c9cbc7cd62366cbb3c50053c590959fde5c510&amp;scene=21#wechat_redirect" target="_blank">RecyclerView实现双列表联动</a><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650823491&amp;idx=1&amp;sn=3d31336ee22d8dd0fc28c42d86b1b780&amp;chksm=80b78fddb7c006cb54c1a246bd87a33078bf40c9cbc7cd62366cbb3c50053c590959fde5c510&amp;scene=21#wechat_redirect" target="_blank"></a></p><p><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650824857&amp;idx=1&amp;sn=4e7b9911c166cbbfbda5d040e8cfd19d&amp;chksm=80b7b407b7c03d1146b5625f029fbe6867acd79188258fac5e5913687dd6db1cec5d4a73459e&amp;scene=21#wechat_redirect" target="_blank">全面总结WebView遇到的坑及优化</a></p><p><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650824857&amp;idx=1&amp;sn=4e7b9911c166cbbfbda5d040e8cfd19d&amp;chksm=80b7b407b7c03d1146b5625f029fbe6867acd79188258fac5e5913687dd6db1cec5d4a73459e&amp;scene=21#wechat_redirect" target="_blank"></a><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650824752&amp;idx=1&amp;sn=ae4318393b633bc93a2fec4364eaee68&amp;chksm=80b7b4aeb7c03db80c5dcad9f89e918d2ce64b0e041abcb375222892e03c587e33288c1885e2&amp;scene=21#wechat_redirect" target="_blank">必知必会 | WebView 的一切都在这儿</a></p><p><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650824752&amp;idx=1&amp;sn=ae4318393b633bc93a2fec4364eaee68&amp;chksm=80b7b4aeb7c03db80c5dcad9f89e918d2ce64b0e041abcb375222892e03c587e33288c1885e2&amp;scene=21#wechat_redirect" target="_blank"></a><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650823284&amp;idx=1&amp;sn=403bf09e3fdc76fc04cb600d13b0e5a1&amp;chksm=80b78eeab7c007fc2636e3b27340324fea050da11905f41eb11d9bdfa90c5c9c37be59024b67&amp;scene=21#wechat_redirect" target="_blank">实战 | 封装解决WebView的那些坑</a></p><h2 id="UI特效"><a href="#UI特效" class="headerlink" title="UI特效"></a>UI特效</h2><p><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650824937&amp;idx=1&amp;sn=8a29d81d0cdec350b4d5521c322db8dc&amp;chksm=80b7b477b7c03d61107d08f387f5e6323ff592132385a82ce53f0b1860febdfe7d94fdfc8c45&amp;scene=21#wechat_redirect" target="_blank">拼图滑块 创意验证码控件</a></p><p><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650824937&amp;idx=1&amp;sn=8a29d81d0cdec350b4d5521c322db8dc&amp;chksm=80b7b477b7c03d61107d08f387f5e6323ff592132385a82ce53f0b1860febdfe7d94fdfc8c45&amp;scene=21#wechat_redirect" target="_blank"></a><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650824901&amp;idx=1&amp;sn=3125688c69c06731f307ceb80b21d89a&amp;chksm=80b7b45bb7c03d4d44171b90a3bb1a5bc17187072f444cf18f89268eb0c3f17a940e7344610d&amp;scene=21#wechat_redirect" target="_blank">仿天猫、京东拖拽商品详情</a></p><p><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650824937&amp;idx=1&amp;sn=8a29d81d0cdec350b4d5521c322db8dc&amp;chksm=80b7b477b7c03d61107d08f387f5e6323ff592132385a82ce53f0b1860febdfe7d94fdfc8c45&amp;scene=21#wechat_redirect" target="_blank"></a><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650824901&amp;idx=1&amp;sn=3125688c69c06731f307ceb80b21d89a&amp;chksm=80b7b45bb7c03d4d44171b90a3bb1a5bc17187072f444cf18f89268eb0c3f17a940e7344610d&amp;scene=21#wechat_redirect" target="_blank"></a><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650824882&amp;idx=1&amp;sn=0bbeff9de97e3c03c6396790cc444a49&amp;chksm=80b7b42cb7c03d3a949314734c2b7c83b9934ff79e731473dca63bd65050e8906d032d3413ce&amp;scene=21#wechat_redirect" target="_blank">来做一个3D效果的小米指南针</a></p><p><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650824882&amp;idx=1&amp;sn=0bbeff9de97e3c03c6396790cc444a49&amp;chksm=80b7b42cb7c03d3a949314734c2b7c83b9934ff79e731473dca63bd65050e8906d032d3413ce&amp;scene=21#wechat_redirect" target="_blank"></a><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650824641&amp;idx=1&amp;sn=9bbacf9c6f0900ec71a2abb2b246137f&amp;chksm=80b78b5fb7c002492b725417c3579da35dcaafe677279987cf7666da4d64f3df817764d6ef9d&amp;scene=21#wechat_redirect" target="_blank">Android 仿知乎创意广告 还能这么玩?</a></p><p><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650824882&amp;idx=1&amp;sn=0bbeff9de97e3c03c6396790cc444a49&amp;chksm=80b7b42cb7c03d3a949314734c2b7c83b9934ff79e731473dca63bd65050e8906d032d3413ce&amp;scene=21#wechat_redirect" target="_blank"></a><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650824641&amp;idx=1&amp;sn=9bbacf9c6f0900ec71a2abb2b246137f&amp;chksm=80b78b5fb7c002492b725417c3579da35dcaafe677279987cf7666da4d64f3df817764d6ef9d&amp;scene=21#wechat_redirect" target="_blank"></a><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650824601&amp;idx=1&amp;sn=61a0c52ca7c292ecb5a28c5cc6a34ea3&amp;chksm=80b78b07b7c002110b278ef38bb9361d2e832f2b241e3e24e7b7957ff9ceb6987b879b4d9175&amp;scene=21#wechat_redirect" target="_blank">精通Span 轻松玩转各种文本特效</a></p><p><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650824601&amp;idx=1&amp;sn=61a0c52ca7c292ecb5a28c5cc6a34ea3&amp;chksm=80b78b07b7c002110b278ef38bb9361d2e832f2b241e3e24e7b7957ff9ceb6987b879b4d9175&amp;scene=21#wechat_redirect" target="_blank"></a><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650824513&amp;idx=1&amp;sn=b1bf1093ad1853c0aff5d0d076a309b2&amp;chksm=80b78bdfb7c002c9fffa1d31d53ff651320d4734b11b9067383fd84c06f02700fe7f40f24a9e&amp;scene=21#wechat_redirect" target="_blank">Android 仿猿题库巧用Span实现填空题 &amp; 技术分享资料下载</a></p><p><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650824601&amp;idx=1&amp;sn=61a0c52ca7c292ecb5a28c5cc6a34ea3&amp;chksm=80b78b07b7c002110b278ef38bb9361d2e832f2b241e3e24e7b7957ff9ceb6987b879b4d9175&amp;scene=21#wechat_redirect" target="_blank"></a><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650824513&amp;idx=1&amp;sn=b1bf1093ad1853c0aff5d0d076a309b2&amp;chksm=80b78bdfb7c002c9fffa1d31d53ff651320d4734b11b9067383fd84c06f02700fe7f40f24a9e&amp;scene=21#wechat_redirect" target="_blank"></a><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650824475&amp;idx=1&amp;sn=cbc761081eb45456e93f5e2496fa2ff8&amp;chksm=80b78b85b7c002930dcc93234310ef377b2f0bbd9fbc2b29e1bc8f47b4dce677f3b4aba68f12&amp;scene=21#wechat_redirect" target="_blank">TextView 图文混排 &amp; 炫酷的段落级Span解析</a></p><p><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650824601&amp;idx=1&amp;sn=61a0c52ca7c292ecb5a28c5cc6a34ea3&amp;chksm=80b78b07b7c002110b278ef38bb9361d2e832f2b241e3e24e7b7957ff9ceb6987b879b4d9175&amp;scene=21#wechat_redirect" target="_blank"></a><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650824513&amp;idx=1&amp;sn=b1bf1093ad1853c0aff5d0d076a309b2&amp;chksm=80b78bdfb7c002c9fffa1d31d53ff651320d4734b11b9067383fd84c06f02700fe7f40f24a9e&amp;scene=21#wechat_redirect" target="_blank"></a><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650824475&amp;idx=1&amp;sn=cbc761081eb45456e93f5e2496fa2ff8&amp;chksm=80b78b85b7c002930dcc93234310ef377b2f0bbd9fbc2b29e1bc8f47b4dce677f3b4aba68f12&amp;scene=21#wechat_redirect" target="_blank"></a><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650824324&amp;idx=1&amp;sn=0d6f90a08a1ece83493ae784c2ffff1d&amp;chksm=80b78a1ab7c0030c950aec8d422af5b92ca246eb8245249b25db0975f709a54766976d247e83&amp;scene=21#wechat_redirect" target="_blank">Android 优雅展示填空题 拖拽完成选词</a></p><p><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650824324&amp;idx=1&amp;sn=0d6f90a08a1ece83493ae784c2ffff1d&amp;chksm=80b78a1ab7c0030c950aec8d422af5b92ca246eb8245249b25db0975f709a54766976d247e83&amp;scene=21#wechat_redirect" target="_blank"></a><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650824000&amp;idx=1&amp;sn=42260b2a5cdf9a78d0dc5edbc3939f74&amp;chksm=80b789deb7c000c853e150c7d50747bf00e4a10d864cae8e37b3730c857b9fe74958a7c66173&amp;scene=21#wechat_redirect" target="_blank">最近很火的全景图功能是如何实现的？</a></p><p><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650824000&amp;idx=1&amp;sn=42260b2a5cdf9a78d0dc5edbc3939f74&amp;chksm=80b789deb7c000c853e150c7d50747bf00e4a10d864cae8e37b3730c857b9fe74958a7c66173&amp;scene=21#wechat_redirect" target="_blank"></a><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650823356&amp;idx=1&amp;sn=d8032af789d075d87ecdc520c625633e&amp;chksm=80b78e22b7c0073492da90a3008975e441760425f7d4c29e7cea16e4e5f74ec49cb748c9c235&amp;scene=21#wechat_redirect" target="_blank">最新特效 | 模仿手机QQ底部导航栏Icon拖拽效果</a></p><p><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650824000&amp;idx=1&amp;sn=42260b2a5cdf9a78d0dc5edbc3939f74&amp;chksm=80b789deb7c000c853e150c7d50747bf00e4a10d864cae8e37b3730c857b9fe74958a7c66173&amp;scene=21#wechat_redirect" target="_blank"></a><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650823356&amp;idx=1&amp;sn=d8032af789d075d87ecdc520c625633e&amp;chksm=80b78e22b7c0073492da90a3008975e441760425f7d4c29e7cea16e4e5f74ec49cb748c9c235&amp;scene=21#wechat_redirect" target="_blank"></a><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650822816&amp;idx=1&amp;sn=ccc5eca1723cd9bf9d32594b85c54b44&amp;chksm=80b78c3eb7c005282136fddb8e448826ba4d344965871b7aecd2ee573789a659a48e85c75a78&amp;scene=21#wechat_redirect" target="_blank">Lottie -- 轻松实现动态加载直播礼物动画</a></p><p><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650824000&amp;idx=1&amp;sn=42260b2a5cdf9a78d0dc5edbc3939f74&amp;chksm=80b789deb7c000c853e150c7d50747bf00e4a10d864cae8e37b3730c857b9fe74958a7c66173&amp;scene=21#wechat_redirect" target="_blank"></a><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650823356&amp;idx=1&amp;sn=d8032af789d075d87ecdc520c625633e&amp;chksm=80b78e22b7c0073492da90a3008975e441760425f7d4c29e7cea16e4e5f74ec49cb748c9c235&amp;scene=21#wechat_redirect" target="_blank"></a><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650822816&amp;idx=1&amp;sn=ccc5eca1723cd9bf9d32594b85c54b44&amp;chksm=80b78c3eb7c005282136fddb8e448826ba4d344965871b7aecd2ee573789a659a48e85c75a78&amp;scene=21#wechat_redirect" target="_blank"></a><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650822680&amp;idx=1&amp;sn=24a4faf2188079d7995fbda7375d2d56&amp;chksm=80b78c86b7c0059090f95fae40791fd9962214331295f2ae30c95289258d6284e7dba3956e4c&amp;scene=21#wechat_redirect" target="_blank">Android AutoWrapTextView 解决中英文排版问题</a></p><h2 id="小知识"><a href="#小知识" class="headerlink" title="小知识"></a>小知识</h2><p style="white-space: normal;text-align: left;"><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650825002&amp;idx=1&amp;sn=1ee33c018bc52408e99962c0515e0702&amp;chksm=80b7b5b4b7c03ca2fbc02c18cb2524d23dc431a2edbc1a1b6dacb7250967202efedc00c3bfe5&amp;scene=21#wechat_redirect" target="_blank" style="white-space: normal;"></a><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650824896&amp;idx=1&amp;sn=a7d908267a69a58e4634f14b29505100&amp;chksm=80b7b45eb7c03d48b07d9dc1f6fd643c1591d118f468ede4a86e9b85b81defb3dc7d2a033e2c&amp;scene=21#wechat_redirect" target="_blank" style="white-space: normal;">应该了解的一些并发基础知识</a></p><p style="white-space: normal;text-align: left;"><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650825002&amp;idx=1&amp;sn=1ee33c018bc52408e99962c0515e0702&amp;chksm=80b7b5b4b7c03ca2fbc02c18cb2524d23dc431a2edbc1a1b6dacb7250967202efedc00c3bfe5&amp;scene=21#wechat_redirect" target="_blank" style="white-space: normal;"></a><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650824896&amp;idx=1&amp;sn=a7d908267a69a58e4634f14b29505100&amp;chksm=80b7b45eb7c03d48b07d9dc1f6fd643c1591d118f468ede4a86e9b85b81defb3dc7d2a033e2c&amp;scene=21#wechat_redirect" target="_blank" style="white-space: normal;"></a><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650824878&amp;idx=1&amp;sn=01a34ae6ba711aedb266a6606bbb0c3d&amp;chksm=80b7b430b7c03d26435fce75dcf3e70b0992f67e37f585cb49eefe7abb4b806f77e8174a738b&amp;scene=21#wechat_redirect" target="_blank" style="white-space: normal;">解决一位群友问题 &nbsp;Android上的隔空取物</a></p><p style="white-space: normal;text-align: left;"><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650824878&amp;idx=1&amp;sn=01a34ae6ba711aedb266a6606bbb0c3d&amp;chksm=80b7b430b7c03d26435fce75dcf3e70b0992f67e37f585cb49eefe7abb4b806f77e8174a738b&amp;scene=21#wechat_redirect" target="_blank" style="white-space: normal;"></a><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650824673&amp;idx=1&amp;sn=82c1a980b6bf612efc30f433de81c894&amp;chksm=80b78b7fb7c002696c1f63f730dcc41abfaad2c617d3e46aaff5199e2b915249c1ceba76c7c5&amp;scene=21#wechat_redirect" target="_blank" style="white-space: normal;">开发SDK和平时写代码体验不同吗? | 经验分享</a></p><p style="white-space: normal;text-align: left;"><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650824673&amp;idx=1&amp;sn=82c1a980b6bf612efc30f433de81c894&amp;chksm=80b78b7fb7c002696c1f63f730dcc41abfaad2c617d3e46aaff5199e2b915249c1ceba76c7c5&amp;scene=21#wechat_redirect" target="_blank" style="white-space: normal;"></a><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650824633&amp;idx=1&amp;sn=66175725a3e726b6255cd54b074be082&amp;chksm=80b78b27b7c00231607b74ca0bab260a34c9236fd1915676847f1b68638cb6591fdfb86aafa9&amp;scene=21#wechat_redirect" target="_blank" style="white-space: normal;">让人欲罢不能的空指针（NullPointerException）</a></p><p style="white-space: normal;text-align: left;"><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650824633&amp;idx=1&amp;sn=66175725a3e726b6255cd54b074be082&amp;chksm=80b78b27b7c00231607b74ca0bab260a34c9236fd1915676847f1b68638cb6591fdfb86aafa9&amp;scene=21#wechat_redirect" target="_blank" style="white-space: normal;"></a><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650824333&amp;idx=1&amp;sn=b91e8885c6f4b29aae347c3d14987295&amp;chksm=80b78a13b7c003055d4d74a9fc8bf2bb75e08d660645ab65906af660c5396f30415e901322e6&amp;scene=21#wechat_redirect" target="_blank" style="white-space: normal;">还记得如何将你的程序放到桌面吗？</a></p><p style="white-space: normal;text-align: left;"><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650824633&amp;idx=1&amp;sn=66175725a3e726b6255cd54b074be082&amp;chksm=80b78b27b7c00231607b74ca0bab260a34c9236fd1915676847f1b68638cb6591fdfb86aafa9&amp;scene=21#wechat_redirect" target="_blank" style="white-space: normal;"></a><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650824333&amp;idx=1&amp;sn=b91e8885c6f4b29aae347c3d14987295&amp;chksm=80b78a13b7c003055d4d74a9fc8bf2bb75e08d660645ab65906af660c5396f30415e901322e6&amp;scene=21#wechat_redirect" target="_blank" style="white-space: normal;"></a><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650824287&amp;idx=1&amp;sn=830daedfe1b48957e3e7300f9e538650&amp;chksm=80b78ac1b7c003d713fb34dfdc6d82952f4086ec4881f819b505a3defecd9e8cbc19f70cc4ea&amp;scene=21#wechat_redirect" target="_blank" style="white-space: normal;">谈谈Sdk迭代开发设计需要考虑的方面</a></p><p style="white-space: normal;text-align: left;"><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650824633&amp;idx=1&amp;sn=66175725a3e726b6255cd54b074be082&amp;chksm=80b78b27b7c00231607b74ca0bab260a34c9236fd1915676847f1b68638cb6591fdfb86aafa9&amp;scene=21#wechat_redirect" target="_blank" style="white-space: normal;"></a><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650824333&amp;idx=1&amp;sn=b91e8885c6f4b29aae347c3d14987295&amp;chksm=80b78a13b7c003055d4d74a9fc8bf2bb75e08d660645ab65906af660c5396f30415e901322e6&amp;scene=21#wechat_redirect" target="_blank" style="white-space: normal;"></a><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650824287&amp;idx=1&amp;sn=830daedfe1b48957e3e7300f9e538650&amp;chksm=80b78ac1b7c003d713fb34dfdc6d82952f4086ec4881f819b505a3defecd9e8cbc19f70cc4ea&amp;scene=21#wechat_redirect" target="_blank" style="white-space: normal;"></a><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650824137&amp;idx=1&amp;sn=dad29505e1c1feeda538ad8641b36088&amp;chksm=80b78957b7c000412c7566da91f9e1c656a7110511029995c0de3a02cab3b70f362b637ecf11&amp;scene=21#wechat_redirect" target="_blank" style="white-space: normal;">Android多点触控最佳实践</a></p><p style="white-space: normal;text-align: left;"><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650824137&amp;idx=1&amp;sn=dad29505e1c1feeda538ad8641b36088&amp;chksm=80b78957b7c000412c7566da91f9e1c656a7110511029995c0de3a02cab3b70f362b637ecf11&amp;scene=21#wechat_redirect" target="_blank" style="white-space: normal;"></a><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650823729&amp;idx=1&amp;sn=623b1602594d36f9f341d569640499bf&amp;chksm=80b788afb7c001b9fde08409399527fc8c3fb5b4867e5c70661393a251354a751d3c47d9d0a3&amp;scene=21#wechat_redirect" target="_blank" style="white-space: normal;">Android安全防护</a></p><p style="white-space: normal;text-align: left;"><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650823729&amp;idx=1&amp;sn=623b1602594d36f9f341d569640499bf&amp;chksm=80b788afb7c001b9fde08409399527fc8c3fb5b4867e5c70661393a251354a751d3c47d9d0a3&amp;scene=21#wechat_redirect" target="_blank" style="white-space: normal;"></a><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650823538&amp;idx=1&amp;sn=1f86bde47890cfb478bf481ab917deb6&amp;chksm=80b78fecb7c006fa54d4f202bc01da509b0353c3c5358bab9c638de616e5b9524a59b366912a&amp;scene=21#wechat_redirect" target="_blank" style="white-space: normal;">如何优雅地管理Retrofit请求的生命周期</a></p><p style="white-space: normal;text-align: left;"><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650823538&amp;idx=1&amp;sn=1f86bde47890cfb478bf481ab917deb6&amp;chksm=80b78fecb7c006fa54d4f202bc01da509b0353c3c5358bab9c638de616e5b9524a59b366912a&amp;scene=21#wechat_redirect" target="_blank" style="white-space: normal;"></a><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650822799&amp;idx=1&amp;sn=7a0b3b21b313ea27b278586f2cef73d5&amp;chksm=80b78c11b7c00507afb20ae3582b7925d31566665f93b8551afa18890cd463e6e87b89fb01f8&amp;scene=21#wechat_redirect" target="_blank" style="white-space: normal;">Android双缓冲绘图技术分析</a></p><p style="white-space: normal;text-align: left;"><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650823538&amp;idx=1&amp;sn=1f86bde47890cfb478bf481ab917deb6&amp;chksm=80b78fecb7c006fa54d4f202bc01da509b0353c3c5358bab9c638de616e5b9524a59b366912a&amp;scene=21#wechat_redirect" target="_blank" style="white-space: normal;"></a><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650822799&amp;idx=1&amp;sn=7a0b3b21b313ea27b278586f2cef73d5&amp;chksm=80b78c11b7c00507afb20ae3582b7925d31566665f93b8551afa18890cd463e6e87b89fb01f8&amp;scene=21#wechat_redirect" target="_blank" style="white-space: normal;"></a><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650822789&amp;idx=1&amp;sn=aabf8b95e233a6bb19466e58fb90f812&amp;chksm=80b78c1bb7c0050da725cb947e0ae3a657e74dbae210bd3228eeaa1f7a990e466bc31b25c0d0&amp;scene=21#wechat_redirect" target="_blank" style="white-space: normal;">写给Android开发者的Java 8简单入门教程</a></p><p style="white-space: normal;text-align: left;"><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650822799&amp;idx=1&amp;sn=7a0b3b21b313ea27b278586f2cef73d5&amp;chksm=80b78c11b7c00507afb20ae3582b7925d31566665f93b8551afa18890cd463e6e87b89fb01f8&amp;scene=21#wechat_redirect" target="_blank" style="white-space: normal;"></a><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650822789&amp;idx=1&amp;sn=aabf8b95e233a6bb19466e58fb90f812&amp;chksm=80b78c1bb7c0050da725cb947e0ae3a657e74dbae210bd3228eeaa1f7a990e466bc31b25c0d0&amp;scene=21#wechat_redirect" target="_blank" style="white-space: normal;"></a><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650822379&amp;idx=1&amp;sn=8dce68bad2a32ebd001e99fcc3a18290&amp;chksm=80b78275b7c00b63610bc43817e2cc8c84844732a294fb06ff5d1d8f993a4ac6bea6d8d9527d&amp;scene=21#wechat_redirect" target="_blank" style="white-space: normal;">Android自定义键盘之汉字键盘</a></p><p style="white-space: normal;text-align: left;"><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650822379&amp;idx=1&amp;sn=8dce68bad2a32ebd001e99fcc3a18290&amp;chksm=80b78275b7c00b63610bc43817e2cc8c84844732a294fb06ff5d1d8f993a4ac6bea6d8d9527d&amp;scene=21#wechat_redirect" target="_blank" style="white-space: normal;"></a><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650824858&amp;idx=1&amp;sn=7ebead3db1b274e77a0bcafe806b49bc&amp;chksm=80b7b404b7c03d1225b46ee2098b1353d7ad7d8472e3faa93d41eb909eb7a09b1915458174d8&amp;scene=21#wechat_redirect" target="_blank">怎么用Kotlin去提高生产力：Kotlin Tips</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>码个蛋2017年精选文章集合</title>
    <link href="/2018/02/09/%E7%A0%81%E4%B8%AA%E8%9B%8B2017%E5%B9%B4%E7%B2%BE%E9%80%89%E6%96%87%E7%AB%A0%E9%9B%86%E5%90%88/"/>
    <url>/2018/02/09/%E7%A0%81%E4%B8%AA%E8%9B%8B2017%E5%B9%B4%E7%B2%BE%E9%80%89%E6%96%87%E7%AB%A0%E9%9B%86%E5%90%88/</url>
    
    <content type="html"><![CDATA[<p>码个蛋从2017年02月20日推送第1篇文章,一年过去了已累积推文近300篇文章，本文为2017年度精选，共计200篇，按照类别整理便于读者主题阅读。</p><a id="more"></a><h2 id="Android"><a href="#Android" class="headerlink" title="Android"></a>Android</h2><h3 id="自定义view"><a href="#自定义view" class="headerlink" title="自定义view"></a>自定义view</h3><p style="text-align: left;"><a href="http://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&amp;mid=2247486078&amp;idx=1&amp;sn=6c639d878b57023904b97973c4ad5f81&amp;chksm=96cdab33a1ba222546290da987fa8e3d37256fce86715bf32578d5f4d8082a9610ea5874a08e&amp;scene=21#wechat_redirect" target="_blank">教你打造绚丽多彩的TextView</a></p><p style="text-align: left;"><a href="http://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&amp;mid=2247485954&amp;idx=1&amp;sn=7183334de913cb70e15b40fa276af03b&amp;chksm=96cdab4fa1ba2259d8f835861d2b55c669fbbb4ffda81f4fa1db48b630b67f0653baade80f1f&amp;scene=21#wechat_redirect" target="_blank">仿百度外卖的酷炫水波纹效果</a></p><p style="text-align: left;"><a href="http://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&amp;mid=2247486324&amp;idx=1&amp;sn=45e7a803b180a09c3a85a90eb4e84a5b&amp;chksm=96cdaa39a1ba232f8fab1ac01a64bf5ca708b544775d51b1677ac415108b2c2f1a1d1106a768&amp;scene=21#wechat_redirect" target="_blank">教你打造炫酷的悬浮音乐盒</a></p><p style="text-align: left;"><a href="http://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&amp;mid=2247486318&amp;idx=1&amp;sn=21106b012a194f248f27e1498d236c37&amp;chksm=96cdaa23a1ba2335d193e364120a4b9a70ec0b73f2c1714443b50b13b549f57ea11c79101992&amp;scene=21#wechat_redirect" target="_blank">炫酷ViewPager指示器效果（全面解析）</a></p><p style="text-align: left;"><a href="http://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&amp;mid=2247486092&amp;idx=1&amp;sn=5c68fc64119a9cbbe6326121d0d8d6b9&amp;chksm=96cdabc1a1ba22d7c890f0ad58731f0d0cb0a89048091f636bffdd681f1ef6cf8a6930fd3d47&amp;scene=21#wechat_redirect" target="_blank">网易云音乐唱片机效果</a></p><p style="text-align: left;"><a href="http://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&amp;mid=2247485861&amp;idx=1&amp;sn=4b17dc1e4c6cbd75522b7468a39b3222&amp;chksm=96cda8e8a1ba21fe3bd516133133432a447cb2ef515c40bc9dade108867ef0bc6e766ae50b99&amp;scene=21#wechat_redirect" target="_blank">Android实用View系列之SuperButton</a><br></p><p style="text-align: left;"><a href="http://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&amp;mid=2247485843&amp;idx=1&amp;sn=d5de05fc0240be0527de8d69b1616c6f&amp;chksm=96cda8dea1ba21c8ba3c620acc07c2ef1e2afc619928587ac8201958af1eb4d3568f6516e4ac&amp;scene=21#wechat_redirect" target="_blank">自定义View之渐变圆环进度条</a></p><p style="text-align: left;"><a href="http://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&amp;mid=2247485476&amp;idx=1&amp;sn=f6d28e484e574fc9196f1aece5017827&amp;chksm=96cda969a1ba207f99a37ae36c76c32cf7d276382be7bb58949187a3596be202407506bfb066&amp;scene=21#wechat_redirect" target="_blank">使用TabLayout看这篇就够了</a></p><p style="text-align: left;"><a href="http://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&amp;mid=2247485101&amp;idx=1&amp;sn=498414e2ea8a98f4021bba168d0c2832&amp;chksm=96cda7e0a1ba2ef6e683c11988f0b642c6ff2c8fa83029977c1e6a2a95c3b55f11ada72dfd81&amp;scene=21#wechat_redirect" target="_blank">Android实用View:水波动画效果</a></p><p style="text-align: left;"><a href="http://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&amp;mid=2247484908&amp;idx=1&amp;sn=13349c39e5e2e257edad49c23f5888cc&amp;chksm=96cda4a1a1ba2db7963837960044fade1da4e3c5438bc16455bc800df4af62a7d319f4164fc5&amp;scene=21#wechat_redirect" target="_blank">Android实用：TextView实现打印机效果</a></p><p style="text-align: left;"><a href="http://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&amp;mid=2247484321&amp;idx=1&amp;sn=caa96cc1c948ea61e74011e0f2ed7815&amp;chksm=96cda2eca1ba2bfac42018e1683e8327918f785b7d6dbcb65712b321ccb0531b614eb7521d42&amp;scene=21#wechat_redirect" target="_blank">Android实用View：仿微信支付密码输入框</a></p><p style="text-align: left;"><a href="http://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&amp;mid=2247484516&amp;idx=1&amp;sn=1f31642399dd90bda5afa8664150a2d5&amp;chksm=96cda529a1ba2c3fa47d0fb0e8328a28480c7496e551363d05306c56aadfca8df49baf109db4&amp;scene=21#wechat_redirect" target="_blank">沉浸式管理：让你的APP更优雅</a></p><p style="text-align: left;"><a href="http://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&amp;mid=2247483927&amp;idx=1&amp;sn=8bc43ab9e0eb9b76078880ba08c7958c&amp;chksm=96cda35aa1ba2a4c7f176cf5eddcea6ff5eba52e9b11915ce848b1e4f3bdb02096717e2a27a3&amp;scene=21#wechat_redirect" target="_blank">Android美团首页分类按钮</a></p><p style="text-align: left;"><a href="http://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&amp;mid=2247484210&amp;idx=1&amp;sn=5551259f0152cb570f96e5764930706e&amp;chksm=96cda27fa1ba2b6959df45699e84a0cc3c741b64008e1e365d13ed35a06ede14287502bf0ac2&amp;scene=21#wechat_redirect" target="_blank">Android自定义动画酷炫的提交按钮</a></p><p style="text-align: left;"><a href="http://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&amp;mid=2247484014&amp;idx=1&amp;sn=1aa81b516d244ac6c1138b6e6f0e1786&amp;chksm=96cda323a1ba2a3581d8a2f5707c3e2bc305959bf37f6b3f5ad8a88650b42a67851abf8c2c60&amp;scene=21#wechat_redirect" target="_blank">Android实现毛玻璃效果(高斯模糊)效果</a></p><p style="text-align: left;"><a href="http://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&amp;mid=2247484408&amp;idx=1&amp;sn=cd077ffe234b15c6c8a193def53fc963&amp;chksm=96cda2b5a1ba2ba387c910df7b864580f6f5858691bcecb46afe2b8a91684ab804879f01d905&amp;scene=21#wechat_redirect" target="_blank">Android灵魂画家的18种混合模式</a></p><p style="text-align: left;"><a href="http://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&amp;mid=2247486503&amp;idx=1&amp;sn=c3db7d1db5b5ac1512e5303a820a1eff&amp;chksm=96cdad6aa1ba247caad4e71e2e6c01213731d0c398a2ab8f7504459222c0d2161f6023448757&amp;scene=21#wechat_redirect" target="_blank">仿触手直播首页切换效果&nbsp;</a></p><p style="text-align: left;"><a href="http://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&amp;mid=2247486926&amp;idx=1&amp;sn=fc8b3f9aa58fb7f4f1733680dd691899&amp;chksm=96cdac83a1ba2595067d28422771a333ae398852feefd27b62be058caa49309a7b7ea9bc1528&amp;scene=21#wechat_redirect" target="_blank">多功能流式布局与网格布局控件</a>&nbsp; &nbsp;&nbsp;</p><p style="text-align: left;"><a href="http://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&amp;mid=2247487876&amp;idx=1&amp;sn=7406cceabe26925307dae53a881c41aa&amp;chksm=96cdb0c9a1ba39df9f3387dcc5b3dc1a0a74dd1ebb109a3a7854c1b0008ac092f992e79f8355&amp;scene=21#wechat_redirect" target="_blank">Android 仿微信微博的展开全文功能&nbsp; &nbsp;&nbsp;</a></p><p style="text-align: left;"><a href="http://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&amp;mid=2247487946&amp;idx=1&amp;sn=37a5dbc4089e171a1e6f2b821abf7a6f&amp;chksm=96cdb087a1ba3991a6b8340b83b9e0b5f4294804f1dd18df4106e51e99f3a72b6efa10130ec7&amp;scene=21#wechat_redirect" target="_blank">你还在为EditText内容判断而烦恼？&nbsp;&nbsp;</a></p><p style="text-align: left;"><a href="http://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&amp;mid=2247488058&amp;idx=1&amp;sn=49e0bfc4a6cba601842f587df1f79aba&amp;chksm=96cdb377a1ba3a6145ede28daf6b64fb52b65818c2381e96929ce7728654adfa160b1bb4f236&amp;scene=21#wechat_redirect" target="_blank">如何实现超萌动感小炸弹？</a>&nbsp; &nbsp;&nbsp;</p><p style="text-align: left;"><a href="http://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&amp;mid=2247488057&amp;idx=2&amp;sn=d67b8d9c7da04e4efdec4084efe2098f&amp;chksm=96cdb374a1ba3a625d34993ee8c65adcfb1139f9b1a607c8c8b76710958915eab540e3aec610&amp;scene=21#wechat_redirect" target="_blank">如何实现超萌动感小太阳？</a>&nbsp;</p><p style="text-align: left;"><a href="http://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&amp;mid=2247488323&amp;idx=1&amp;sn=8dbf3c70513e6d12af9f08021477419a&amp;chksm=96cdb20ea1ba3b18d5baa46089978be11c54417ead90cd66378cea7bbb0e9321da809b7c890f&amp;scene=21#wechat_redirect" target="_blank">自定义三级联动地址选择器</a>&nbsp; &nbsp;</p><p style="text-align: left;"><a href="http://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&amp;mid=2247488970&amp;idx=1&amp;sn=26728039e505a5cef9c35a53e9350480&amp;chksm=96cdb487a1ba3d91df306573312e581c2b01877581d96575e07d3757ad7ba9e21e9c57b8c721&amp;scene=21#wechat_redirect" target="_blank">仿支付宝芝麻信用分仪表盘效果</a>&nbsp;&nbsp;</p><p style="text-align: left;"><a href="http://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&amp;mid=2247489710&amp;idx=1&amp;sn=6037872bd8147782b2d04e5c4125b0e0&amp;chksm=96cdb9e3a1ba30f5046201d29a028608afe6c2634cf209ca35e2e5f3d252dedf010355028744&amp;scene=21#wechat_redirect" target="_blank">Android 自定义Switch开关按钮的样式</a>&nbsp; &nbsp;&nbsp;</p><p style="text-align: left;"><a href="http://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&amp;mid=2247489596&amp;idx=1&amp;sn=e1baa364dfc9bcda26eca5c5db99d029&amp;chksm=96cdb971a1ba3067626bdca1e259284d7ff2c81a0dd6c5dea0a247e25dc13e88ede9ec684410&amp;scene=21#wechat_redirect" target="_blank">Android自定义控件 倒计时</a>&nbsp; &nbsp;</p><p style="text-align: left;"><a href="http://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&amp;mid=2247487400&amp;idx=1&amp;sn=85b060a3503280623b1b68205e928d5b&amp;chksm=96cdaee5a1ba27f301723aa5b8b7890c93f14cca2bd9df5fdab48046eee807a830a454dffd0d&amp;scene=21#wechat_redirect" target="_blank">仿iOS底部弹框实现及分析</a>&nbsp; &nbsp;</p><p style="text-align: left;"><a href="http://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&amp;mid=2247487074&amp;idx=1&amp;sn=5c27a2282d6e1d146fd6a7da1af7d255&amp;chksm=96cdaf2fa1ba26390552ec361b89fc3db769891d5cb23eda158e5db9981207bb914d1f3d5c44&amp;scene=21#wechat_redirect" target="_blank">仿iOS版ofo（小黄车）首页菜单动画</a> &nbsp;</p><p style="text-align: left;"><a href="http://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&amp;mid=2247486976&amp;idx=1&amp;sn=2567fc6ba788e064ad7f355bd4df4df7&amp;chksm=96cdaf4da1ba265bd4f394de8d7c32d3ef94ce35b25da2eba3c52d786def2bdde0fc5d4f7a6d&amp;scene=21#wechat_redirect" target="_blank">史上最详细仿QQ消息拖拽粘性效果&nbsp;</a> &nbsp;</p><p style="text-align: left;"><a href="http://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&amp;mid=2247486770&amp;idx=1&amp;sn=e1d42dfeed6b924512f037967a0b4a6d&amp;chksm=96cdac7fa1ba2569240483f9350c96a1a539c4876645a47cac18753bc920c84693e89a2abfd4&amp;scene=21#wechat_redirect" target="_blank">Android图文混排实现方式详解</a>&nbsp;&nbsp;</p><h3 id="热门技术"><a href="#热门技术" class="headerlink" title="热门技术"></a>热门技术</h3><p style="text-align: left;"><a href="http://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&amp;mid=2247489519&amp;idx=1&amp;sn=e2130b149ec21f76898acfd88cb468a0&amp;chksm=96cdb6a2a1ba3fb4a51462b030c98354aff2dc958896f0455e6cf7f876043c2b2d6dde21bd7e&amp;scene=21#wechat_redirect" target="_blank">Android 开发规范（完结版）</a></p><p style="color: rgb(255, 202, 0);font-size: 15px;letter-spacing: 0.5px;text-align: left;white-space: normal;background-color: rgb(255, 255, 255);"><a href="http://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&amp;mid=2247485002&amp;idx=1&amp;sn=e07f1949362946ee545079259b6b9014&amp;chksm=96cda707a1ba2e11da927e18c0500bcc9231a82e401069f06048f68b09392c3f332e7893f9a5&amp;scene=21#wechat_redirect" target="_blank">巧用Android多进程</a></p><p style="color: rgb(255, 202, 0);font-size: 15px;letter-spacing: 0.5px;text-align: left;white-space: normal;background-color: rgb(255, 255, 255);"><a href="http://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&amp;mid=2247485791&amp;idx=1&amp;sn=7cefb329021f119f4c91e7b5e65dd8f4&amp;chksm=96cda812a1ba21042760585dc2c12f745140692a1bd34366b1888bcae544be3ec1737ec69d62&amp;scene=21#wechat_redirect" target="_blank">Google I/O ‘17 新推出的物理动画库</a></p><p style="color: rgb(255, 202, 0);font-size: 15px;letter-spacing: 0.5px;text-align: left;white-space: normal;background-color: rgb(255, 255, 255);"><a href="http://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&amp;mid=2247485605&amp;idx=1&amp;sn=c3df77f766984df658191b7d6a5214d1&amp;chksm=96cda9e8a1ba20fedb3e93cf2e74d09702c7a172bf16a8161431992d9e7b7a9ec941702e6628&amp;scene=21#wechat_redirect" target="_blank">你的Android应用稳定吗？</a></p><p style="color: rgb(255, 202, 0);font-size: 15px;letter-spacing: 0.5px;text-align: left;white-space: normal;background-color: rgb(255, 255, 255);"><a href="http://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&amp;mid=2247486804&amp;idx=1&amp;sn=664b30f6bdbd55f3b8be706a9a4fe092&amp;chksm=96cdac19a1ba250f6567e45d8495838e953dfd22d8eca309413535b4f192695dc7cca6deea6f&amp;scene=21#wechat_redirect" target="_blank">Android彻底组件化源码分析&nbsp; &nbsp;&nbsp;</a></p><p style="color: rgb(255, 202, 0);font-size: 15px;letter-spacing: 0.5px;text-align: left;white-space: normal;background-color: rgb(255, 255, 255);"><a href="http://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&amp;mid=2247486803&amp;idx=1&amp;sn=884fed93567022e3ac9731df6fc4660a&amp;chksm=96cdac1ea1ba2508aebd69c2b5ae28ff271032806f34a42b2bf5928ea79106bcc71749567714&amp;scene=21#wechat_redirect" target="_blank">Android彻底组件化方案实践&nbsp; &nbsp;&nbsp;&nbsp;</a></p><p style="color: rgb(255, 202, 0);font-size: 15px;letter-spacing: 0.5px;text-align: left;white-space: normal;background-color: rgb(255, 255, 255);"><a href="http://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&amp;mid=2247486927&amp;idx=1&amp;sn=29e7439c220387f34df232f04ab283ac&amp;chksm=96cdac82a1ba2594182dc87498d621bc884c665b44ebe9271cbee1861aaf64d7641cae50b5d2&amp;scene=21#wechat_redirect" target="_blank">2017 Android插件化框架总结&nbsp; &nbsp;&nbsp;</a></p><p style="color: rgb(255, 202, 0);font-size: 15px;letter-spacing: 0.5px;text-align: left;white-space: normal;background-color: rgb(255, 255, 255);"><a href="http://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&amp;mid=2247487177&amp;idx=1&amp;sn=3bdf6a7e1230b30fc29940dc597be514&amp;chksm=96cdaf84a1ba269210d1213089d4a9e4ec2ffccd3a363945f2cd211760243cdcb76e98cbf406&amp;scene=21#wechat_redirect" target="_blank">是什么造成你的应用内存泄漏？</a></p><p style="color: rgb(255, 202, 0);font-size: 15px;letter-spacing: 0.5px;text-align: left;white-space: normal;background-color: rgb(255, 255, 255);"><a href="http://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&amp;mid=2247486266&amp;idx=1&amp;sn=80380a7f5163e721c1edfe8542922b3d&amp;chksm=96cdaa77a1ba2361e6ed514cd9cb7ff0b80249c7e0fcb6fbfd1d9784b8dc25e763fd3127d6c4&amp;scene=21#wechat_redirect" target="_blank">Glide：最新版使用指南（含新特性）</a></p><p style="text-align: left;"><a href="http://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&amp;mid=2247484091&amp;idx=1&amp;sn=222d15aa0ce04a00b593a5b1b88948bb&amp;chksm=96cda3f6a1ba2ae029f821b4fba5eb2c23cdee5ce075cde7509cbad46e92809f8ceb8920f8ef&amp;scene=21#wechat_redirect" target="_blank">重识OkHttp：从深入了解到源码分析</a></p><p style="text-align: left;"><a href="http://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&amp;mid=2247483707&amp;idx=1&amp;sn=232459663871c699d570a77f753ab7cd&amp;chksm=96cda076a1ba29600b089ae11a249752812ac8c4b1fbed9d5c8671b992361453414c7667a9ec&amp;scene=21#wechat_redirect" target="_blank">Android网络请求改造之路</a></p><p style="text-align: left;"><a href="http://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&amp;mid=2247483668&amp;idx=1&amp;sn=ff2612a607378053cbe8476e94af5a4f&amp;chksm=96cda059a1ba294f715cc3b126541127bee9da877c7f2ad982e82c85f5e35e6a21a5934994d7&amp;scene=21#wechat_redirect" target="_blank">Gradle 构建:从入门到实战</a><br></p><p style="text-align: left;"><a href="http://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&amp;mid=2247484543&amp;idx=1&amp;sn=e4b34982a2c193b384e73e15d741a76e&amp;chksm=96cda532a1ba2c24dc4356cb4928d7e95b36858df0abe2be915aff547c76b327a5623251f2df&amp;scene=21#wechat_redirect" target="_blank">Android动画实现详解</a></p><p style="text-align: left;"><a href="http://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&amp;mid=2247486202&amp;idx=1&amp;sn=49b04f0ccacef9324dc4d8184c122cf4&amp;chksm=96cdabb7a1ba22a153dc71a0872fc46f63cab1c60224088ab00cf798ec1d2dbf166032a491f2&amp;scene=21#wechat_redirect" target="_blank">2个函数终结状态栏6个疑难杂症</a></p><p style="text-align: left;"><a href="http://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&amp;mid=2247486145&amp;idx=1&amp;sn=ce9570665adc1609094b5d6e8c780447&amp;chksm=96cdab8ca1ba229a5fb2e1f0894c968769c2093527ba619f1783feca9c63de948b4aaf79d09d&amp;scene=21#wechat_redirect" target="_blank">仿网易云音乐的主题换肤</a></p><p style="text-align: left;"><a href="http://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&amp;mid=2247486019&amp;idx=1&amp;sn=a65e5023bca143fc1406194b107e7aae&amp;chksm=96cdab0ea1ba22185753888c2a181fbd781a7c5bc1f984a5798377ac89c9d4b89da6f9adf6fd&amp;scene=21#wechat_redirect" target="_blank">Android 安全逆向:篡改你的位置信息</a></p><p style="text-align: left;"><a href="http://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&amp;mid=2247485739&amp;idx=1&amp;sn=751318824da6b00507c3023207476f84&amp;chksm=96cda866a1ba2170d2ac32d93147a4302ab3e083e96d55966d7e7f545564e02463d4c5083a92&amp;scene=21#wechat_redirect" target="_blank">Retrofit 2.0 使用教程（含实例讲解）</a></p><p style="text-align: left;"><a href="http://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&amp;mid=2247485185&amp;idx=1&amp;sn=3809c66d91e92bb6ae5506a45d4d09f8&amp;chksm=96cda64ca1ba2f5a842b60b78733ee54a088c380dfb296a9a756fe01e956fb2a21469a48ec1d&amp;scene=21#wechat_redirect" target="_blank">Android_其他语言交互篇</a></p><p style="text-align: left;"><a href="http://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&amp;mid=2247486465&amp;idx=1&amp;sn=7878c347c8617f0d9a9f1f789eec7a03&amp;chksm=96cdad4ca1ba245a36184f2847a3cb49e95b91b05aa9d55f27a870974d7a8b83ff76b2d785ed&amp;scene=21#wechat_redirect" target="_blank">如何实现日夜间主题切换功能？</a></p><p style="text-align: left;"><a href="http://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&amp;mid=2247486605&amp;idx=1&amp;sn=ac80b25046438a5dce28193c4810c04b&amp;chksm=96cdadc0a1ba24d6955a9e8160582c004e2d99a6963ac20316e8acfd2ef8f01c87f56caebe43&amp;scene=21#wechat_redirect" target="_blank">物联网来了，你还不会蓝牙开发？&nbsp;</a> &nbsp;&nbsp;</p><p style="text-align: left;"><a href="http://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&amp;mid=2247486573&amp;idx=1&amp;sn=df5719345a413fe8de4c15e30085d23c&amp;chksm=96cdad20a1ba2436aa696b6d1918cc6473f37ecaa10eb82f8271cb6ab7efcc84ce57332a7164&amp;scene=21#wechat_redirect" target="_blank">这个列表实现很复杂？不存在&nbsp; &nbsp;</a>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</p><p style="text-align: left;"><a href="http://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&amp;mid=2247487150&amp;idx=1&amp;sn=2f25036ea03e4599d60aa9fc57e1a55e&amp;chksm=96cdafe3a1ba26f5c25e0f309df042f5010a52384f12354b16b56a75e48bd4dbff51ec7c619d&amp;scene=21#wechat_redirect" target="_blank">手动找Bug?快用自动化测试提高效率吧！</a>&nbsp;&nbsp;</p><p style="text-align: left;"><a href="http://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&amp;mid=2247487125&amp;idx=1&amp;sn=b3cdac76e37bc4bb234a53cd5f03b527&amp;chksm=96cdafd8a1ba26ceae06a75ace639f9dcd6bd1bec329536ceea6582c6e356a0f9a464f4ddb44&amp;scene=21#wechat_redirect" target="_blank">Android 4.4.2引入的超炫动画库&nbsp; &nbsp;&nbsp;</a></p><p style="text-align: left;"><a href="http://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&amp;mid=2247487254&amp;idx=1&amp;sn=d1ade5026b2fe1ca232b59840ad52ce8&amp;chksm=96cdae5ba1ba274d49e813783ed9f51b7695ec2ce7f24d6a9075a20be517c22d59c18efce34e&amp;scene=21#wechat_redirect" target="_blank">Material Design 过渡动画实现及流程分析</a></p><p style="text-align: left;"><a href="http://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&amp;mid=2247487974&amp;idx=1&amp;sn=eeae43cbbf99a2ad3c38ccf3b0bef097&amp;chksm=96cdb0aba1ba39bd9279748efa67ef8fe2c3a7601d9083d983f9f8cc7e61d9777a73b56401f8&amp;scene=21#wechat_redirect" target="_blank">2017年的25个新Android开源库&nbsp; &nbsp;&nbsp;</a></p><p style="text-align: left;"><a href="http://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&amp;mid=2247487886&amp;idx=1&amp;sn=6fbe4d971e873ee351aef213eedba0ae&amp;chksm=96cdb0c3a1ba39d5a4ed82973ff326675a2cd32516e4465cf276dec2029fc6458e4539a26833&amp;scene=21#wechat_redirect" target="_blank">Android启动页黑屏及最优解决方案&nbsp; &nbsp;&nbsp;</a></p><p style="text-align: left;"><a href="http://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&amp;mid=2247487786&amp;idx=1&amp;sn=a6b647885f2eb5cb7202c378502fb761&amp;chksm=96cdb067a1ba3971a6b6cb29e505f2e65b7329d685e98b5171ff6295e3e44de28ba3f61e0396&amp;scene=21#wechat_redirect" target="_blank">Android中的注解与反射你知道吗？&nbsp; &nbsp;&nbsp;</a></p><p style="text-align: left;"><a href="http://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&amp;mid=2247487635&amp;idx=1&amp;sn=407576fc688f4bef4bb689fd5c025e33&amp;chksm=96cdb1dea1ba38c890fb00d652ace4787f3627b5c977a074a33a7195c8337f81643bf12f3f6b&amp;scene=21#wechat_redirect" target="_blank">如何简单高效的学会Smali语法?&nbsp; &nbsp;&nbsp;</a></p><p style="text-align: left;"><a href="http://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&amp;mid=2247487574&amp;idx=1&amp;sn=4e5a0aef6366ae5c809a4abc448fc209&amp;chksm=96cdb11ba1ba380d564971ba18b8a397466620200675515fa3f4bed8dcd3267f4e9d9f02469d&amp;scene=21#wechat_redirect" target="_blank">Android Gradle 使用大全&nbsp; &nbsp;&nbsp;</a></p><p style="text-align: left;"><a href="http://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&amp;mid=2247488220&amp;idx=1&amp;sn=834f2b928d2852ebdc4db1439ee0e08b&amp;chksm=96cdb391a1ba3a87c2bc4e0bf0921acd28469be06de9bb14f63002dfa7eeab5fe1a4e21fac15&amp;scene=21#wechat_redirect" target="_blank">Android与Python爱之初体验&nbsp; &nbsp;&nbsp;</a></p><p style="text-align: left;"><a href="http://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&amp;mid=2247488201&amp;idx=1&amp;sn=bffe823d4536b86a8135448c04f4556c&amp;chksm=96cdb384a1ba3a925d8bcb907ee1d01b5984a5d06cf8d78ca06d97d286e500088e14a30b6ea8&amp;scene=21#wechat_redirect" target="_blank">探讨Android6.0及以上系统保活</a></p><p style="text-align: left;"><a href="http://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&amp;mid=2247488175&amp;idx=1&amp;sn=b8d044fdd6b534b685e84a8fdf25398b&amp;chksm=96cdb3e2a1ba3af427f5ed5a94951521eec938a358c1e37b4e8f53f9e61f24b77e15012117cd&amp;scene=21#wechat_redirect" target="_blank">Android性能优化之列表卡顿</a></p><p style="text-align: left;"><a href="http://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&amp;mid=2247488151&amp;idx=1&amp;sn=f329687505b416cd898c843ca558b693&amp;chksm=96cdb3daa1ba3acc19b083824005fc9e5b0e5b01486fa8da052804d01ad9124afac4df4884f1&amp;scene=21#wechat_redirect" target="_blank">Jenkins+Github+蒲公英/Fir.im+邮件通知</a></p><p style="text-align: left;"><a href="http://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&amp;mid=2247488089&amp;idx=1&amp;sn=9fe1697810c3727d501bfb8c93ed3973&amp;chksm=96cdb314a1ba3a026fc0d2686ca14174d4288193f1cafec2c16e7a1a356bccf336e6f3d70b7d&amp;scene=21#wechat_redirect" target="_blank">百度地图街景实现，看这篇就够了&nbsp; &nbsp;&nbsp;</a></p><p style="text-align: left;"><a href="http://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&amp;mid=2247488311&amp;idx=1&amp;sn=e9fa0f336b62832b6b65fc62ade6c770&amp;chksm=96cdb27aa1ba3b6ced3848b3ab7974c248dd5498c4dd94655174477724d3dc7cbd4118e25e8b&amp;scene=21#wechat_redirect" target="_blank">关于Android中图片大小、内存占用的研究与分析&nbsp; &nbsp;&nbsp;</a></p><p style="text-align: left;"><a href="http://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&amp;mid=2247488456&amp;idx=1&amp;sn=4136c0a098ca71583534fb203738accc&amp;chksm=96cdb285a1ba3b93ab39b5e4f06fcb31dc4a7974a859caeae47dfd812cb53f88614936c63e2e&amp;scene=21#wechat_redirect" target="_blank">Activity、View、Window的理解</a></p><p style="text-align: left;"><a href="http://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&amp;mid=2247488433&amp;idx=1&amp;sn=f424f31a9d721281df423fb67fbc211c&amp;chksm=96cdb2fca1ba3beaf5530e48401173640e763be5e7d7963f4351e163e9a5f250da143e1299a4&amp;scene=21#wechat_redirect" target="_blank">Android打包之多版本、多环境、多渠道&nbsp; &nbsp;&nbsp;</a></p><p style="text-align: left;"><a href="http://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&amp;mid=2247488667&amp;idx=1&amp;sn=9f17d205c9deff7b571c3280ca2b1e10&amp;chksm=96cdb5d6a1ba3cc0d70f61d5883123e84e992b9e1f2139aa909c3f3d517ece4bb363d00a1c74&amp;scene=21#wechat_redirect" target="_blank">图解ConcurrentHashMap&nbsp; &nbsp;&nbsp;</a></p><p style="text-align: left;"><a href="http://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&amp;mid=2247488633&amp;idx=1&amp;sn=67178270527b135eb9bffab88da3f727&amp;chksm=96cdb534a1ba3c221143548960c377dd47ce068311a5f84316dee4332afa37b59130e9ab1341&amp;scene=21#wechat_redirect" target="_blank">Android性能优化之如何避免Overdraw&nbsp; &nbsp;</a>&nbsp;</p><p style="text-align: left;"><a href="http://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&amp;mid=2247488786&amp;idx=1&amp;sn=9267a368eb61a36c0a4980e05f86302e&amp;chksm=96cdb45fa1ba3d49f45598e44af6e28ef755699eec0f289d700f1894de649347db0677d01513&amp;scene=21#wechat_redirect" target="_blank">ConstraintLayout 详细使用教程&nbsp; &nbsp;&nbsp;</a></p><p style="text-align: left;"><a href="http://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&amp;mid=2247488730&amp;idx=1&amp;sn=5c5b7f9f42c95933680769ef3636759d&amp;chksm=96cdb597a1ba3c811d4e773673a69e84cf0371d44427fca7133bc25fff4b804aab0aea0db11f&amp;scene=21#wechat_redirect" target="_blank">你不知道的App启动优化方案&nbsp;</a> &nbsp;&nbsp;</p><p style="text-align: left;"><a href="http://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&amp;mid=2247489401&amp;idx=1&amp;sn=9eecc9faa9d2dc0ce8bae6d7c45885a9&amp;chksm=96cdb634a1ba3f227af9e3f995da5c305bb23b55e22f5b4cdf0bd996998407910869b30e5d5e&amp;scene=21#wechat_redirect" target="_blank">用Lottie把启动界面动起来&nbsp; &nbsp;&nbsp;</a>&nbsp;</p><p style="text-align: left;"><a href="http://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&amp;mid=2247484179&amp;idx=1&amp;sn=aef8a3fdf69547c666aa79849ff3fe14&amp;chksm=96cda25ea1ba2b48493130a07011211964f92007ee8f07942c10ab74e8242c36b6220a959a02&amp;scene=21#wechat_redirect" target="_blank">Kotlin初探</a></p><p style="text-align: left;"><a href="http://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&amp;mid=2247483767&amp;idx=1&amp;sn=c10f3e90186d84cd10b6f01a225dd681&amp;chksm=96cda03aa1ba292c2d147233eefcaf9e623d408e7ea72bc2eb7a94ea46cf21f8dc3ffcb288cf&amp;scene=21#wechat_redirect" target="_blank">BaseActivity的封装思想</a></p><p style="text-align: left;"><a href="http://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&amp;mid=2247483959&amp;idx=1&amp;sn=8f21abbc42b36121c963c2f70338384b&amp;chksm=96cda37aa1ba2a6cf906724a327d7863805757339e35430f98c4b95d518e89513e1bd8d13c87&amp;scene=21#wechat_redirect" target="_blank">你知道几种单例模式？</a></p><p style="text-align: left;"><a href="http://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&amp;mid=2247485810&amp;idx=1&amp;sn=70cd8756e349131ca4ba69849619afdc&amp;chksm=96cda83fa1ba21292bcb1a4b6d85d54c8368b1f549b1c78180eb7a68d4bc9258d98575c4a629&amp;scene=21#wechat_redirect" target="_blank">RxJava+Retrofit 如何精简封装？</a></p><p style="text-align: left;"><a href="http://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&amp;mid=2247485590&amp;idx=1&amp;sn=0c63e45be06cb32b34610222d3661410&amp;chksm=96cda9dba1ba20cd40aa2131374f15f6167972fc59764ea0544250d6dfd2e625c5bb885fa3f1&amp;scene=21#wechat_redirect" target="_blank">App组件化与业务拆分那些事</a></p><p style="text-align: left;"><a href="http://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&amp;mid=2247485140&amp;idx=1&amp;sn=43f8e81585cc6ea906fa0641fbefd45b&amp;chksm=96cda799a1ba2e8f5ca2f6d47b049a9e0db6faeb56f0612c77e12d8e3d72bb121ac659dceda3&amp;scene=21#wechat_redirect" target="_blank">采用Gson解析含有多种JsonObject</a></p><p style="text-align: left;"><a href="http://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&amp;mid=2247483835&amp;idx=1&amp;sn=68eabd1942b04c7bff8f8cfa63378996&amp;chksm=96cda0f6a1ba29e0ced05a08f2468fd3eaa7785f3cb5821150aae3401f06a6511b7292665664&amp;scene=21#wechat_redirect" target="_blank">一文让你明白Java字节码</a></p><p style="text-align: left;"><a href="http://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&amp;mid=2247483903&amp;idx=1&amp;sn=c20d3172052bd7db9a1ad6a95f112bc9&amp;chksm=96cda0b2a1ba29a4cc9912cb1bf8a955f97ee45a7b8db48e384f1694ddbabbd4d5e7fa90f880&amp;scene=21#wechat_redirect" target="_blank">深入理解Java类加载机制</a></p><p style="text-align: left;"><a href="http://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&amp;mid=2247484614&amp;idx=1&amp;sn=5580b6d316846deb1153b4aefdedddb4&amp;chksm=96cda58ba1ba2c9d23838a5f1e4446fd00cb8f2b3db65287fb673d1abed9b473a65e2aaf6c20&amp;scene=21#wechat_redirect" target="_blank">你知道Thread线程是如何运作的吗？</a></p><p style="text-align: left;"><a href="http://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&amp;mid=2247483998&amp;idx=1&amp;sn=03cb1942533247ac23876448fdf1b39a&amp;chksm=96cda313a1ba2a050f8cc2325e36b468f620d3d167d9f0dbc3108127c5ba16d14dc83cabc3c6&amp;scene=21#wechat_redirect" target="_blank">Android开发之Handler的前世今生</a></p><p style="text-align: left;"><a href="http://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&amp;mid=2247485679&amp;idx=1&amp;sn=cdf5785ae5a63af9b7eec9f068ea4b96&amp;chksm=96cda9a2a1ba20b4f91db6985c24696ec1ad710f06d4d9692e35cec25caf19b2c1bbc76111e6&amp;scene=21#wechat_redirect" target="_blank">Android：深入剖析 Retrofit 2.0 源码</a><br></p><p style="text-align: left;"><a href="http://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&amp;mid=2247485540&amp;idx=1&amp;sn=9bc2ff88f96e55e34e804077456dc211&amp;chksm=96cda929a1ba203f39a6918367a3e1a423db54086d2b6c3a18c65400f7b521dcd101bc2f386d&amp;scene=21#wechat_redirect" target="_blank">AsyncTask? AsyncTask串行and并行？</a></p><p style="text-align: left;"><a href="http://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&amp;mid=2247484203&amp;idx=1&amp;sn=6c98747e0c2d3bd4a7001d2db45df6d8&amp;chksm=96cda266a1ba2b7086f38adb26135009a59dd42c58be4f9c60ed0e56b37952b2d5919173d783&amp;scene=21#wechat_redirect" target="_blank">你一定会用到的RxJava常用操作符</a></p><p style="text-align: left;"><a href="http://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&amp;mid=2247488588&amp;idx=1&amp;sn=3f7c59654835ec8d560610ba97d10fc0&amp;chksm=96cdb501a1ba3c173c0f2e173ad131c27a0fbd5bdca0d8245822ae440562c8822ba1aaf3324a&amp;scene=21#wechat_redirect" target="_blank">我打赌你一定没搞明白的Activity启动模式&nbsp;</a></p><p style="text-align: left;"><a href="http://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&amp;mid=2247486906&amp;idx=1&amp;sn=d6f473abffdea7b2ece6f6bb1f72e084&amp;chksm=96cdacf7a1ba25e19569f1baf9f956139c2b03140012b96e77802a79383a15f9f2872d8a6864&amp;scene=21#wechat_redirect" target="_blank">看我逆向小米rom层应用做碎片化适配</a>&nbsp; &nbsp;&nbsp;</p><p style="text-align: left;"><a href="http://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&amp;mid=2247487014&amp;idx=1&amp;sn=ce2e5378d0dd8a8bc6b85358a8aaa47c&amp;chksm=96cdaf6ba1ba267de98ac3aeba61809e18f9005bb82e384a782d2abbda2dd785846298d17124&amp;scene=21#wechat_redirect" target="_blank">APP从启动到主页经历了哪些过程吗？</a></p><p style="text-align: left;"><a href="http://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&amp;mid=2247486700&amp;idx=1&amp;sn=a1160460e5e8fe4171de73f7775a2c8d&amp;chksm=96cdada1a1ba24b74141193b1d9b99a0d59b67d4bbb81fb53ba142658359d4d145bd123bbd31&amp;scene=21#wechat_redirect" target="_blank">深度分析：Google Play列表滑动效果&nbsp;&nbsp;</a></p><p style="text-align: left;"><a href="http://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&amp;mid=2247487307&amp;idx=1&amp;sn=7390a991f738f9537d3c853883a1c272&amp;chksm=96cdae06a1ba271081da48dadf02bc77d1782b79ffb9503f95c78eb856a6afb150179f475c3d&amp;scene=21#wechat_redirect" target="_blank">Android 搭建属于你的技术堆栈</a>&nbsp;</p><p style="text-align: left;"><a href="http://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&amp;mid=2247487442&amp;idx=2&amp;sn=768e9cc22bd5b7f739e5fc95b6796b02&amp;chksm=96cdae9fa1ba27895a3162bc106377657e2ca35d619ab4d9a984ebdd0d576f314417de2ac50b&amp;scene=21#wechat_redirect" target="_blank">Android 项目最新架构&nbsp; &nbsp;</a></p><p style="text-align: left;"><a href="http://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&amp;mid=2247489158&amp;idx=1&amp;sn=9a72afd00f16607ed673b9750278cdad&amp;chksm=96cdb7cba1ba3edd39f0076abc3dbc4473bdb3b64c06b978a574fc15b9e050f2790e1d0ed960&amp;scene=21#wechat_redirect" target="_blank">双语言（Java与Kotlin）5种单例模式&nbsp;&nbsp;</a></p><p style="text-align: left;"><a href="http://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&amp;mid=2247487305&amp;idx=1&amp;sn=e9bdff7cb91b0eabbe67ec965f3be660&amp;chksm=96cdae04a1ba2712a459d2494abed3c32e97223300acf7288f73c10ce264a4efbd7157041ba1&amp;scene=21#wechat_redirect" target="_blank">Jenkins实现自动化打包并集成fir平台</a></p><p style="text-align: left;"><a href="http://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&amp;mid=2247488256&amp;idx=1&amp;sn=7f69fb37b57f9c29a41e47420fba046f&amp;chksm=96cdb24da1ba3b5b775b5c86d422559b366eda7a74b20b51ae389c20a6b0d3c61a3f3c0cd9b3&amp;scene=21#wechat_redirect" target="_blank">2017年Android求职回顾&nbsp;</a></p><p style="text-align: left;"><a href="http://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&amp;mid=2247486946&amp;idx=1&amp;sn=64339a8d8f92fe3b448ec0b5b52e49d1&amp;chksm=96cdacafa1ba25b9927872e77c3e2577349ed23cecf2f798f4ee9dc38e39e6336bda14f5e006&amp;scene=21#wechat_redirect" target="_blank">Android 那些你不可错过的好书&nbsp;</a></p><p style="text-align: left;"><a href="http://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&amp;mid=2247487835&amp;idx=1&amp;sn=3b8ddd7fd4c52e1a4d6e5c1e601d91d7&amp;chksm=96cdb016a1ba3900b81f3d26126312549e678f1a309b9c5ea018c753a504eae3be01a5699483&amp;scene=21#wechat_redirect" target="_blank">30多个Android开发者超赞的工具&nbsp;</a></p><p style="text-align: left;"><a href="http://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&amp;mid=2247488337&amp;idx=2&amp;sn=cdf09c45bafd09b07687cefa6149cc5d&amp;chksm=96cdb21ca1ba3b0a2a04368f63de02db89c499614de0d1c22d042f671f31ffe3b539e6bad3dd&amp;scene=21#wechat_redirect" target="_blank">Facebook面经记&nbsp;&nbsp;</a></p><p style="text-align: left;"><a href="http://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&amp;mid=2247484320&amp;idx=1&amp;sn=032fa88c05c03916e0a176efb95bce27&amp;chksm=96cda2eda1ba2bfb3776e8afb8a97b8f3c4ab23c30d6aada6406bf4ea89d8cff34d4c3293c4b&amp;scene=21#wechat_redirect" target="_blank">2017年4月美团Android面试总结&nbsp;</a></p><p style="text-align: left;"><a href="http://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&amp;mid=2247488476&amp;idx=1&amp;sn=d709ea84e78670c248f226942b8dd563&amp;chksm=96cdb291a1ba3b870d4aa5345f47d1bd743836d59e09f0ba1fe0da41c68332d29ef414ae266b&amp;scene=21#wechat_redirect" target="_blank">Android 面试题整理</a></p><p style="text-align: left;"><a href="http://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&amp;mid=2247488310&amp;idx=1&amp;sn=b8b428c9e516c5579aa37f4f6cad2bfd&amp;chksm=96cdb27ba1ba3b6d86e2d649cf2514da496d94af81c53e61d6fb53e0cd35791cf91521bca814&amp;scene=21#wechat_redirect" target="_blank">2017 Android秋招面试总结&nbsp;&nbsp;</a></p><h3 id="系列文章"><a href="#系列文章" class="headerlink" title="系列文章"></a>系列文章</h3><p style="text-align: left;"><a href="http://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&amp;mid=2247488909&amp;idx=1&amp;sn=fef481b374ffa61ec497c85dbbfc3894&amp;chksm=96cdb4c0a1ba3dd6fde4866470b8e1d9897f9a9fae28ae5d0fa1a40cec996828f175864408a9&amp;scene=21#wechat_redirect" target="_blank">图解RxJava2(一)&nbsp;&nbsp;</a></p><p style="text-align: left;"><a href="http://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&amp;mid=2247489050&amp;idx=1&amp;sn=4b9edc057cc6913dae1580e24d911e37&amp;chksm=96cdb757a1ba3e41ee902bb12ee437ab3d93b64a5fefe030c5aa82184a6ebc63ec669178d6a1&amp;scene=21#wechat_redirect" target="_blank">图解RxJava2(二)&nbsp;</a> &nbsp; &nbsp; &nbsp;</p><p style="text-align: left;"><a href="http://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&amp;mid=2247489109&amp;idx=1&amp;sn=29dcacb34782d774fa1206d7b5e50b6b&amp;chksm=96cdb718a1ba3e0e19f7952b931f34abac422250160cacb764e3e36377f1a6bf47df13aefa8b&amp;scene=21#wechat_redirect" target="_blank">图解RxJava2(三)&nbsp;</a> &nbsp;&nbsp;</p><p style="text-align: left;"><a href="http://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&amp;mid=2247488560&amp;idx=1&amp;sn=86d5b138ade517144ad99d602564eae1&amp;chksm=96cdb57da1ba3c6be523c6502a577f6fd51b1e2ff7e39ac20117b8530e6e33a84a5cdcf43a1b&amp;scene=21#wechat_redirect" target="_blank">图解HashMap(一)</a>&nbsp;&nbsp;</p><p style="text-align: left;"><a href="http://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&amp;mid=2247488620&amp;idx=1&amp;sn=97f43f05706db888188509ffe0f9d781&amp;chksm=96cdb521a1ba3c37420f17fd82f3a11d08f77c574b55974b3d2bb5be6869b75a0864de54a78e&amp;scene=21#wechat_redirect" target="_blank">图解HashMap(二)</a>&nbsp; &nbsp;&nbsp;</p><p style="text-align: left;"><a href="http://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&amp;mid=2247485886&amp;idx=1&amp;sn=3f8e193722f79eb1a433b91867f9d885&amp;chksm=96cda8f3a1ba21e561115a42c3dad25248a0fecd823a07e712921c042f7449228db6983e5474&amp;scene=21#wechat_redirect" target="_blank">RxJava2.X 解析： 探索分发订阅流程</a></p><p style="text-align: left;"><a href="http://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&amp;mid=2247485904&amp;idx=1&amp;sn=0515378e13ce30814db272ef8f194b53&amp;chksm=96cda89da1ba218b618294bfefa07b71af807f6646482648dd056cc167f8877e3ba97ae52fb1&amp;scene=21#wechat_redirect" target="_blank">RxJava2.X 解析：神秘的取消订阅流程</a></p><p style="text-align: left;"><a href="http://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&amp;mid=2247485954&amp;idx=2&amp;sn=56f11ade0644bec80c830890030c8f9d&amp;chksm=96cdab4fa1ba22594d00386bb53be2b2f11ebbea57d3e9bf07dafd7fc0031edfdebd6bc80f68&amp;scene=21#wechat_redirect" target="_blank">RxJava2.X 解析：订阅线程切换</a></p><p style="text-align: left;"><a href="http://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&amp;mid=2247486019&amp;idx=2&amp;sn=e1eb6639beceb68bb2740be6065c672e&amp;chksm=96cdab0ea1ba221812afccac370ea8933d89b9942c069abb219535e508061c5c51b01a48e3da&amp;scene=21#wechat_redirect" target="_blank">RxJava2.X 解析：观察者线程切换原理</a></p><p style="text-align: left;"><a href="http://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&amp;mid=2247486042&amp;idx=2&amp;sn=e2dfd4c2d0c8e73698ea7fb8fa51c34b&amp;chksm=96cdab17a1ba2201332f2c654d2b7d3f9415a47c6eb14328639c490f70973841914e39a7956f&amp;scene=21#wechat_redirect" target="_blank">RxJava2.X 解析：切换线程的有效性</a></p><p style="text-align: left;"><a href="http://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&amp;mid=2247484453&amp;idx=1&amp;sn=425a664b5fdc22242b396213a4e87400&amp;chksm=96cda568a1ba2c7e2b7d156b805052b15abf986eca89e1326937173732d2addd5b7bed6d01a6&amp;scene=21#wechat_redirect" target="_blank">跟着google学习mvp架构</a><br></p><p style="text-align: left;"><a href="http://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&amp;mid=2247484632&amp;idx=1&amp;sn=40d62a328443569418adae7cd07edbfd&amp;chksm=96cda595a1ba2c8383e7caa8ae4b61a31dfd7e8503be57dce4f50f277dff5da0363b8eb53f1a&amp;scene=21#wechat_redirect" target="_blank">跟着google学习mvp架构（clean篇）</a></p><p style="text-align: left;"><a href="http://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&amp;mid=2247484246&amp;idx=1&amp;sn=d20a9dbc15a248ff5bc7e386941e10dd&amp;chksm=96cda21ba1ba2b0dbf3f0024e3b1ff5503919b93d031aa06504737212f7a3bc0df128e2975cf&amp;scene=21#wechat_redirect" target="_blank">给初学者的RxJava2.0教程：基本工作原理</a></p><p style="text-align: left;"><a href="http://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&amp;mid=2247484268&amp;idx=1&amp;sn=84716be98ff3c7542c310f23e4e891b3&amp;chksm=96cda221a1ba2b37fd3b697d564f15831358d28493e0399720ecef6a3b6c5c5206a88f989856&amp;scene=21#wechat_redirect" target="_blank">给初学者的RxJava2.0教程：线程控制</a></p><p style="text-align: left;"><a href="http://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&amp;mid=2247484268&amp;idx=1&amp;sn=84716be98ff3c7542c310f23e4e891b3&amp;chksm=96cda221a1ba2b37fd3b697d564f15831358d28493e0399720ecef6a3b6c5c5206a88f989856&amp;scene=21#wechat_redirect" target="_blank">给初学者的RxJava2.0教程：map和flatMap</a></p><p style="text-align: left;"><a href="http://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&amp;mid=2247484322&amp;idx=1&amp;sn=70e6c88cfcd518f2134e80d3b4fdf309&amp;chksm=96cda2efa1ba2bf90007379eef18d2ea3976ced1ce0aa47e9fd929652760927d2d9b23502ad9&amp;scene=21#wechat_redirect" target="_blank">给初学者的RxJava2.0教程：zip操作符使用</a></p><p style="text-align: left;"><a href="http://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&amp;mid=2247484422&amp;idx=1&amp;sn=c1dfb14d9221d8919c3e7188b47c0a70&amp;chksm=96cda54ba1ba2c5dec956a56c6edb003867e0d4c94fb8758bbe73b551dc9d6ded5ceca1e7969&amp;scene=21#wechat_redirect" target="_blank">给初学者的RxJava2.0教程：背压</a></p><p style="text-align: left;"><a href="http://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&amp;mid=2247484689&amp;idx=1&amp;sn=1f54c343c6a5d73c63b4cdb555bdf254&amp;chksm=96cda45ca1ba2d4af7e0e51454283f86d145a19b613a1fc149e4d46d22e277c150d2910e95b6&amp;scene=21#wechat_redirect" target="_blank">给初学者的RxJava2.0教程：治理</a></p><p style="text-align: left;"><a href="http://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&amp;mid=2247484711&amp;idx=1&amp;sn=c3837b7cad21f0a69d7dccd1aaaf7721&amp;chksm=96cda46aa1ba2d7ce145472449e5a832cd3ac0bc1f766fe09f1ce68ca46c16bab645e507f0b5&amp;scene=21#wechat_redirect" target="_blank">给初学者的RxJava2.0教程：Flowable</a></p><p style="text-align: left;"><a href="http://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&amp;mid=2247484733&amp;idx=1&amp;sn=2f292e89b50b043e5a7201e6342b7be4&amp;chksm=96cda470a1ba2d667e76032d55470e7643d00cc5e3ed656b57f400b1574bad8d3f0e91260952&amp;scene=21#wechat_redirect" target="_blank">给初学者的RxJava2.0教程：Flowable缓存</a></p><p style="text-align: left;"><a href="http://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&amp;mid=2247484765&amp;idx=1&amp;sn=518fbb085cda7ed7718ca101c286814b&amp;chksm=96cda410a1ba2d061e8cb42503625c6f11ed9bfc6d2c1d118101b85c9cfe45409be12325e78f&amp;scene=21#wechat_redirect" target="_blank">给初学者的RxJava2.0教程 ：响应式拉取</a></p><p style="text-align: left;"><a href="http://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&amp;mid=2247485425&amp;idx=1&amp;sn=78ad2c2bae37b5ec0c5f4b84866c0670&amp;chksm=96cda6bca1ba2faa212ac6d9b19605a6a90515bd95c2e7668fc2e354bc98d57e27d07e378c2e&amp;scene=21#wechat_redirect" target="_blank">测试框架Robolectric3.0：入门篇</a></p><p style="text-align: left;"><a href="http://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&amp;mid=2247485426&amp;idx=1&amp;sn=6f53ab0ed5368aef7c284e3239a90253&amp;chksm=96cda6bfa1ba2fa90a886b77cf6ecdc97c2ee5d17fe8f10b7c293c1e5e91fa2e8021dd89626e&amp;scene=21#wechat_redirect" target="_blank">测试框架Robolectric3.0：数据篇</a></p><p style="text-align: left;"><a href="http://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&amp;mid=2247484662&amp;idx=1&amp;sn=7b8a8831b37975936a9ea95c7a54d52a&amp;chksm=96cda5bba1ba2cad32081316ad0771aab42fa64782f7b2c726acc2bb5809fb04f4ef7088ab29&amp;scene=21#wechat_redirect" target="_blank">一文解决Android&nbsp;View滑动冲突</a></p><p style="text-align: left;"><a href="http://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&amp;mid=2247484615&amp;idx=1&amp;sn=d34d4035e6ecf03abbead56cd9eafa4c&amp;chksm=96cda58aa1ba2c9c5663ff1f3e6a2ef72a64db81c813c74b7ebbc389fbcbb0ce3b3eaefe85a5&amp;scene=21#wechat_redirect" target="_blank">一文读懂Android&nbsp;View事件分发机制</a></p><p style="text-align: left;"><a href="http://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&amp;mid=2247486163&amp;idx=1&amp;sn=8449c537e5bc0238e0425966c48740d9&amp;chksm=96cdab9ea1ba2288d9f6a860e054518f62555d31072d0a6a4d2ca551c45c20d2b60ff6e6028c&amp;scene=21#wechat_redirect" target="_blank">拆 JakeWharton 系列之 Picasso</a></p><p style="text-align: left;"><a href="http://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&amp;mid=2247485055&amp;idx=1&amp;sn=c3e20d8f499974890c65def242f740d4&amp;chksm=96cda732a1ba2e24c18af1e9dbd8f12151eea75d0303735c53cc92dbe98bb5193d1732ff13ea&amp;scene=21#wechat_redirect" target="_blank">拆 JakeWharton 系列之 ButterKnife</a></p><p style="text-align: left;"><a href="http://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&amp;mid=2247485056&amp;idx=1&amp;sn=46cffb71fea5ff5058389ae5c3306fc1&amp;chksm=96cda7cda1ba2edbff4add2246afc7e27d817da7ace5110da08b9ef6009d4d556d3a9a254f7a&amp;scene=21#wechat_redirect" target="_blank">Android黑科技①:只要活着，就有希望</a></p><p style="text-align: left;"><a href="http://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&amp;mid=2247485080&amp;idx=1&amp;sn=fc53738f874746bb0df7ed47b3eeb667&amp;chksm=96cda7d5a1ba2ec3148becbc9e6f0ae78c887287357956ec2f8d5cb1e63f7ca93d9cf2982748&amp;scene=21#wechat_redirect" target="_blank">Android黑科技②:欺骗的艺术</a></p><p style="text-align: left;"><a href="http://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&amp;mid=2247485214&amp;idx=1&amp;sn=989542ebf42258e2747f83913c65ea9b&amp;chksm=96cda653a1ba2f4524bb293dd2a5bc903a30740fbacad2de848a62f7f7ea30ae677bd046ce8d&amp;scene=21#wechat_redirect" target="_blank">Android黑科技③:干大事不择手段</a></p><h3 id="工具技巧"><a href="#工具技巧" class="headerlink" title="工具技巧"></a>工具技巧</h3><p><a href="http://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&amp;mid=2247486384&amp;idx=1&amp;sn=dff859c691a26bb79fd0eab9d6a9c4da&amp;chksm=96cdaafda1ba23ebd5acfed4d78b586750db811aa1c890bb6d6aeb54eff15db08d585a499c47&amp;scene=21#wechat_redirect" target="_blank">Android studio常用插件之行云流水coding<br></a></p><p><a href="http://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&amp;mid=2247488398&amp;idx=1&amp;sn=ef11d223341039f3b3a91688d7e0fa3d&amp;chksm=96cdb2c3a1ba3bd514f0c0b14caa53db54fa4a4fb48d69c4c4470a6d120a1cc43e60ff30ae0c&amp;scene=21#wechat_redirect" target="_blank">熟练这些，才知道 Android studio 高效&nbsp;&nbsp;</a></p><p><a href="http://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&amp;mid=2247487907&amp;idx=1&amp;sn=202a662ccf28a9b00d7daf2067eb22d6&amp;chksm=96cdb0eea1ba39f8ffaa465278f9d8b0cf9658e76423b9c184b1fabe5d3d6784978460c5921e&amp;scene=21#wechat_redirect" target="_blank">Android Studio 3.0的性能分析工具&nbsp;&nbsp;</a></p><p><a href="http://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&amp;mid=2247487640&amp;idx=1&amp;sn=3752d389f908a6116341a03e6f3c6730&amp;chksm=96cdb1d5a1ba38c3698e67f35a96af2f8f823ab548ac249a024f1e8549e76846746deeeaf239&amp;scene=21#wechat_redirect" target="_blank">Android Studio插件集合(IDE通用)（上）</a></p><p><span style="font-size: 15px;letter-spacing: 0.5px;background-color: rgb(255, 255, 255);"><a href="http://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&amp;mid=2247487717&amp;idx=1&amp;sn=ea07b2546f47af16f2f6bae0ec8c092b&amp;chksm=96cdb1a8a1ba38be457a7590e4135dd47f8366021838c6f7a7b1cb24b6ed313ec03eef22002d&amp;scene=21#wechat_redirect" target="_blank">Android Studio插件集合(IDE通用)（下）</a></span></p><p><a href="http://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&amp;mid=2247487401&amp;idx=1&amp;sn=94b2e5ca0b2dcf79ef3423e7cdb5564f&amp;chksm=96cdaee4a1ba27f28be60d33f334afd5b7c9037f32c0b45065876c20c09d655fa41c060caec2&amp;scene=21#wechat_redirect" target="_blank">Android Studio 你不知道的调试技巧&nbsp;</a>&nbsp; &nbsp;</p><p><a href="http://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&amp;mid=2247488705&amp;idx=1&amp;sn=c1df7454a24867daad4f8d96207204df&amp;chksm=96cdb58ca1ba3c9a6106bacb0a3ee85ba442b0bab5fae9e2ecbe181a5a2c4e6b1ede609ec798&amp;scene=21#wechat_redirect" target="_blank">如何使用android studio插件提高效率&nbsp; </a>&nbsp;&nbsp;</p><p><a href="http://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&amp;mid=2247485764&amp;idx=1&amp;sn=f816c73c1bc0d024d877f5f5371488b7&amp;chksm=96cda809a1ba211faf50e83386c40d74bc71a24bd420f22cffda6a3d62a64ded6b5695a20d59&amp;scene=21#wechat_redirect" target="_blank">Android Studio 实用小技巧</a></p><p><a href="http://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&amp;mid=2247486441&amp;idx=1&amp;sn=cba50665f3f4cf48e587fc54e616d363&amp;chksm=96cdaaa4a1ba23b2b192111d86d9081b617307b11f1dc1fa19d924498baa45a1e86d80fc6ed4&amp;scene=21#wechat_redirect" target="_blank">如何造 Android Studio 插件？</a></p><p><a href="http://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&amp;mid=2247486724&amp;idx=1&amp;sn=5a66e01a2ecb72dbd97c619718d906ab&amp;chksm=96cdac49a1ba255fe938689d8eb60a44fec9573b68ccebd253bcf57abcda6b3942f65c048423&amp;scene=21#wechat_redirect" target="_blank">打造一款AndroidStudio翻译插件</a>&nbsp;&nbsp;</p><h2 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h2><p><a href="http://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&amp;mid=2247489652&amp;idx=1&amp;sn=30dbd2e572a9f3ab8b1abe6a34bcc639&amp;chksm=96cdb939a1ba302fdefe7c1143beb98f66a4a87ba4b9016ebbf76641913e0071361f5432e729&amp;scene=21#wechat_redirect" target="_blank">如何用Python做词云？</a>&nbsp; &nbsp;&nbsp;</p><p><a href="http://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&amp;mid=2247489698&amp;idx=1&amp;sn=e9c6ecfe75018de73e5afd1b9777d31f&amp;chksm=96cdb9efa1ba30f9c35fa54a20af2b202700d73c9e3ec89bbc002ab36ff80e73fa67e0883551&amp;scene=21#wechat_redirect" target="_blank">如何用Python和深度神经网络识别图像？&nbsp;</a></p><p><a href="http://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&amp;mid=2247488970&amp;idx=2&amp;sn=9823dc5808fb203b9ad7922c0b93ad30&amp;chksm=96cdb487a1ba3d9174114466dea29df958c3df8e577f8c419f023bc7fcaa92f1a458615594c8&amp;scene=21#wechat_redirect" target="_blank">Pycharm中一些不为人知的技巧</a>&nbsp; &nbsp;&nbsp;</p><p><a href="http://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&amp;mid=2247489068&amp;idx=1&amp;sn=46b760cd0d7ca673b9340a66da4e92eb&amp;chksm=96cdb761a1ba3e77e29173107ac63043ab45be4c82856fb0065d2863e5a8954d5c7227bf54d7&amp;scene=21#wechat_redirect" target="_blank">Python 值得关注的开源库、工具和开发者</a></p><p><a href="http://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&amp;mid=2247489621&amp;idx=1&amp;sn=f98a1bffcc058e28a4a692e7a974aa35&amp;chksm=96cdb918a1ba300e449af645ae9d0bfb09303821e7e72471043cdb616297c0d6c90398a318b9&amp;scene=21#wechat_redirect" target="_blank">从零开发一个小游戏：PyGame 入门</a>&nbsp; &nbsp;</p><p><a href="http://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&amp;mid=2247489179&amp;idx=1&amp;sn=4b99a633b1f4fc1804782c6e85faa5bf&amp;chksm=96cdb7d6a1ba3ec03fd0a2fd611cc8ea6db3d91feb995a9ef4310ea238720244a99ad9048ce9&amp;scene=21#wechat_redirect" target="_blank">用Python爬取各Android市场应用下载量</a></p><p><a href="http://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&amp;mid=2247489350&amp;idx=1&amp;sn=ab30e1eb75c3402ffafbe6b17afb7b3c&amp;chksm=96cdb60ba1ba3f1d7d37974aceb1c48fb1b7998002f5e74248db20cf35d66f637eaac724d304&amp;scene=21#wechat_redirect" target="_blank">爬取电影天堂的最新电影</a></p><p><a href="http://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&amp;mid=2247488877&amp;idx=2&amp;sn=2b695113c3137db3db9075d0fcdc4ed8&amp;chksm=96cdb420a1ba3d361042f192356c88fc973ae7344b609559b1e818d282be826184975d7c10f2&amp;scene=21#wechat_redirect" target="_blank">Python 如何入门？</a>&nbsp; &nbsp;</p><h2 id="通用技术"><a href="#通用技术" class="headerlink" title="通用技术"></a>通用技术</h2><p><a href="http://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&amp;mid=2247486644&amp;idx=1&amp;sn=933e75008cb67a3b0677e54af79d6cd4&amp;chksm=96cdadf9a1ba24efaa0eefb4f144a08df379b61a04fcdd28c09d79d700130be332be718f7c29&amp;scene=21#wechat_redirect" target="_blank">一篇文章，教你学会Git&nbsp;</a> &nbsp;&nbsp;</p><p><a href="http://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&amp;mid=2247488268&amp;idx=1&amp;sn=9e908855b84df9db6fdaf74546de7591&amp;chksm=96cdb241a1ba3b570c2e53fdda8b20675349addc8d406fd4aded230b7aa0efe3cd83bc140b6c&amp;scene=21#wechat_redirect" target="_blank">华为如何实现基于Git的跨地域协同开发</a></p><p><a href="http://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&amp;mid=2247489234&amp;idx=1&amp;sn=c6de4582a1400af22e0908f05a8870bc&amp;chksm=96cdb79fa1ba3e89f723104a39934eedbda8e9fd25c75157f5cf27c264295b423f540d434b7b&amp;scene=21#wechat_redirect" target="_blank">Markdown语法图文全面详解</a></p><p><a href="http://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&amp;mid=2247486671&amp;idx=1&amp;sn=cedbdf2abd2e77f942edf962629f2b32&amp;chksm=96cdad82a1ba249433f2a7ed88e816857cd8e4ba6b9c84ddf7281e02ac0f582d2a4ce3b2cc21&amp;scene=21#wechat_redirect" target="_blank">HTTP请求响应涉及了哪些知识吗？</a></p><p><a href="http://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&amp;mid=2247486825&amp;idx=1&amp;sn=db596ed4b69bd9220f6a8ad79ef308db&amp;chksm=96cdac24a1ba2532df1bcb267d0af9f9ad103e71014e3c534a068858cf170d0bfa19763f811e&amp;scene=21#wechat_redirect" target="_blank">关于TCP/IP，必知必会的十个问题</a></p><p><a href="http://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&amp;mid=2247487344&amp;idx=1&amp;sn=744a9ebc0425fb3fa17c3f62eb59e421&amp;chksm=96cdae3da1ba272b80d7cf49941d9606caf29c6dd6b19f70742c9a35984035eda0060fa7491c&amp;scene=21#wechat_redirect" target="_blank">几条小经验帮你美化你的GitHub开源项目</a></p><p><a href="https://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&amp;mid=2247488871&amp;idx=1&amp;sn=8c7d3ea49054d87bd63aa6960bcfc309&amp;scene=21#wechat_redirect" target="_blank">GitHub快速入门图文全面详解</a></p><p><a href="http://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&amp;mid=2247488280&amp;idx=1&amp;sn=0ded525c8f65a42b662f34b9f25aac96&amp;chksm=96cdb255a1ba3b432cf7acf3d29bbc02d3532086f640f91d3a7a5aaea03186204b6c5213ee7d&amp;scene=21#wechat_redirect" target="_blank">如何进行code review?&nbsp;&nbsp;</a></p><p><a href="http://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&amp;mid=2247489628&amp;idx=1&amp;sn=fe3a9f866149c4410016421d8cd904a9&amp;chksm=96cdb911a1ba300747e695c0e69e8e8c3c28e4421fba6767ea1d4d2b7e39903d383031949de1&amp;scene=21#wechat_redirect" target="_blank">如何给老婆解释什么是Restful&nbsp;</a></p><p><a href="http://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&amp;mid=2247483949&amp;idx=1&amp;sn=8fb1a5524d18bc3ded26ce469e0b28ce&amp;chksm=96cda360a1ba2a76c8fccd416bf7cac14fe897686e539d311703c9f5d99db527ebc1b5c9812b&amp;scene=21#wechat_redirect" target="_blank">MySQL入坑手册（含教学视频）</a></p><p><a href="http://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&amp;mid=2247484846&amp;idx=1&amp;sn=368db5686435560fa2255da3ae21923f&amp;chksm=96cda4e3a1ba2df5378d53246d6e2c01189f734afb024a4970c4118100f814ff10ea3a119642&amp;scene=21#wechat_redirect" target="_blank">关于线程，还有这些是你需要知道的！</a>&nbsp;</p><p><a href="http://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&amp;mid=2247488109&amp;idx=1&amp;sn=caf6d0dfc9e8ce74b672eb71dc720f88&amp;chksm=96cdb320a1ba3a36a5ad8179cc5f6e910069bf005893d1f1d46e103c4be2dc4a83975635c71f&amp;scene=21#wechat_redirect" target="_blank">瞬间提高逼格的纯文本流程图</a></p><p><a href="http://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&amp;mid=2247483968&amp;idx=1&amp;sn=75890a88bf3a86d8825f16a066d3f9d8&amp;chksm=96cda30da1ba2a1b10b4d7eff1efee7f8d62a9078cd3496d80865c45b2dcb235e99ffb7660fe&amp;scene=21#wechat_redirect" target="_blank">BRVAH从0到1024的过程</a></p><p><a href="http://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&amp;mid=2247486701&amp;idx=1&amp;sn=f364fd41102fd520d9658a490bca0e25&amp;chksm=96cdada0a1ba24b6ac42b80b83a389429012b5993738c6606aa48d80b409662f42434789d990&amp;scene=21#wechat_redirect" target="_blank">什么是「设计模式」？</a></p><p><a href="http://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&amp;mid=2247487041&amp;idx=1&amp;sn=dea11fce71ffbd13d80c0b3d7079b852&amp;chksm=96cdaf0ca1ba261a9f009e244d6a6a7b919903ff666aa1ea16003bfbb1c98e51743d77971f61&amp;scene=21#wechat_redirect" target="_blank">王者荣耀之「建造者模式」&nbsp;&nbsp;</a></p><p><a href="http://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&amp;mid=2247486750&amp;idx=1&amp;sn=c2080d8c0fff1b23f22833ca24c68417&amp;chksm=96cdac53a1ba2545961a49919078bba90a035c5143b0f375429f5ef4f6361282b3b3e028a2bb&amp;scene=21#wechat_redirect" target="_blank">王者荣耀之「装饰者模式」&nbsp; &nbsp;</a></p><p><a href="http://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&amp;mid=2247486704&amp;idx=1&amp;sn=3b1b0fadf33c45639092f1a1f6d95938&amp;chksm=96cdadbda1ba24abd8c023dfbcfe69b64e945ba13af06901dd2761a505b4e5eaa882029848c0&amp;scene=21#wechat_redirect" target="_blank">英雄联盟之「策略模式」&nbsp;</a></p><p style="color: rgb(255, 202, 0);font-size: 15px;letter-spacing: 0.5px;text-align: left;white-space: normal;background-color: rgb(255, 255, 255);"><a href="http://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&amp;mid=2247483959&amp;idx=2&amp;sn=976d8af4a77daa45936b482d0a663f4a&amp;chksm=96cda37aa1ba2a6c649fb239f04226ca7c2228760d27f699702c6e04bbd44e47df654e2a0aa4&amp;scene=21#wechat_redirect" target="_blank">多种可替代解决方案的业务逻辑的思路</a></p><p style="color: rgb(255, 202, 0);font-size: 15px;letter-spacing: 0.5px;text-align: left;white-space: normal;background-color: rgb(255, 255, 255);"><a href="http://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&amp;mid=2247484375&amp;idx=1&amp;sn=7003046606fcb94b91e7182919b3579c&amp;chksm=96cda29aa1ba2b8c02da4ac0fc4b54e254ac3799ae5a6958084fe0718f0184533303cc13925f&amp;scene=21#wechat_redirect" target="_blank">武林秘籍之设计模式迷你手册</a></p><p><a href="http://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&amp;mid=2247489137&amp;idx=1&amp;sn=33461b0b6ef1974a6f3b7c4259cb9894&amp;chksm=96cdb73ca1ba3e2ac23486ebe0ea3dec55e304b936a834aaa8864af3739c0ccbcaa2e174e191&amp;scene=21#wechat_redirect" target="_blank">破壳问答 | 第一期&nbsp;</a>&nbsp;&nbsp;<br></p><h2 id="程序人生"><a href="#程序人生" class="headerlink" title="程序人生"></a>程序人生</h2><p><a href="http://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&amp;mid=2247486830&amp;idx=1&amp;sn=2d638e9d0f19bde00030ed5a8aa24688&amp;chksm=96cdac23a1ba2535949c4ca3b606e19a0eb58e8e3782191ac0f241c41bc14180c7f99341f4c3&amp;scene=21#wechat_redirect" target="_blank">如何在移动开发者的寒冬中破冰而出？&nbsp;&nbsp;</a></p><p><a href="http://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&amp;mid=2247489005&amp;idx=1&amp;sn=b52639b3a8d8ff70d9d71c79e5f9932d&amp;chksm=96cdb4a0a1ba3db6a131f5bbb751c0f056dc2b7381b10b07aac4be8a646ca2d9a79269bdf5a9&amp;scene=21#wechat_redirect" target="_blank">我是如何从流水线工人到程序员？</a></p><p><a href="http://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&amp;mid=2247488366&amp;idx=1&amp;sn=9b4a53f01144fabb69168512a408b046&amp;chksm=96cdb223a1ba3b356f4a15e3afd22d0ccb2aa226e9310e668af65e46e746c36f11090a17ec59&amp;scene=21#wechat_redirect" target="_blank">为何别人的团队战斗力爆表？</a></p><p><a href="http://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&amp;mid=2247488591&amp;idx=1&amp;sn=1f92ba30d363bf22bfbfd2480e361b37&amp;chksm=96cdb502a1ba3c14c6214f290bf989a1cc1716f9918daadb5b9402c4737d9ddffe27cadd8e3e&amp;scene=21#wechat_redirect" target="_blank">为什么源码分析味同嚼蜡？&nbsp;&nbsp;</a></p><p><a href="http://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&amp;mid=2247486252&amp;idx=1&amp;sn=464768d55047f7b60c6450c2f2b0c422&amp;chksm=96cdaa61a1ba237703ee2e93d982f6580d10a1ed0152c602fd4d3f2dd3529ba610be48888b52&amp;scene=21#wechat_redirect" target="_blank">编程给我带来了什么？</a></p><p><a href="http://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&amp;mid=2247484100&amp;idx=1&amp;sn=6d049494e35c19c5bd688d9d71f034d9&amp;chksm=96cda389a1ba2a9f5425c4d4ad8ad8a91d5ba2ca1ed44871b345e411bf404a7ceb15e570595f&amp;scene=21#wechat_redirect" target="_blank">你的开发为何如此低效？</a></p><p><a href="http://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&amp;mid=2247486383&amp;idx=1&amp;sn=0284c7d589251159f510ba1a6fbdead2&amp;chksm=96cdaae2a1ba23f4dbc2f90c44ce35971c8bb074fd87facec72febf276548f6fe09228aa790e&amp;scene=21#wechat_redirect" target="_blank">写给IT自学者的入门指南&nbsp;&nbsp;</a></p><p><a href="http://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&amp;mid=2247489611&amp;idx=1&amp;sn=ea2cd0ff30ac19dc33175cf676cc7450&amp;chksm=96cdb906a1ba3010538ed9f4115f850d42a06e5ec32520c78c3cc7bda5a3c611790908bb904d&amp;scene=21#wechat_redirect" target="_blank">优秀程序员眼中的整洁代码&nbsp; &nbsp; &nbsp;</a></p><p><a href="http://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&amp;mid=2247489289&amp;idx=1&amp;sn=58166ecc82206c9d3021b2a9a083cd82&amp;chksm=96cdb644a1ba3f521d4d8585c6c8bfebc4339b74ed339af461c8889394fdcbd5af3f821ae1ce&amp;scene=21#wechat_redirect" target="_blank">大厂十年研发经历，总结了12条开发经验</a></p><p><a href="http://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&amp;mid=2247488018&amp;idx=1&amp;sn=0eebb7eb8d783320c2e3f9513b736be8&amp;chksm=96cdb35fa1ba3a49b2b8ec8a5ff22cfd5aaf40acc50dc3a591bf53f4bdf0dff20ec8af29ebe8&amp;scene=21#wechat_redirect" target="_blank">老程序员总结的16条经验教训&nbsp; &nbsp;</a>&nbsp;</p><p><a href="http://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&amp;mid=2247486650&amp;idx=1&amp;sn=9c6e2e0fd5780aab2bcb02b823e7316e&amp;chksm=96cdadf7a1ba24e1ab3f1978a0accdf170e5b227672e67500e6bc70a95435417844a1088699d&amp;scene=21#wechat_redirect" target="_blank">Scrum：官僚者们的游戏&nbsp;</a></p><p><a href="http://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&amp;mid=2247485562&amp;idx=1&amp;sn=99fb6f3668db9296bfb79278f2507cbc&amp;chksm=96cda937a1ba20210a7c9d7ec83e4e9a8122259c43275edcdd3094c907a690e364bfbfef5d1e&amp;scene=21#wechat_redirect" target="_blank">从理论到实践，让你全面看懂OKR！</a></p><p><a href="http://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&amp;mid=2247486355&amp;idx=2&amp;sn=cb60717ff4ade0fefc9a711959fc190e&amp;chksm=96cdaadea1ba23c8ed49f12519c55b634e8ddb9acc0cef51bad04cb8f3fa9feb293916842e74&amp;scene=21#wechat_redirect" target="_blank">流程图制作利器：Giffy Diagrams</a></p><p><a href="http://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&amp;mid=2247489341&amp;idx=2&amp;sn=f4c9ed88bbd724018e39e42fa1dc0fca&amp;chksm=96cdb670a1ba3f66391f9f582a9c62d120db6202f062d2ad4e4076f853099d8cf12bb141053c&amp;scene=21#wechat_redirect" target="_blank">12款堪称神器的 Chrome 插件</a></p><p><a href="http://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&amp;mid=2247489588&amp;idx=1&amp;sn=b1f336bd5800086ea97b89af904cbe24&amp;chksm=96cdb979a1ba306fa5f2971798c68e0076bd66034f0c3237298d06e6210ad4d056bab28bee95&amp;scene=21#wechat_redirect" target="_blank">7 款 Mac 工具，提高你的效率！</a></p><p><a href="http://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&amp;mid=2247487450&amp;idx=1&amp;sn=7afef51ae651844c8971e92a502f0a60&amp;chksm=96cdae97a1ba2781fbd1afa68fa9af15850f64c88e97075bbb36349152eff133ee1d2347c810&amp;scene=21#wechat_redirect" target="_blank">一名全栈工程师的必备工具箱</a></p><p><a href="http://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&amp;mid=2247487075&amp;idx=1&amp;sn=4d789779199a7643a275fa8a7e79afcc&amp;chksm=96cdaf2ea1ba263866e3aae4919687f45adc02fe921b659cd9638f834ce8e5e3a9efb5036e1f&amp;scene=21#wechat_redirect" target="_blank">学会戴上“克制”的面具温和示人</a></p><p><a href="http://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&amp;mid=2247486751&amp;idx=1&amp;sn=a0581fc81025b79d6f6b1d5d2860147c&amp;chksm=96cdac52a1ba25448bbc8125041b04b5fd30f7bfbe96bf25a3063b4fbde55e2c68d913e2ab0a&amp;scene=21#wechat_redirect" target="_blank">利用这10个App管理自己的时间</a></p><p><a href="http://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&amp;mid=2247485762&amp;idx=1&amp;sn=1259add04c5de788211d1127a5024f74&amp;chksm=96cda80fa1ba211955596432ae38a608bc90b53d0dc46418810f9259ec0adbe4224f8aa138f7&amp;scene=21#wechat_redirect" target="_blank">从拖延到高效，我推荐这7本书</a></p><p><a href="http://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&amp;mid=2247486044&amp;idx=1&amp;sn=fdfe1c9e32084ef09d1da52fa3369a07&amp;chksm=96cdab11a1ba2207b18ee26a69fd1cd45b6783e53d767ba4c6eb7a2259e2267ba709be504514&amp;scene=21#wechat_redirect" target="_blank">下班后，高效生活的10个日常习惯</a></p><p><a href="http://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&amp;mid=2247485869&amp;idx=1&amp;sn=6bb6bfac079c6eb691d95211037882e7&amp;chksm=96cda8e0a1ba21f69c702497f45ed3ad4154262f46c5c66268827da23dd8cb412f552d2f3115&amp;scene=21#wechat_redirect" target="_blank">自律人生的开启方式—时间管理之术</a></p><p><a href="http://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&amp;mid=2247487208&amp;idx=1&amp;sn=649d54250b4532e79776e43b72687a95&amp;chksm=96cdafa5a1ba26b3036e01a05871fb915148cdef8705bef90d2150309993d05c598dabce2308&amp;scene=21#wechat_redirect" target="_blank">他们说学历不重要，可怜你深信不疑&nbsp; &nbsp; </a>&nbsp;</p><p><a href="http://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&amp;mid=2247486836&amp;idx=1&amp;sn=5c23896978688eed618559082b7b2583&amp;chksm=96cdac39a1ba252fee411853a62c0a0642afa510890e760c125bdd43dbc9d5cdc8e56c989e1b&amp;scene=21#wechat_redirect" target="_blank">不管出彩还是出局，要管得住初心&nbsp; &nbsp;</a></p><p><a href="http://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&amp;mid=2247487308&amp;idx=1&amp;sn=8c3ec1252f9bae4d4301b3f8447c8a98&amp;chksm=96cdae01a1ba271778fd0d99658c85bd265d6e83ac145571f1ceb40266a5d49e1b6057f70fb3&amp;scene=21#wechat_redirect" target="_blank">走出“丧”的状态，从让自己“忙”开始&nbsp;&nbsp;</a></p><p><a href="http://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&amp;mid=2247485763&amp;idx=1&amp;sn=f6a60bc6b367be260db2e43e19df43d8&amp;chksm=96cda80ea1ba21180025bdb265e0768978192a51c89b6ebe2122cf3d1445fd15624a20e6e463&amp;scene=21#wechat_redirect" target="_blank">踏实，是一个年轻人矜贵的品质</a></p><p><a href="http://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&amp;mid=2247487075&amp;idx=1&amp;sn=4d789779199a7643a275fa8a7e79afcc&amp;chksm=96cdaf2ea1ba263866e3aae4919687f45adc02fe921b659cd9638f834ce8e5e3a9efb5036e1f&amp;scene=21#wechat_redirect" target="_blank">学会戴上“克制”的面具温和示人&nbsp;&nbsp;</a></p><p><a href="http://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&amp;mid=2247485012&amp;idx=1&amp;sn=03c1978005cb01e40e6f3fe78da4ee9b&amp;chksm=96cda719a1ba2e0f45438be27ef861c1b7007ad5f6140cf0cf0fe5518e2bb01b87f553bfd960&amp;scene=21#wechat_redirect" target="_blank">如何让你的知识内化？</a></p><p><a href="http://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&amp;mid=2247484542&amp;idx=1&amp;sn=357c2b6462a3b6a4527dc150bcae3613&amp;chksm=96cda533a1ba2c2536c42544db6a633367a3bc03699a44656b3edb22ecd9c7ae32981d4ad34b&amp;scene=21#wechat_redirect" target="_blank">5步学习法，从方法到实践</a></p><p style="font-size: 15px;letter-spacing: 0.5px;white-space: normal;background-color: rgb(255, 255, 255);"><a href="http://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&amp;mid=2247486647&amp;idx=1&amp;sn=8e9bb2a429da04fe9cae4d68d4905357&amp;chksm=96cdadfaa1ba24ecdd7a5310e68c452e244594f0e35f71f34d308fca6806b0b70a9bb1dcfa0a&amp;scene=21#wechat_redirect" target="_blank">读了100多本书只向你推荐这6本</a></p><p style="font-size: 15px;letter-spacing: 0.5px;white-space: normal;background-color: rgb(255, 255, 255);"><a href="http://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&amp;mid=2247486468&amp;idx=1&amp;sn=b498aed5576470529d8a155846a8eac7&amp;chksm=96cdad49a1ba245f71d75208ca6711d23b9087fa4329ca68f774a763ce1ecfedd0c0cf9c9835&amp;scene=21#wechat_redirect" target="_blank">推荐给程序员的一些书（不止是技术书）</a>&nbsp;&nbsp;</p>]]></content>
    
    
    
    <tags>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一年又一年——2017末</title>
    <link href="/2017/12/25/%E4%B8%80%E5%B9%B4%E5%8F%88%E4%B8%80%E5%B9%B4%E2%80%94%E2%80%942017%E6%9C%AB/"/>
    <url>/2017/12/25/%E4%B8%80%E5%B9%B4%E5%8F%88%E4%B8%80%E5%B9%B4%E2%80%94%E2%80%942017%E6%9C%AB/</url>
    
    <content type="html"><![CDATA[<p>分析一下现在，计划一下未来。</p><a id="more"></a><p>刚刚写完公司2017的年终总结，现在想自己写写，写写那些自己的话。</p><p>今年的上半年基本在烦恼压抑中度过，因为一些人吧，那时候还在上家公司工作，年初提了调薪申请，然后被忽视。这件事让我更加坚定了我跳槽的想法。然后我在qq空间里开始倒数，我定了一个100天跳槽的计划，每天在空间打卡，每天提醒自己的计划，每天坚持学习。就这样，转眼来到了今年的下半年，大约是7月份吧，开始投简历。可是无奈的是伯乐不常有，投了几十家都石沉大海，慢慢的我开始怀疑我自己，我又和公司谈了谈涨薪，希望留下来，毕竟自己可能走不成，而我又不能潇洒地裸辞，可是公司也是说考虑考虑。无奈。</p><p>大约是7月末吧，我在某招聘软件上私聊了一个小米的leader，我是米粉，对小米还是很有好感的。我希望那个leader能够给我一个面试机会，然后他同意了，这样我顺利的拿到了小米的面试机会，并且拿到了offer。接到offer的那天下午，原来的公司HR告诉我，公司资金紧张，涨不了薪了。我说我理解公司。第二天我提出了离职。毕竟多说已经无意义。</p><p>然后进入了小米，工作和以前相比可以说是大不同，公司人多，管理起来一定会有各种规定，比如进代码，要找各种人review。还有就是我负责老项目，原来是三不管而又是所有人都可以修改的项目，而我也过来了。现在项目交出去了，一切回忆起来，这个项目对我的开发来说意义不大，对我的项目管理、版本管理来说倒是挺有意义的。</p><p>回想在小米的这四个多月，脚本写了一些，Python学了些，kotlin学了些，iOS写了写，做的事情挺杂的，有点找不到方向。最近有个中兴的同行跳了楼，程序员的中年危机问题引发了越来越多人的深思。的确，我也有这种问题，我现在这个状态，接触的东西这么杂，平时也不是太忙，好多东西都是研究性的去开发、去尝试，但是这些到底对我有多大的帮助呢，长此以往，我会不会有这用危机，感觉我的危机会来到的更早，毕竟越是高级的开发，门槛越高，但是瓶颈来到的也越晚。越是初级的开发越容易遇到瓶颈，越容易被社会淘汰。但是，如果我现在是一个android开发呢，整天开发App，一人陶醉在自己的编程世界中，但是这样技术即使提高了，但是中年危机还是会来的。</p><p>所以，不管怎样中年危机终会到来，既然避免不了，还不如坦然面对。</p><p>这个“坦然”做起来挺难，这也是我想写这篇博客的原因。年末了，需要整理一下行装，重新出发。</p><p>2018年估计是一个变革之年，不知道为什么，我心里一直有这个感觉，而且这个感觉很强烈。2018，可能房价会变，不知道政府会有什么新的政策出来，毕竟现在的房价还是受国家的政策影响。2018，北京可能会变，人口的结构会进一步的调整，雄安能不能雄起，北京会不会继续治理自建房，一起都蓄势待发。2018，感觉网民大哥们会搞出来点事情，然后国家会严查网络，会不会实名制啊，哈哈，有这个感觉是因为，现在的网民戾气太重，动不动就喷，喷完这个喷那个，已经形成了一个喷子文化，不知道喷子们会不会搞出点事情。2018，对于Android开发，估计kotlin会火热，我看了kotlin的语法及对于android的支持，感觉这是一门好语言，适合有一定android开发经验的人去使用，新手上来就搞kotlin，感觉有点早，新手还是把Java先写好吧。2018，说说我自己，自己的选的路，还是要继续的走下去，这次换工作的经历的确让我懂了好多，我感觉这一切都是值得的，有了经历才知道未来的坑在哪里。</p><p>2018，我的计划突然没了详细的计划，就是有一些想法。</p><p>2018，想多认识一些志同道合的人，搞点事情。技术要跟上更新的速度，广泛涉猎。然后看看自己能不能挣钱买个房子，去小城市买吧，去个比较有前途的小城市。</p><p>要做到以上这些，必须改掉自己懒的毛病。</p>]]></content>
    
    
    
    <tags>
      
      <tag>生活</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>kotlin入坑</title>
    <link href="/2017/12/21/kotlin%E5%85%A5%E5%9D%91/"/>
    <url>/2017/12/21/kotlin%E5%85%A5%E5%9D%91/</url>
    
    <content type="html"><![CDATA[<p>这个是一些学习笔记。碎碎记。</p><a id="more"></a><p>kotlin与android，现在是kotlin通过插件编译成jvm能运行的机器码，java有的东西kotlin都有。</p><p>kotlin支持方法拓展，但是不能写到类里边。写到类里边无效。这个特性非常重要，为拓展提供了新思路。<br>方法拓展还可以给已有方法重命名，当然，原来方法名还能用，就是包了一层。</p><div class="hljs"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> 类名.拓展方法（args）&#123;&#125; //子类可以继承</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">var</span> TextView.text: CharSequence  <span class="hljs-comment">// 拓展 重命名</span><span class="hljs-keyword">get</span>() = getText()<span class="hljs-keyword">set</span>(v) = setText(v)</code></pre></div><p>支持lambda，我感觉相当于匿名内部类。</p><p>好像要在Javabean的对象前加data</p><p>支持对象copy并修改值。</p><p>类继承，所有类继承自Any，（不是Object了），默认类不可继承，只有open 或abstract 修饰的类才可以。</p><p>函数可以简写了，直接在返回值类型后加=</p><p>构造方法和初始化用constructor和init，constructor可以重载</p><p>类型转换用as ，安全转换用as？，不成功就是null</p><p>静态：</p><ol><li>静态类前边加object；</li><li>一部分是静态方法的情况 : 将方法用 companion object { } 包裹即可，这个叫“伴生对象”，可以给伴生对象起名字，放到object后，也可不加。</li></ol><p>bean类不用写getter、setter了， 其实还有，只是不用写，可以重写。</p><div class="hljs"><pre><code class="hljs cs"><span class="hljs-keyword">public</span> classs Person &#123;<span class="hljs-keyword">var</span> name: String = <span class="hljs-string">""</span><span class="hljs-keyword">get</span>() = field.toUpperCase() <span class="hljs-keyword">set</span>(<span class="hljs-keyword">value</span>)&#123;field = <span class="hljs-string">"Name: $value"</span> &#125;&#125;</code></pre></div><p>重写用override，加到fun前面</p><p>是空安全的，支持?:操作符，和Java里的意思不一样，java里的那个三目运算符只能用if、else表示，但是可以简写</p><div class="hljs"><pre><code class="hljs dart">hah?.<span class="hljs-built_in">print</span>() <span class="hljs-comment">//hah不为空才打印</span>hah!!/<span class="hljs-built_in">print</span>() <span class="hljs-comment">//强制打印，可能会有exception</span>hah?.name?:<span class="hljs-string">"null"</span> <span class="hljs-comment">// null打印null，代替值</span><span class="hljs-comment">//在变量类型后面加上问号，代表该变量是可空变量  可空变量需要强制判null</span><span class="hljs-keyword">var</span> name: <span class="hljs-built_in">String</span>? = <span class="hljs-string">"zhangsan"</span>  <span class="hljs-keyword">var</span> lenght:Int = <span class="hljs-keyword">if</span>(haha!=<span class="hljs-keyword">null</span>) haha.length: <span class="hljs-number">-1</span> <span class="hljs-comment">// 原来java的三目这么用了</span></code></pre></div><p>with函数，直接使用with括号对象的属性方法。</p><p>kotlin强制指定泛型，不加报错</p><div class="hljs"><pre><code class="hljs lasso"><span class="hljs-built_in">var</span> <span class="hljs-built_in">list</span> = ArrayList&lt;<span class="hljs-built_in">String</span>&gt;()</code></pre></div><p>集合里边有好多拓展方法，map mapto,groupBy,filter很多，详见</p><div class="hljs"><pre><code class="hljs angelscript">kotlin-stdlib<span class="hljs-number">-1.1</span><span class="hljs-number">.51</span>-sources.jar!/generated/_Collections.kt</code></pre></div><p>有个库叫anko，这是一个对Android使用kotlin的拓展库，JetBrains开发的。提供了新方式写UI布局。</p><p>记一个简化过程<br>简化 setOnClickListener()</p><p>我们用 Android 中非常典型的例子去解释它是怎么工作的:View.setOnClickListener()方法。如果我 们想用 Java 的方式去增加点击事件的回调，我首先要编写一个 OnClickListener 接口:<br>然后我们要编写一个匿名内部类去实现这个接口:</p><div class="hljs"><pre><code class="hljs routeros">public<span class="hljs-built_in"> interface </span>OnClickListener &#123; void onClick(View v);&#125;</code></pre></div><div class="hljs"><pre><code class="hljs reasonml">view.set<span class="hljs-constructor">OnClickListener(<span class="hljs-params">new</span> OnClickListener()</span>&#123; @Overridepublic void on<span class="hljs-constructor">Click(View <span class="hljs-params">v</span>)</span> &#123;<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Toast</span>.</span></span>make<span class="hljs-constructor">Text(<span class="hljs-params">v</span>.<span class="hljs-params">getContext</span>()</span>, <span class="hljs-string">"Click"</span>, Toast.LENGTH_SHORT).show<span class="hljs-literal">()</span>; &#125;&#125;)</code></pre></div><p>我们将把上面的代码转换成 Kotlin(使用了 Anko 的 toast 函数):</p><div class="hljs"><pre><code class="hljs kotlin">view.setOnClickListener(<span class="hljs-keyword">object</span> : OnClickListener &#123; <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onClick</span><span class="hljs-params">(v: <span class="hljs-type">View</span>)</span></span> &#123;toast(<span class="hljs-string">"Click"</span>) &#125;&#125;</code></pre></div><p>很幸运的是，Kotlin 允许 Java 库的一些优化，Interface 中包含单个函数可以被替代为一个函数。 如果我们这么去定义了，它会正常执行:</p><div class="hljs"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">setOnClickListener</span><span class="hljs-params">(listener: (<span class="hljs-type">View</span>) -&gt; <span class="hljs-type">Unit</span>)</span></span></code></pre></div><p>一个 lambda 表达式通过参数的形式被定义在箭头的左边(被圆括号包围)，然后在箭头的右边返<br>回结果值。在这个例子中，我们接收一个 View，然后返回一个 Unit(没有东西)。所以根据这种思<br>想，我们可以把前面的代码简化成这样:</p><div class="hljs"><pre><code class="hljs reasonml">view.set<span class="hljs-constructor">OnClickListener(&#123; <span class="hljs-params">view</span> -&gt; <span class="hljs-params">toast</span>(<span class="hljs-string">"Click"</span>)</span>&#125;)</code></pre></div><p>这是非常棒的简化!当我们定义了一个方法，我们必须使用大括号包围，然后在箭头的左边指定参数， 在箭头的右边返回函数执行的结果。如果左边的参数没有使用到，我们甚至可以省略左边的参数:</p><div class="hljs"><pre><code class="hljs isbl"><span class="hljs-variable">view.setOnClickListener</span>(&#123; <span class="hljs-function"><span class="hljs-title">toast</span>(<span class="hljs-string">"Click"</span>) &#125;)</span></code></pre></div><p>如果这个函数的最后一个参数是一个函数，我们可以把这个函数移动到圆括号外面: </p><div class="hljs"><pre><code class="hljs less"><span class="hljs-selector-tag">view</span><span class="hljs-selector-class">.setOnClickListener</span>() &#123; <span class="hljs-selector-tag">toast</span>(<span class="hljs-string">"Click"</span>) &#125;</code></pre></div><p>并且，最后，如果这个函数只有一个参数，我们可以省略这个圆括号: </p><div class="hljs"><pre><code class="hljs cos"><span class="hljs-keyword">view</span>.setOnClickListener &#123; toast(<span class="hljs-string">"Click"</span>) &#125;</code></pre></div><p>比原始的 Java 代码简短了 5 倍多，并且更加容易理解它所做的事情。非常让人影响深刻。</p><p>inline 内联函数， Anko也是基于这个思想来实现的 Android layout 的 DSL 化。</p><div class="hljs"><pre><code class="hljs kotlin"><span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">testInline</span><span class="hljs-params">(code: () -&gt; <span class="hljs-type">Unit</span>)</span></span> &#123;    code();&#125;testInline &#123;    print(<span class="hljs-string">"af"</span>)&#125;</code></pre></div><p>委托，标准委托，用by<br>lazy 懒加载，就是使用的时候才进行调用，一般用于初始化</p><div class="hljs"><pre><code class="hljs reasonml"><span class="hljs-keyword">val</span> datebase: SQLiteOpenHelper by <span class="hljs-keyword">lazy</span> &#123;    <span class="hljs-constructor">MyDatabaseHelper(<span class="hljs-params">applicationContext</span>)</span>&#125;</code></pre></div><p>observable 观察者</p><div class="hljs"><pre><code class="hljs kotlin"><span class="hljs-keyword">var</span> property <span class="hljs-keyword">by</span> Delegates.observable(<span class="hljs-string">""</span>)&#123;    d,old,new -&gt;  <span class="hljs-comment">// 这个是一个lambda表达式 实际是onchange 源码在下边几行</span>    database.saveChanges(<span class="hljs-keyword">this</span>,new)&#125;<span class="hljs-comment">// 源码</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> <span class="hljs-title">observable</span><span class="hljs-params">(initialValue: <span class="hljs-type">T</span>, <span class="hljs-keyword">crossinline</span> onChange: (<span class="hljs-type">property</span>: <span class="hljs-type">KProperty</span>&lt;*&gt;, <span class="hljs-type">oldValue</span>: <span class="hljs-type">T</span>, <span class="hljs-type">newValue</span>: <span class="hljs-type">T</span>) -&gt; <span class="hljs-type">Unit</span>)</span></span>:    ReadWriteProperty&lt;Any?, T&gt; = <span class="hljs-keyword">object</span> : ObservableProperty&lt;T&gt;(initialValue) &#123;        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">afterChange</span><span class="hljs-params">(property: <span class="hljs-type">KProperty</span>&lt;*&gt;, oldValue: <span class="hljs-type">T</span>, newValue: <span class="hljs-type">T</span>)</span></span> = onChange(property, oldValue, newValue)    &#125;<span class="hljs-comment">// 也可以这么写</span><span class="hljs-keyword">var</span> property <span class="hljs-keyword">by</span> Delegates.observable(<span class="hljs-string">""</span>, onChange = &#123;    property: KProperty&lt;*&gt;, oldValue: String, newValue: String -&gt;    database.saveChanges(oldValue, newValue)&#125;)</code></pre></div><p>Vetoable 否决器（姑且这么叫吧）用于决定一个值是不是可以赋给变量</p><div class="hljs"><pre><code class="hljs haxe"><span class="hljs-comment">//只能是"HAHA"</span><span class="hljs-keyword">var</span> onlyHAHA by Delegates.vetoable(<span class="hljs-string">""</span>, &#123; p, old, <span class="hljs-keyword">new</span> <span class="hljs-type"></span>-&gt;    <span class="hljs-keyword">new</span> <span class="hljs-type"></span>== <span class="hljs-string">"HAHA"</span>&#125;)</code></pre></div><p>Not Null 指定变量不能为空，为null则抛出异常</p><div class="hljs"><pre><code class="hljs lasso"><span class="hljs-built_in">var</span> notNull: <span class="hljs-built_in">String</span> <span class="hljs-keyword">by</span> Delegates.notNull()</code></pre></div><p>从Map中获取映射值；map以构造方法的方式传入bean，bean中属性后添加by map,即可自动匹配,if field_name==map.key then:field_value=map.value</p><p>自定义一个委托，实现一个值只能修改一次</p><div class="hljs"><pre><code class="hljs kotlin"><span class="hljs-comment">// 定义</span><span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NotNullSingleValueVar</span>&lt;<span class="hljs-type">T</span>&gt;</span>() : ReadWriteProperty&lt;Any?, T&gt; &#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> value: T? = <span class="hljs-literal">null</span>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getValue</span><span class="hljs-params">(thisRef: <span class="hljs-type">Any</span>?, property: <span class="hljs-type">KProperty</span>&lt;*&gt;)</span></span>: T &#123;        <span class="hljs-keyword">return</span> value ?: <span class="hljs-keyword">throw</span> IllegalStateException(<span class="hljs-string">"not initialized"</span>)    &#125;    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">setValue</span><span class="hljs-params">(thisRef: <span class="hljs-type">Any</span>?, property: <span class="hljs-type">KProperty</span>&lt;*&gt;, value: <span class="hljs-type">T</span>)</span></span> &#123;        <span class="hljs-keyword">this</span>.value = <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.value == <span class="hljs-literal">null</span>) value <span class="hljs-keyword">else</span> <span class="hljs-keyword">throw</span> IllegalStateException(<span class="hljs-string">"already initialized"</span>)    &#125;&#125;<span class="hljs-comment">//封装</span><span class="hljs-keyword">object</span> DelegatesExt &#123;    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> <span class="hljs-title">notNullSingleValue</span><span class="hljs-params">()</span></span>:            ReadWriteProperty&lt;Any?, T&gt; &#123;        <span class="hljs-keyword">return</span> NotNullSingleValueVar()    &#125;&#125;<span class="hljs-comment">// demo</span>    <span class="hljs-keyword">var</span> notNullSingle: String <span class="hljs-keyword">by</span> DelegatesExt.notNullSingleValue()</code></pre></div><p>object关键字；在参数中，相当于new一个匿名内部类；修饰类，相当于单例模式</p><div class="hljs"><pre><code class="hljs kotlin">view.setOnClickListener(new OnClickListener()&#123; <span class="hljs-meta">@Override</span><span class="hljs-keyword">public</span> void onClick(View v) &#123;Toast.makeText(v.getContext(), <span class="hljs-string">"Click"</span>, Toast.LENGTH_SHORT).show(); &#125;&#125;)<span class="hljs-comment">// 我们将把上面的代码转换成 Kotlin(使用了 Anko 的 toast 函数):</span>view.setOnClickListener(<span class="hljs-keyword">object</span> : OnClickListener &#123; <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onClick</span><span class="hljs-params">(v: <span class="hljs-type">View</span>)</span></span> &#123;toast(<span class="hljs-string">"Click"</span>) &#125;&#125;<span class="hljs-comment">// 简单单例模式</span><span class="hljs-keyword">object</span> Obj&#123;    <span class="hljs-keyword">init</span>&#123;        println(<span class="hljs-string">"object init..."</span>)    &#125;&#125;</code></pre></div><p>泛型函数<br>不仅类可以有类型参数。函数也可以有。类型参数要放在函数名称之前：</p><div class="hljs"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> <span class="hljs-title">singletonList</span><span class="hljs-params">(item: <span class="hljs-type">T</span>)</span></span>: List&lt;T&gt; &#123;    <span class="hljs-comment">// ……</span>&#125;<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> T.<span class="hljs-title">basicToString</span><span class="hljs-params">()</span></span> : String &#123;  <span class="hljs-comment">// 扩展函数</span>    <span class="hljs-comment">// ……</span>&#125;<span class="hljs-comment">//要调用泛型函数，在调用处函数名之后指定类型参数即可：</span><span class="hljs-keyword">val</span> l = singletonList&lt;<span class="hljs-built_in">Int</span>&gt;(<span class="hljs-number">1</span>)</code></pre></div><p>还有好多不容易理解的特性，以后继续更新。</p><p>放个图，哈哈</p><img src="/img/kotlin_haha.jpg" srcset="/img/loading.gif">]]></content>
    
    
    
    <tags>
      
      <tag>Android</tag>
      
      <tag>kotlin</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>非对称加密</title>
    <link href="/2017/12/08/%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/"/>
    <url>/2017/12/08/%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/</url>
    
    <content type="html"><![CDATA[<p>非对称加密有一对公钥和私钥，成对出现，使用时，如果A想给你发消息，你把公钥给A，让A使用公钥对消息进行加密，加密后发给你，然后你用私钥解开，别人虽然能拿到公钥和密文，但是解不开，因为公钥可以加密明文成为密文，但是却无法使用公钥对密文进行解密，只有私钥能够解密公钥加密的东西，而私钥只有你自己有，这就保证了信息的安全性。</p><a id="more"></a><h3 id="神奇的数学"><a href="#神奇的数学" class="headerlink" title="神奇的数学"></a>神奇的数学</h3><p>但是你可能有疑问了，为啥公钥加密了，用公钥却解不开，这么神奇？<br>对，就是这么神奇，这个要从一个牛B的数学现象说起。<br>当然，我说的是非对称加密算法的一种，也是比较常用的一种，这种算法叫RSA。</p><p>这个数学现象就是：两个大素数相乘十分容易，但那时想要对其乘积进行因式分解却极其困难。</p><h3 id="啥是素数"><a href="#啥是素数" class="headerlink" title="啥是素数"></a>啥是素数</h3><p>质数（prime number）又称素数，有无限个。<br>质数定义为在大于1的自然数中，除了1和它本身以外不再有其他因数。</p><p>两个不同的质数一定是互质数。（这个很明显）</p><p>实现RSA还是有些复杂的，需要理解以下公式：</p><h3 id="RSA用到的公式和定理"><a href="#RSA用到的公式和定理" class="headerlink" title="RSA用到的公式和定理"></a>RSA用到的公式和定理</h3><p>一、数和互为素数<br>任何大于1的整数a能被因式分解为如下唯一形式：<br>a=p1p2…pl(p1,p2，…，pl为素数）</p><p>二、模运算<br>①{[a(mod n)]×[b(mod n)]}modn≡（a×b)(mod n)<br>②如果（a×b）=（a×c）（mod n),a与n互素，则<br>b=c(mod n)</p><p>三、费马定理<br>若p是素数，a与p互素，则<br>a^(p-1）≡1 （mod p）</p><p>四、欧拉定理<br>欧拉函数φ（n）表示不大于n且与n互素的正整数的个数。<br>当n是素数，φ（n)=n-1。n=pq,p,q均为素数时，则φ（n)= φ（p）φ（q)=（p-1）（q-1）。<br>对于互素的a和n，有a^φ（n)≡1(mod n)</p><h3 id="RSA实现方式"><a href="#RSA实现方式" class="headerlink" title="RSA实现方式"></a>RSA实现方式</h3><p>RSA的算法涉及三个参数，n、e1、e2。<br>其中，n是两个大质数p、q的积，n的二进制表示时所占用的位数，就是所谓的密钥长度。<br>e1和e2是一对相关的值，e1可以任意取，但要求e1与(p-1）<em>(q-1）互质；再选择e2，要求（e2*e1）mod((p-1）</em>(q-1））=1。<br>（n，e1）,(n，e2）就是密钥对。其中(n，e1）为公钥，(n，e2）为私钥。[1]<br>RSA加解密的算法完全相同，设A为明文，B为密文，则：A=B^e2 mod n；B=A^e1 mod n；（公钥加密体制中，一般用公钥加密，私钥解密）<br>e1和e2可以互换使用，即：<br>A=B^e1 mod n；B=A^e2 mod n;</p><h3 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h3><p>RSA 1024位已经被认为不安全了，因为现在的计算机已经越来越快了，一直增加秘钥的位数也不是长久之计，也许RSA会逐渐被其他算法取代。</p><blockquote><p><a href="https://www.zhihu.com/question/23879943/answer/27383875" target="_blank" rel="noopener">https://www.zhihu.com/question/23879943/answer/27383875</a><br><a href="http://blog.sina.com.cn/s/blog_4a0fa5420101f2lj.html" target="_blank" rel="noopener">http://blog.sina.com.cn/s/blog_4a0fa5420101f2lj.html</a><br><a href="https://baike.baidu.com/item/%E6%AC%A7%E6%8B%89%E5%AE%9A%E7%90%86/891345?fr=aladdin" target="_blank" rel="noopener">https://baike.baidu.com/item/%E6%AC%A7%E6%8B%89%E5%AE%9A%E7%90%86/891345?fr=aladdin</a></p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>加密</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>记一种签名认证方法</title>
    <link href="/2017/12/08/%E8%AE%B0%E4%B8%80%E7%A7%8D%E7%AD%BE%E5%90%8D%E8%AE%A4%E8%AF%81%E6%96%B9%E6%B3%95/"/>
    <url>/2017/12/08/%E8%AE%B0%E4%B8%80%E7%A7%8D%E7%AD%BE%E5%90%8D%E8%AE%A4%E8%AF%81%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>数字签名（又称公钥数字签名、电子签章）是一种类似写在纸上的普通的物理签名，但是使用了公钥加密领域的技术实现，用于鉴别数字信息的方法。一套数字签名通常定义两种互补的运算，一个用于签名，另一个用于验证。</p><p>数字签名，就是只有信息的发送者才能产生的别人无法伪造的一段数字串，这段数字串同时也是对信息的发送者发送信息真实性的一个有效证明。</p><p>数字签名是非对称密钥加密技术与数字摘要技术的应用。</p><a id="more"></a><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>数字签名的文件的完整性是很容易验证的（不需要骑缝章，骑缝签名，也不需要笔迹专家），而且数字签名具有不可抵赖性（不需要笔迹专家来验证）。</p><p>简单地说,所谓数字签名就是附加在数据单元上的一些数据,或是对数据单元所作的密码变换。这种数据或变换允许数据单元的接收者用以确认数据单元的来源和数据单元的完整性并保护数据,防止被人(例如接收者)进行伪造。它是对电子形式的消息进行签名的一种方法,一个签名消息能在一个通信网络中传输。<br>基于公钥密码体制和私钥密码体制都可以获得数字签名,主要是基于公钥密码体制的数字签名。包括普通数字签名和特殊数字签名。<br>普通数字签名算法有RSA、ElGamal、Fiat-Shamir、Guillou- Quisquarter、Schnorr、Ong-Schnorr-Shamir数字签名算法、Des/DSA,椭圆曲线数字签名算法和有限自动机数字签名算法等。<br>特殊数字签名有盲签名、代理签名、群签名、不可否认签名、公平盲签名、门限签名、具有消息恢复功能的签名等,它与具体应用环境密切相关。显然,数字签名的应用涉及到法律问题,美国联邦政府基于有限域上的离散对数问题制定了自己的数字签名标准(DSS)。</p><blockquote><p><a href="https://baike.baidu.com/item/%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D/212550" target="_blank" rel="noopener">数字签名-百度百科</a></p></blockquote><h2 id="一种实现方式"><a href="#一种实现方式" class="headerlink" title="一种实现方式"></a>一种实现方式</h2><p>此方法不属于非对称加密。</p><p>首先定义几个概念</p><blockquote></blockquote><p>token 服务端生成，每5分钟变一次，有15分钟的有效期<br>sign 签名，客户端生成<br>salt 盐，用于加盐<br>timestamp 时间戳</p><p>首先，客户端Client(简称C)向服务端Server(简称S)请求token，token可以通过登录验证生成，并和C的SN绑定，C的所有请求都要携带SN和timestamp，token获取成功后，由C保存在本地。</p><p>平常的请求，C端取得http requestbody，使用token+salt做秘钥，body+时间戳做明文进行加密，生成sign，进行请求，S端拿到request，取得requestbody，使用服务器上缓存的token+salt对requestbody+时间戳进行加密（B、C端salt相同，或者定期同步），获得B_sign，通过对比sign和B_sign，确定请求的完整性和合法性。</p><p>通过登录获取token，还应该返回authToken，token每五分钟改变一次，客户端应当可以使用authToken去服务器获取新token。authToken的有效时间应该更长，如果无法使用authToken获取token，说明用户需要重新登陆。<br>salt十分重要，为防止反编译，最好使用jni写在so库。<br>服务端需要验证请求的时间，如果C端请求的timestamp与服务器相差超过5分钟，则视为非法请求。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Android</tag>
      
      <tag>加密</tag>
      
      <tag>安全</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mac SSH&amp;NFS Ubuntu</title>
    <link href="/2017/11/17/Mac-SSH-NFS-Ubuntu/"/>
    <url>/2017/11/17/Mac-SSH-NFS-Ubuntu/</url>
    
    <content type="html"><![CDATA[<p>两台电脑，Ubuntu、MacBook；<br>Ubuntu性能强，用于编译Android源码；<br>MacBook用户体验好，用于写代码；<br>需求是：使用MacBook操纵Ubuntu；<br>方案是：</p><ol><li>使用SSH操作Ubuntu；</li><li>使用mount NFS挂载代码到MacBook，使用Android Studio修改代码；<a id="more"></a></li></ol><h1 id="SSH"><a href="#SSH" class="headerlink" title="SSH"></a>SSH</h1><p>首先搞定SSH， 以下是服务端和客户端配置。</p><h2 id="服务端（Ubuntu）"><a href="#服务端（Ubuntu）" class="headerlink" title="服务端（Ubuntu）"></a>服务端（Ubuntu）</h2><div class="hljs"><pre><code class="hljs pgsql">sudo  apt-<span class="hljs-keyword">get</span> install openssh-<span class="hljs-keyword">server</span></code></pre></div><p>如果安装失败，缺少依赖库，可以通过添加apt软件源的方式解决。如果还是无法安装，就需要一个一个依赖库的下载。<br>常用库下载地址：</p><p><a href="http://launchpadlibrarian.net/130237887/libtasn1-3-dbg_2.14-2_i386.deb" target="_blank" rel="noopener">http://launchpadlibrarian.net/130237887/libtasn1-3-dbg_2.14-2_i386.deb</a><br><a href="http://launchpadlibrarian.net/130237888/libtasn1-3_2.14-2_i386.deb" target="_blank" rel="noopener">http://launchpadlibrarian.net/130237888/libtasn1-3_2.14-2_i386.deb</a><br><a href="http://launchpadlibrarian.net/130237883/libtasn1-3_2.14-2_amd64.deb" target="_blank" rel="noopener">http://launchpadlibrarian.net/130237883/libtasn1-3_2.14-2_amd64.deb</a><br><a href="http://launchpadlibrarian.net/130237889/libtasn1-3-bin_2.14-2_i386.deb" target="_blank" rel="noopener">http://launchpadlibrarian.net/130237889/libtasn1-3-bin_2.14-2_i386.deb</a><br><a href="http://security.ubuntu.com/ubuntu/pool/main/g/gnutls26/libgnutls26_2.12.23-12ubuntu2.8_amd64.deb" target="_blank" rel="noopener">http://security.ubuntu.com/ubuntu/pool/main/g/gnutls26/libgnutls26_2.12.23-12ubuntu2.8_amd64.deb</a><br><a href="https://launchpadlibrarian.net/85099924/libtasn1-3_2.10-1ubuntu1_amd64.deb" target="_blank" rel="noopener">https://launchpadlibrarian.net/85099924/libtasn1-3_2.10-1ubuntu1_amd64.deb</a><br><a href="https://launchpadlibrarian.net/85099923/libtasn1-3-dbg_2.10-1ubuntu1_amd64.deb" target="_blank" rel="noopener">https://launchpadlibrarian.net/85099923/libtasn1-3-dbg_2.10-1ubuntu1_amd64.deb</a><br><a href="http://launchpadlibrarian.net/154418135/libplist1_1.10-1_amd64.deb" target="_blank" rel="noopener">http://launchpadlibrarian.net/154418135/libplist1_1.10-1_amd64.deb</a><br><a href="http://launchpadlibrarian.net/154432952/libusbmuxd2_1.0.8-2ubuntu1_amd64.deb" target="_blank" rel="noopener">http://launchpadlibrarian.net/154432952/libusbmuxd2_1.0.8-2ubuntu1_amd64.deb</a><br><a href="https://launchpadlibrarian.net/264961543/libusbmuxd-tools_1.0.10-3_amd64.deb" target="_blank" rel="noopener">https://launchpadlibrarian.net/264961543/libusbmuxd-tools_1.0.10-3_amd64.deb</a><br><a href="https://launchpadlibrarian.net/160013007/libgcrypt11_1.5.3-2ubuntu4_amd64.deb" target="_blank" rel="noopener">https://launchpadlibrarian.net/160013007/libgcrypt11_1.5.3-2ubuntu4_amd64.deb</a><br><a href="https://launchpadlibrarian.net/160012809/libgcrypt11_1.5.3-2ubuntu4.debian.tar.gz" target="_blank" rel="noopener">https://launchpadlibrarian.net/160012809/libgcrypt11_1.5.3-2ubuntu4.debian.tar.gz</a></p><p>启动ssh server</p><div class="hljs"><pre><code class="hljs routeros">sudo /etc/init.d/ssh start <span class="hljs-comment"># 或者 </span>service ssh start</code></pre></div><h2 id="客户端（MacBook）"><a href="#客户端（MacBook）" class="headerlink" title="客户端（MacBook）"></a>客户端（MacBook）</h2><p>应该都已经安装了SSH，没有安装的话可以用homebrew安装。</p><p>安装后，使用以下命令访问服务器就可以了。</p><div class="hljs"><pre><code class="hljs nginx"><span class="hljs-attribute">ssh</span> username<span class="hljs-variable">@ipAddress</span></code></pre></div><h2 id="免密登录"><a href="#免密登录" class="headerlink" title="免密登录"></a>免密登录</h2><p>将客户端<del>/.ssh/id_rsa.pub  的内容添加到服务端的</del>/.ssh/authorized_keys文件中（没有该文件就创建一个）。</p><h2 id="服务器别名设置"><a href="#服务器别名设置" class="headerlink" title="服务器别名设置"></a>服务器别名设置</h2><p>使用cd ~/.ssh/ 进入ssh目录，会看到有config、known_hosts两个文件，一般的没有设置的话，只会有known_hosts，可以使用touch config命令创建config文件。</p><p>使用vim编辑config文件，添加如下内容：</p><div class="hljs"><pre><code class="hljs routeros">Host servernameHostName 1xx.1xx.1xx.67User rootIdentitiesOnly <span class="hljs-literal">yes</span></code></pre></div><p>其中： </p><ol><li>Host 后边的是名称，以后可以根据这个名称进行访问； </li><li>HostName是你的主机IP地址； </li><li>User为主机登录的用户名； </li><li>IdentitiesOnly yes固有配置；</li></ol><p>这样就可以用以下命令访问服务器了。</p><div class="hljs"><pre><code class="hljs ebnf"><span class="hljs-attribute">ssh servername</span></code></pre></div><hr><h1 id="NFS"><a href="#NFS" class="headerlink" title="NFS"></a>NFS</h1><p>NFS（Network File System）是挂载硬盘的一种方式，使用mount命令挂载。记得使用sudo。</p><div class="hljs"><pre><code class="hljs elm"><span class="hljs-title">sudo</span> mount -t nfs -o resv<span class="hljs-keyword">port</span>,rw ipAddress:/home/xxx  ~/xxxx</code></pre></div><h2 id="服务器端配置（Ubuntu）"><a href="#服务器端配置（Ubuntu）" class="headerlink" title="服务器端配置（Ubuntu）"></a>服务器端配置（Ubuntu）</h2><ol><li>安装Ubuntu nfs服务器端：</li></ol><div class="hljs"><pre><code class="hljs pgsql">sudo apt-<span class="hljs-keyword">get</span> install nfs-kernel-<span class="hljs-keyword">server</span></code></pre></div><ol start="2"><li>安装nfs的客户端：<br>(在安装nsf-kernel-server的时候，也会安装nfs-commom。如果没有安装这个软件包，则要执行1.2中的命令了)</li></ol><div class="hljs"><pre><code class="hljs armasm"><span class="hljs-symbol">sudo</span> apt-<span class="hljs-meta">get</span> install nfs-<span class="hljs-meta">common</span>​</code></pre></div><ol start="3"><li>设置共享的文件目录</li></ol><div class="hljs"><pre><code class="hljs arduino">sudo <span class="hljs-built_in">mkdir</span> <span class="hljs-comment">/***/</span>***</code></pre></div><ol start="4"><li>修改配置文件/etc/exports</li></ol><p>在最后一行添加：</p><div class="hljs"><pre><code class="hljs lisp">/home/USER/nfs *(<span class="hljs-name">rw</span>,sync,no_root_squash,no_subtree_check)</code></pre></div><blockquote><p>前面那个目录是与nfs服务客户端共享的目录，*代表允许所有的网段访问（也可以使用具体的IP）<br>rw：挂接此目录的客户端对该共享目录具有读写权限<br>sync：资料同步写入内存和硬盘<br>no_root_squash：客户机用root访问该共享文件夹时，不映射root用户。（root_squash：客户机用root用户访问该共享文件夹时，将root用户映射成匿名用户）<br>no_subtree_check：不检查父目录的权限。</p></blockquote><ol start="5"><li>nfs是一个RPC程序，使用它前，需要映射好端口，通过rpcbind 设定：</li></ol><div class="hljs"><pre><code class="hljs routeros">sudo<span class="hljs-built_in"> service </span>rpcbind restart restart</code></pre></div><ol start="6"><li>重启nfs服务：</li></ol><div class="hljs"><pre><code class="hljs routeros">sudo<span class="hljs-built_in"> service </span>restartnfs-kernel-server restart</code></pre></div><blockquote><p>如果修改了/etc/exports，记得要重启服务，即5、6两步。</p></blockquote><h2 id="客户端配置（MacBook）"><a href="#客户端配置（MacBook）" class="headerlink" title="客户端配置（MacBook）"></a>客户端配置（MacBook）</h2><p>直接挂载即可：</p><div class="hljs"><pre><code class="hljs elm"><span class="hljs-title">sudo</span> mount -t nfs -o resv<span class="hljs-keyword">port</span>,rw ipAddress:/home/xxx  ~/xxxx</code></pre></div><h2 id="无写入权限问题"><a href="#无写入权限问题" class="headerlink" title="无写入权限问题"></a>无写入权限问题</h2><p>需要将服务器的共享目录更改权限，即添加本组和其他用户的读写权限。</p><div class="hljs"><pre><code class="hljs awk">sudo chmod -R go+rw <span class="hljs-regexp">/xxx/</span>xxx</code></pre></div><h2 id="使用Android-Studio"><a href="#使用Android-Studio" class="headerlink" title="使用Android Studio"></a>使用Android Studio</h2><p>挂载成功后，即可以像操作本地文件一样操作服务器了，用Android Studio打开相应的工程即可。</p><hr><p>The End.</p>]]></content>
    
    
    
    <tags>
      
      <tag>工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>好久没写博客了，原因竟然是。。</title>
    <link href="/2017/11/14/%E5%A5%BD%E4%B9%85%E6%B2%A1%E5%86%99%E5%8D%9A%E5%AE%A2%E4%BA%86%EF%BC%8C%E5%8E%9F%E5%9B%A0%E7%AB%9F%E7%84%B6%E6%98%AF%E3%80%82%E3%80%82/"/>
    <url>/2017/11/14/%E5%A5%BD%E4%B9%85%E6%B2%A1%E5%86%99%E5%8D%9A%E5%AE%A2%E4%BA%86%EF%BC%8C%E5%8E%9F%E5%9B%A0%E7%AB%9F%E7%84%B6%E6%98%AF%E3%80%82%E3%80%82/</url>
    
    <content type="html"><![CDATA[<p>换了工作后，因为<a id="more"></a>公司配的电脑没装写博客的环境。</p>]]></content>
    
    
    
    <tags>
      
      <tag>计划</tag>
      
      <tag>生活</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android面试题集第一发</title>
    <link href="/2017/08/03/Android%E9%9D%A2%E8%AF%95%E9%A2%98%E9%9B%86%E7%AC%AC%E4%B8%80%E5%8F%91/"/>
    <url>/2017/08/03/Android%E9%9D%A2%E8%AF%95%E9%A2%98%E9%9B%86%E7%AC%AC%E4%B8%80%E5%8F%91/</url>
    
    <content type="html"><![CDATA[<p>Android Common Interview Questions</p><a id="more"></a><h1 id="Android-Common-Interview-Questions"><a href="#Android-Common-Interview-Questions" class="headerlink" title="Android-Common-Interview-Questions"></a>Android-Common-Interview-Questions</h1><blockquote><p><strong>面试题总结</strong></p></blockquote><p>##通用</p><ul><li>安卓学习途径, 寻找资料学习的博客网站  </li><li>AndroidStudio使用, 插件使用  </li><li>安卓和苹果的区别  </li></ul><p>##初级(基础1年左右)</p><ul><li>四大组件  </li><li>五大存储方式  </li><li>Layout布局有哪几种 FrameLayout什么时候用  </li><li>ListView的优化  </li><li>点击事件设置监听的几种方式  </li><li>安卓主线程和子线程的关系  </li><li>Activity生命周期 onStart onResume区别  </li><li>Fragment生命周期 Activity和Fragment区别  </li><li>页面之间如何传递数据, 如果传递一个对象如何处理, 如何传递集合  </li><li>dp px sp的区别  </li><li>gravity和layout_gravity的区别  </li><li>margin和padding的区别  </li><li>weight的作用  </li><li>Handler机制  </li><li>什么的ANR, 如何避免  </li><li>显式意图和隐式意图区别,隐式意图的使用  </li><li>广播几种接收方式, 广播有几种类型, 区别  </li><li>开启Service的几种方式, 区别, Service和Activity之间如何传递数据  </li><li>Service中如果要start一个Activity要如何特殊处理,为什么<br>…<br>还有很多,都是网上常见面试题, 百度搜看看, 背下来即可  </li></ul><p>##中级(2~3年, 也问部分基础问题)</p><ul><li>自定义控件  </li><li>常用开源框架的使用  </li><li>动画类型  </li><li>任务栈,页面启动方式    </li><li>Material Design / 新控件RecyclerView CardView等使用  </li><li>图片压缩和双缓存原理  </li><li>多层View的onTouch事件分发<br>…<br>简单了解记下来, 最好自己写个demo试验下</li></ul><p>##高级(3年+, 也问部分中级问题)</p><ul><li>Android绘制原理 onMeasure onLayout onDraw作用  </li><li>MeasureSpec的集中类型区别和作用  </li><li>自定义控件  </li><li>什么是MVC MVP,区别  </li><li>响应式编程  </li><li>常见开源框架源码  </li><li>单元测试常用框架和实际使用 场景<br>…<br>需要阅读源码和项目编码练习  </li></ul><hr><blockquote><p>其他</p></blockquote><p>##多媒体</p><ul><li>音频的环绕声和混响等如何处理  </li><li>音频录制播放  </li><li>视频的录制和播放  </li><li>播放使用的常用框架  </li><li>Android原生支持格式  </li><li>软解码硬解码的区别  </li><li>如果要做一个按住屏幕右侧滑动调整声音功能如何处理<br>…<br>特殊公司做这方面相关的会问的多</li></ul><hr><p>#Android<br>##一.基础</p><ol><li><p>四大组件,五大布局. </p><ul><li>四大组件:Activity Service ContentProvider BroadCastReceiver</li><li>五大布局:线性布局 相对布局 帧布局 表格布局 帧布局</li></ul></li><li><p>数据持久化几种方式,都有什么.    </p><p>五种方式:文件存储 数据库 SharedPreferences 网络 内容提供者</p></li><li><p>有哪些种动画,具体说一下区别.    </p></li><li><p>Activity的生命周期,并说明在Activity的哪个特定时刻会执行哪个特定的方法.<strong>要理解透彻</strong>    </p></li><li><p>Fragment的生命周期,同上.    </p></li><li><p>Service的生命周期,根据不同的启动方式有不同的生命周期.    </p></li><li><p>ContentProvider的作用是干嘛的,如何使用.    </p></li><li><p>BroadcastReceiver分为几种.Broadcast有几种.    </p></li><li><p>原生的网络请求是什么.    </p></li><li><p>原生的数据库是什么.    </p></li><li><p>请求回来的网络数据如何解析.    </p></li><li><p>ADT/ADB/SDK/ANR/OOM都是什么意思.    </p></li><li><p>当前的SDK最高版本是多少,AS的版本是多少.    </p></li><li><p>6.0与7.0均新加的什么特性.    </p></li><li><p>AS的常用快捷键.    </p></li><li><p>什么情况下会导致ANR,如何避免.    </p></li><li><p>ListView的运行机制.    </p></li><li><p>适配器的优化方式,适配器几个方法的意义.    </p></li><li><p>ListView如何加载不同的行布局.    </p></li><li><p>如何解决和避免内存泄露.    </p></li><li><p>横竖屏切换的时候Activity会重新加载布局,那么数据如何保存.    </p></li><li><p>你常用哪种Http请求方式.(Post和Get),二者的区别.    </p></li><li><p>简述Http,TCP/IP,Socket三者的关系.    </p></li><li><p>说一下你所了解的网络请求框架,都有什么.他们之间的区别.    </p></li><li><p>Volley的基本使用方法,封装原则.    </p></li><li><p>项目中你是如何使用Volley的,是否对Request类进行了重写.    </p></li><li><p>Volley能不能进行同步的网络请求,如果可以,怎么做.    </p></li><li><p>Volley加载图片的方法用过没有,图片的缓存是如何实现的.    </p></li><li><p>OkHttp的使用方式.与Volley有何不同.    </p></li><li><p>OkHttp如何下载文件,Volley能不能下载.    </p></li><li><p>大文件的下载过程你一般是如何做的.    </p></li><li><p>用过Retrofit么,对它进行一下简单的介绍,包括使用方式.    </p></li><li><p>你是如何进行数据库的操作的.    </p></li><li><p>图片你是如何加载的.    </p></li><li><p>design包下的控件都使用过什么.    </p></li><li><p>知道材料设计(material design)么.    </p></li><li><p>Fragment有几种使用方式.    </p></li><li><p>Serializable 和 Parcelable的联系和区别.    </p></li><li><p>如何将Activity设置为窗口模式.    </p></li></ol><p>##二.进阶</p><ol><li><p>简述Handler机制的原理.    </p></li><li><p>说一下事件分发机制.    </p></li><li><p>View的绘制过程.    </p></li><li><p>都有哪些方式可以实现进程间通信.    </p></li><li><p>代码混淆是干嘛的.    </p></li><li><p>gradle是干嘛的.    </p></li><li><p>关于内存优化,你都做过什么.    </p></li><li><p>Activity的启动方式.    </p></li><li><p><code>Activity</code>A启动了<code>Activity</code>B,那么A的<code>onPause()</code>方法和B的<code>onCreate()</code>方法谁先执行.    </p></li><li><p>Fragment与宿主Activity进行通信,有哪些方式,请说明.    </p></li><li><p>一般来说,一个应用程序一共有多少个Context.    </p><p>Context的个数等于Activity的个数 + Service个数 +  1 (Application也是Context)</p></li><li><p>如何一次性退出所有的Activity,有哪些解决方案.    </p></li></ol><h1 id="Java面试题"><a href="#Java面试题" class="headerlink" title="Java面试题"></a>Java面试题</h1><p>##一.基础</p><ol><li><p>Java面向对象的三大特性,并说出你的理解.    </p></li><li><p>Collection和Collections有什么区别.</p><p>Collection是一个集合接口,它提供了对集合对象进行基本糙所的通用接口方法.Collection接口在Java类库中有很多具体的实现,例如LinkedList Set等;</p><p>Collections是一个包装类它包含有各种有关集合操作的<strong>静态多态方法</strong>。此类<strong>不能实例化</strong>，是一<strong>个工具类</strong>，有类似排序等功能,服务于Java的Collection框架。</p></li><li><p>抽象类与接口的区别.</p><p>抽象类可以有构造方法 接口不行</p><p>抽象类可以有普通成员变量 接口没有</p><p>抽象类可以有非抽象的方法 接口必须全部抽象</p><p>抽象类的访问类型都可以 接口只能是 public abstract</p><p>一个类可以实现多个接口 但只能继承一个抽象类</p></li><li><p>类能不能多继承类,能不能多实现接口.接口能不能多继承接口,接口能不能实现接口.</p><p>一个类只能继承一个类,但是可以实现多个接口;</p><p>一个接口可以继承多个接口,但是不能实现接口</p></li><li><p>重写(覆写)与重载的区别.</p><ul><li>重写是子类对父类的函数进行重新定义,即子类中定义的方法与其父类具有相同的方法名和参数,重写的时候子类不能函数的访问权限不能少于父类的</li></ul><ul><li>重载(Overloading)是 是在类中可以创建多个方法，它们具有相同的名字，但具有不同的参数和不同的定义。调用方法时通过传递给它们的不同参数个数和参数类型来决定具体使用哪个方法, 这就是多态性。</li></ul></li><li><p>构造方法能不能被覆写.</p></li><li><p>覆写父类的方法,方法的哪个组成部分可以不同.</p></li><li><p>能不能继承String类.</p><p>不能,String是final类型的,不能被继承</p></li><li><p>String/StringBuffer/StringBuilder的区别.</p></li><li><p>final/finally/finalize的区别.</p></li></ol><ul><li>final 用于声明属性,方法和类, 分别表示属性不可变, 方法不可覆盖, 类不可继承.</li><li>finally 是异常处理语句结构的一部分，表示总是执行该代码块<ul><li>finalize 是Object类的一个方法，在垃圾收集器执行的时候会调用被回收对象的此方法，可以覆盖此方法提供垃圾收集时的其他资源回收，例如关闭文件等. JVM不保证此方法总被调用.</li></ul></li></ul><ol start="11"><li><p>throw与throws的作用.</p></li><li><p>try…catch…finally语句块的用法,哪部分可以省略.</p></li><li><p>数据流的分类,常用的数据流.</p></li><li><p>基本概念,JDK/JRE/JVM</p><ul><li><p>JDK Java Development Kit Java开发包.包含JRE和Java的常用类库.</p></li><li><p>JRE Java Runtime Environment Java运行时环境.可以单独在Oracle官网下载,运行Java程序必须安装.</p></li><li><p>JVM Java Virtual Machine Java虚拟机.Oracle官网不提供单独下载,集成在JRE中.Java程序最终运行在JVM中.<br>在搭建环境时,只需要安装JDK即可.</p></li></ul></li><li><p>内部类与静态内部类有什么区别.</p></li><li><p>switch能否作用在byte/char/long/String上.</p></li><li><p>toString/equals/hashCode分别是谁的方法,一般用来干嘛.</p></li><li><p>Java中如何退出多重循环.</p></li></ol><ul><li>如下所示:<div class="hljs"><pre><code class="hljs angelscript"><span class="hljs-comment">// 标记双重循环开始的位置</span>ABC:<span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">10</span>; j++) &#123;        <span class="hljs-comment">// 在某个时刻结束双重循环</span>        <span class="hljs-keyword">break</span> ABC;        &#125;&#125;</code></pre></div></li></ul><ol start="91"><li>实例方法可不可以访问静态属性,静态方法可不可以访问实例属性.</li></ol><p>##二.进阶</p><ol><li><p>Java中Class类是用来干嘛的.</p></li><li><p>说一下反射可以干什么.</p></li><li><p>开启线程有几种方式,线程池的执行原理.</p></li><li><p>Java中存在几种引用的方式.</p><ul><li><p>强引用:如果一个对象具有强引用，那垃圾回收器绝不会回收它。当内存空间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足的问题。</p></li><li><p>软引用:如果一个对象具有软引用，内存空间足够，垃圾回收器就不会回收它；如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。SoftReference的特点是它的一个实例保存对一个Java对象的软引用， 该软引用的存在不妨碍垃圾收集线程对该Java对象的回收。</p></li><li><p>弱引用:只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它 所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。</p></li><li><p>虚引用:如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。虚引用主要用来跟踪对象被垃圾回收的活动。虚引用与软引用和弱引用的一个区别在于：虚引用必须和引用队列（ReferenceQueue）联合使用。</p><table><thead><tr><th>引用类型</th><th>被GC回收时间</th><th>用途</th><th>生存时间</th></tr></thead><tbody><tr><td>强引用</td><td>从来不会</td><td>对象的一般形态</td><td>JVM停止运行时</td></tr><tr><td>软引用</td><td>内存不足时</td><td>对象缓存</td><td>内存不足时终止</td></tr><tr><td>弱引用</td><td>在GC运行时</td><td>对象缓存</td><td>GC运行后停止</td></tr></tbody></table></li></ul></li><li><p>Java的垃圾回收机制.</p></li><li><p>存在继承关系时,子类与父类构造方法的调用顺序.</p></li><li><p>Error与Exception有什么区别.</p></li><li><p>List/Set/Map三者的区别.</p></li><li><p>如何比较两个对象的大小.或者换句话说,如何让对象之间有可比性.</p></li><li><p>面向对象的六大原则.</p></li><li><p>简述一下你了解的设计模式.</p></li><li><p>单例模式什么情况下会失效.</p></li><li><p>内存泄露与内存溢出.</p></li></ol><hr><h1 id="Android面试题"><a href="#Android面试题" class="headerlink" title="Android面试题"></a>Android面试题</h1><ol><li><p>什么是数据结构？<br> 数据结构是一门研究非数值计算的程序设计问题中的操作对象，以及它们之间的关系和操作等相关问题的学科.<br> 程序设计 = 数据结构 + 算法<br> 传统上，我们把数据结构分为逻辑结构和物理结构。<br> 逻辑结构：是指数据对象中数据元素之间的相互关系，也是我们今后最需要关注和讨论的问题。<br> {</p><div class="hljs"><pre><code>集合结构(仅仅同属一个集合),线性结构（一对一的关系），　树形结构（一对多的层次关系），　图形结构（多对多的关系）</code></pre></div><p> }<br> 物理结构：是指数据的逻辑结构在计算机中的存储形式。<br> ｛</p><div class="hljs"><pre><code>顺序存储：是把数据元素存放在地址连续的存储单元里，其数据间的逻辑关系和物理关系是一致的。例如我们编程语言的数组结构就是这样滴。链式存储：是把数据元素存放在任意的存储单元里，这组存储单元可以是连续的，也可以是不连续的。（因此需要用一个指针存放数据元素的地址，这样子通过地址就可以找到相关联数据元素的位置。）</code></pre></div><p> ｝</p></li><li><p>算法<br> 算法是解决特定问题求解步骤的描述，在计算机中表现为指令的有限序列，并且每条指令表示一个或多个操作。</p><p> 算法的特征：输入、输出、有穷性、确定性和可行性。<br> 输入：算法具有零个或多个输入。<br> 输出：算法至少有一个或多个输出。<br> 有穷性：指算法在执行有限的步骤之后，自动结束而不会出现无限循环，并且每一个步骤在可接受的时间内完成。<br> 确定性：算法的每一个步骤都具有确定的含义，不会出现二义性。<br> 可行性：算法的每一步都必须是可行的，也就是说，每一步都能够通过执行有限次数完成。</p><p> 算法设计的要求：<br> 正确性：算法的正确性是指算法至少应该具有输入、输出和加工处理无歧义性、能正确反映问题的需求、能够得到问题的正确答案。<br> 大体分为以下四个层次：<br> 算法程序没有语法错误。<br> 算法程序对于合法输入能够产生满足要求的输出。<br> 算法程序对于非法输入能够产生满足规格的说明。<br> 算法程序对于故意刁难的测试输入都有满足要求的输出结果。<br> 可读性：算法设计另一目的是为了便于阅读、理解和交流。<br> 健壮性：当输入数据不合法时，算法也能做出相关处理，而不是产生异常、崩溃或莫名其妙的结果。<br> 时间效率高和存储量低：<br>３. 时间复杂度和空间复杂度</p> <div class="hljs"><pre><code class="hljs excel"><span class="hljs-built_in">int</span> i, <span class="hljs-built_in">sum</span> = <span class="hljs-number">0</span>, <span class="hljs-built_in">n</span> = <span class="hljs-number">100</span>;   // 执行<span class="hljs-number">1</span>次for( i=<span class="hljs-number">1</span>; i &lt;= <span class="hljs-built_in">n</span>; i++ )    // 执行了<span class="hljs-built_in">n</span>+<span class="hljs-number">1</span>次&#123;   <span class="hljs-built_in">sum</span> = <span class="hljs-built_in">sum</span> + i;         // 执行<span class="hljs-built_in">n</span>次&#125;</code></pre></div> <div class="hljs"><pre><code class="hljs angelscript"><span class="hljs-built_in">int</span> sum = <span class="hljs-number">0</span>, n = <span class="hljs-number">100</span>;     <span class="hljs-comment">// 执行1次</span>sum = (<span class="hljs-number">1</span>+n)*n/<span class="hljs-number">2</span>;          <span class="hljs-comment">// 执行1次</span></code></pre></div><p> 第一种算法执行了1+(n+1)+n=2n+2次。<br> 第二种算法，是1+1=2次<br> 我们研究算法的复杂度，侧重的是研究算法随着输入规模扩大增长量的一个抽象，而不是精确地定位需要执行多少次。<br> 我们在分析一个算法的运行时间时，重要的是把基本操作的数量和输入模式关联起来。<br> 函数的渐近增长：给定两个函数f(n)和g(n)，如果存在一个整数N，使得对于所有的n&gt;N，f(n)总是比g(n)大。那么，我们说f(n)的增长渐近快于g(n)。<br> 判断一个算法的效率时，函数中的常数和其他次要项常常可以忽略，而更应该关注主项（最高项）的阶数。<br> 算法时间复杂度的定义：在进行算法分析时，语句总的执行次数T(n)是关于问题规模n的函数，进而分析T(n)随n的变化情况并确定T(n)的数量级。<br> 算法的时间复杂度，也就是算法的时间量度，记作：T(n)= O(f(n))。<br> 它表示随问题规模n的增大，算法执行时间的增长率和f(n)的增长率相同，称作算法的渐近时间复杂度，简称为时间复杂度。其中f(n)是问题规模n的某个函数。<br> 这样用大写O()来体现算法时间复杂度的记法，我们称之为大O记法。<br> 一般情况下，随着输入规模n的增大，T(n)增长最慢的算法为最优算法。<br> 显然，由此算法时间复杂度的定义可知，我们的三个求和算法的时间复杂度分别为O(1)，O(n)，O(n^2)。</p><p> 推导大O阶方法:<br> 用常数1取代运行时间中的所有加法常数。<br> 在修改后的运行次数函数中，只保留最高阶项。<br> 如果最高阶项存在且不是1，则去除与这个项相乘的常数。<br> 得到的最后结果就是大O阶。<br> 线性阶:一般含有非嵌套循环涉及线性阶，线性阶就是随着问题规模n的扩大，对应计算次数呈直线增长。<br> 平方阶:<br> 对数阶:<br> 在应用中，这是一种最重要的需求，通常除非特别指定，我们提到的运行时间都是最坏情况的运行时间。</p><p> 算法的空间复杂度:<br> 算法的空间复杂度通过计算算法所需的存储空间实现，算法的空间复杂度的计算公式记作：S(n)=O(f(n))，其中，n为问题的规模，f(n)为语句关于n所占存储空间的函数。</p></li><li><p>线性表<br> 线性表（List）：由零个或多个数据元素组成的有限序列。<br> 首先它是一个序列，也就是说元素之间是有个先来后到的<br> 若元素存在多个，则第一个元素无前驱，而最后一个元素无后继，其他元素都有且只有一个前驱和后继。<br> 另外，线性表强调是有限的，事实上无论计算机发展到多强大，它所处理的元素都是有限的。<br> 若将线性表记为（a1,…,ai-1,ai,ai+1,…an）,则表中ai-1领先于ai,ai领先于ai+1,称ai-1是ai的直接前驱元素,ai+1是ai的直接后继元素。<br> 所以线性表元素的个数n(n&gt;=0)定义为线性表的长度，当n=0时，称为空表。</p><p> 第一个元素无前驱，而最后一个元素无后继，其他元素都有且只有一个前驱和后继。</p><p> 数据类型：是指一组性质相同的值的集合及定义在此集合上的一些操作的总称。<br> {</p><div class="hljs"><pre><code>原子类型：不可以再分解的基本类型，例如整型、浮点型、字符型等。结构类型：由若干个类型组合而成，是可以再分解的，例如整型数组是由若干整型数据组成的。</code></pre></div><p> }<br> 抽象：是指抽取出事物具有的普遍性的本质。它要求抽出问题的特征而忽略非本质的细节，是对具体事物的一个概括。抽象是一种思考问题的方式，它隐藏了繁杂的细节。<br> 我们对已有的数据类型进行抽象，就有了抽象数据类型。<br> 抽象数据类型（Abstract Data Type，ADT）是指一个数学模型及定义在该模型上的一组操作。<br> 抽象数据类型的定义仅取决于它的一组逻辑特性，而与其在计算机内部如何表示和实现无关。<br> “抽象”的意义在于数据类型的数学抽象特性。<br> 描述抽象数据类型的标准格式：<br> ADT 抽象数据类型名<br> Data<br> 数据元素之间逻辑关系的定义</p><div class="hljs"><pre><code>Operation</code></pre></div><p> 操作<br> endADT</p><p> 所谓抽象数据类型就是把数据类型和相关操作捆绑在一起。<br> 总结下，顺序存储结构封装需要三个属性:<br> 存储空间的起始位置，数组data，它的存储位置就是线性表存储空间的存储位置。<br> 线性表的最大存储容量：数组的长度MaxSize。<br> 线性表的当前长度：length。</p><p> 数组的长度是存放线性表的存储空间的总长度，一般初始化后不变。<br> 而线性表的当前长度是线性表中元素的个数，是会变化的。</p><p> 线性表顺序存储结构的优缺点:<br> 线性表的顺序存储结构，在存、读数据时，不管是哪个位置，时间复杂度都是O(1)。而在插入或删除时，时间复杂度都是O(n)。<br> 优点：<br> 无须为表示表中元素之间的逻辑关系而增加额外的存储空间。<br> 可以快速地存取表中任意位置的元素。<br> 缺点：<br> 插入和删除操作需要移动大量元素。<br> 当线性表长度变化较大时，难以确定存储空间的容量。<br> 容易造成存储空间的“碎片”。</p><p> 线性表链式存储结构定义:<br> 线性表的链式存储结构的特点是用一组任意的存储单元存储线性表的数据元素，这组存储单元可以存在内存中未被占用的任意位置。比起顺序存储结构每个数据元素只需要存储一个位置就可以了。<br> 单链表:<br> 现在链式存储结构中，除了要存储数据元素信息外，还要存储它的后继元素的存储地址（指针）。<br> 也就是说除了存储其本身的信息外，还需存储一个指示其直接后继的存储位置的信息。<br> 我们把存储数据元素信息的域称为数据域，把存储直接后继位置的域称为指针域。<br> 指针域中存储的信息称为指针或链。<br> 这两部分信息组成数据元素称为存储映像，称为结点(Node)。<br> n个结点链接成一个链表，即为线性表(a1, a2, a3, …, an)的链式存储结构。<br> 因为此链表的每个结点中只包含一个指针域，所以叫做单链表。<br> 我们把链表中的第一个结点的存储位置叫做头指针，最后一个结点指针为空(NULL)。</p><p> 头指针是指链表指向第一个结点的指针，若链表有头结点，则是指向头结点的指针。<br> 头指针具有标识作用，所以常用头指针冠以链表的名字（指针变量的名字）。<br> 无论链表是否为空，头指针均不为空。<br> 头指针是链表的必要元素。</p><p> 头结点是为了操作的统一和方便而设立的，放在第一个元素的结点之前，其数据域一般无意义（但也可以用来存放链表的长度）。<br> 有了头结点，对在第一元素结点前插入结点和删除第一结点起操作与其它结点的操作就统一了。<br> 头结点不一定是链表的必须要素。<br> 获得链表第i个数据的算法思路：<br> 声明一个结点p指向链表第一个结点，初始化j从1开始；<br> 当j&lt;i时，就遍历链表，让p的指针向后移动，不断指向一下结点，j+1；<br> 若到链表末尾p为空，则说明第i个元素不存在；<br> 否则查找成功，返回结点p的数据。<br> 其核心思想叫做“工作指针后移”，这其实也是很多算法的常用技术。<br> 单链表的插入:s-&gt;next = p-&gt;next;p-&gt;next = s;<br> 单链表第i个数据插入结点的算法思路：<br> 声明一结点p指向链表头结点，初始化j从1开始；<br> 当j&lt;1时，就遍历链表，让p的指针向后移动，不断指向下一结点，j累加1；<br> 若到链表末尾p为空，则说明第i个元素不存在；<br> 否则查找成功，在系统中生成一个空结点s；<br> 将数据元素e赋值给s-&gt;data；<br> 单链表的插入刚才两个标准语句；<br> 返回成功。<br> 单链表的删除:<br> 可以这样：p-&gt;next = p-&gt;next-&gt;next;<br> 也可以是：q=p-&gt;next; p-&gt;next=q-&gt;next;<br> 单链表第i个数据删除结点的算法思路：<br> 声明结点p指向链表第一个结点，初始化j=1；<br> 当j&lt;1时，就遍历链表，让P的指针向后移动，不断指向下一个结点，j累加1；<br> 若到链表末尾p为空，则说明第i个元素不存在；<br> 否则查找成功，将欲删除结点p-&gt;next赋值给q；<br> 单链表的删除标准语句p-&gt;next = q-&gt;next；<br> 将q结点中的数据赋值给e，作为返回；<br> 释放q结点。<br> 效率PK:<br> 我们最后的环节是效率PK，我们发现无论是单链表插入还是删除算法，它们其实都是由两个部分组成：第一部分就是遍历查找第i个元素，第二部分就是实现插入和删除元素。<br> 从整个算法来说，我们很容易可以推出它们的时间复杂度都是O(n)。<br> 再详细点分析：如果在我们不知道第i个元素的指针位置，单链表数据结构在插入和删除操作上，与线性表的顺序存储结构是没有太大优势的。<br> 但如果，我们希望从第i个位置开始，插入连续10个元素，对于顺序存储结构意味着，每一次插入都需要移动n-i个位置，所以每次都是O(n)。<br> 而单链表，我们只需要在第一次时，找到第i个位置的指针，此时为O(n)，接下来只是简单地通过赋值移动指针而已，时间复杂度都是O(1)。<br> 显然，对于插入或删除数据越频繁的操作，单链表的效率优势就越是明显啦~<br> 单链表整表创建的算法思路如下：<br> 声明一结点p和计数器变量i；<br> 初始化一空链表L；<br> 让L的头结点的指针指向NULL，即建立一个带头结点的单链表；<br> 循环实现后继结点的赋值和插入。<br> 头插法建立单链表:头插法从一个空表开始，生成新结点，读取数据存放到新结点的数据域中，然后将新结点插入到当前链表的表头上，直到结束为止。<br> 简单来说，就是把新加进的元素放在表头后的第一个位置：<br> 先让新节点的next指向头节点之后<br> 然后让表头的next指向新节点<br> 尾插法建立单链表:<br> 头插法建立链表虽然算法简单，但生成的链表中结点的次序和输入的顺序相反。<br> 就像现实社会我们鄙视插队不遵守纪律的孩子，那编程中我们也可以不这么干，我们可以把思维逆过来：把新结点都插入到最后，这种算法称之为尾插法。</p><p> 单链表整表删除的算法思路如下：<br> 声明结点p和q；<br> 将第一个结点赋值给p，下一结点赋值给q；<br> 循环执行释放p和将q赋值给p的操作；</p><p> 单链表结构与顺序存储结构优缺点:<br> 存储分配方式：<br> 顺序存储结构用一段连续的存储单元依次存储线性表的数据元素。<br> 单链表采用链式存储结构，用一组任意的存储单元存放线性表的元素。<br> 时间性能：<br> 查找<br> 顺序存储结构O(1)<br> 单链表O(n)<br> 插入和删除<br> 顺序存储结构需要平均移动表长一半的元素，时间为O(n)<br> 单链表在计算出某位置的指针后，插入和删除时间仅为O(1)<br> 空间性能：<br> 顺序存储结构需要预分配存储空间，分大了，容易造成空间浪费，分小了，容易发生溢出。<br> 单链表不需要分配存储空间，只要有就可以分配，元素个数也不受限制。<br> 结论：<br> 若线性表需要频繁查找，很少进行插入和删除操作时，宜采用顺序存储结构。<br> 若需要频繁插入和删除时，宜采用单链表结构。<br> 比如说游戏开发中，对于用户注册的个人信息，除了注册时插入数据外，绝大多数情况都是读取，所以应该考虑用顺序存储结构。<br> 而游戏中的玩家的武器或者装备列表，随着玩家的游戏过程中，可能会随时增加或删除，此时再用顺序存储就不太合适了，单链表结构就可以大展拳脚了。<br> 当线性表中的元素个数变化较大或者根本不知道有多大时，最好用单链表结构，这样可以不需要考虑存储空间的大小问题。<br> 而如果事先知道线性表的大致长度，比如一年12个月，一周就是星期一至星期日共七天，这种用顺序存储结构效率会高很多。<br> 快速找到未知长度单链表的中间节点?<br> 既然是面试题就一定有普通方法和高级方法，而高级方法无疑会让面试官大大加分！<br> 普通的方法很简单，首先遍历一遍单链表以确定单链表的长度L。然后再次从头节点出发循环L/2次找到单链表的中间节点。<br> 算法复杂度为：O(L+L/2)=O(3L/2)。<br> 能否再优化一下这个时间复杂度呢？<br> 有一个很巧妙的方法：利用快慢指针！<br> 利用快慢指针原理：设置两个指针<em>search、*mid都指向单链表的头节点。其中</em> search的移动速度是<em>mid的2倍。当</em>search指向末尾节点的时候，mid正好就在中间了。这也是标尺的思想。</p><p> 将单链表中终端结点的指针端由空指针改为指向头结点，就使整个单链表形成一个环，这种头尾相接的单链表成为单循环链表，简称循环链表。<br> 判断单链表中是否有环<br> 有环的定义是，链表的尾节点指向了链表中的某个节点。<br> 方法一：使用p、q两个指针，p总是向前走，但q每次都从头开始走，对于每个节点，看p走的步数是否和q一样。如图，当p从6走到3时，用了6步，此时若q从head出发，则只需两步就到3，因而步数不等，出现矛盾，存在环。<br> 方法二：使用p、q两个指针，p每次向前走一步，q每次向前走两步，若在某个时候p == q，则存在环。</p></li></ol><p>双向链表的插入操作<br>    插入操作其实并不复杂，不过顺序很重要，千万不能写反了。<br>    s-&gt;next = p;<br>    s-&gt;prior = p-&gt;prior;<br>    p-&gt;prior-&gt;next = s;<br>    p-&gt;prior = s;<br>    双向链表的删除操作<br>    p-&gt;prior-&gt;next = p-&gt;next;<br>    p-&gt;next-&gt;prior = p-&gt;prior;<br>    free(p);<br>    双向链表相对于单链表来说，是要更复杂一点，每个结点多了一个prior指针，对于插入和删除操作的顺序大家要格外小心。不过，双向链表可以有效提高算法的时间性能，说白了就是用空间来换取时间。<br>    栈是一种重要的线性结构，可以这样讲，栈是前面讲过的线性表的一种具体形式。<br>    清空一个栈<br>    所谓清空一个栈，就是将栈中的元素全部作废，但栈本身物理空间并不发生改变（不是销毁）。<br>    因此我们只要将s-&gt;top的内容赋值为s-&gt;base即可，这样s-&gt;base等于s-&gt;top，也就表明这个栈是空的了。<br>    这个原理跟高级格式化只是但单纯地清空文件列表而没有覆盖硬盘的原理是一样的。<br>    ClearStack(sqStack <em>s)<br>    {<br>        s-&gt;top = s-&gt;base;<br>    }<br>    销毁一个栈<br>    销毁一个栈与清空一个栈不同，销毁一个栈是要释放掉该栈所占据的物理内存空间，因此不要把销毁一个栈与清空一个栈这两种操作混淆。<br>    DestroyStack(sqStack <em>s)<br>    {<br>        int i, len;<br>        len = s-&gt;stackSize;<br>        for( i=0; i &lt; len; i++ )<br>        {<br>            free( s-&gt;base );<br>            s-&gt;base++;<br>        }<br>        s-&gt;base = s-&gt;top = NULL;<br>        s-&gt;stackSize = 0;<br>    }<br>    计算栈的当前容量<br>    计算栈的当前容量也就是计算栈中元素的个数，因此只要返回s.top-s.base即可。<br>    注意，栈的最大容量是指该栈占据内存空间的大小，其值是s.stackSize，它与栈的当前容量不是一个概念哦。<br>    int StackLen(sqStack s)<br>    {<br>        return(s.top – s.base);  // 初学者需要重点讲解<br>    }<br>    逆波兰计算<br>    逆波兰表达式<br>    a+b —&gt; a b +<br>    a+(b-c) —&gt; a b c – +<br>    a+(b-c)</em>d —&gt; a b c – d * +<br>    a+d</em>(b-c)—&gt; a d b c – * +<br>    队列的链式存储结构<br>    我们将队头指针指向链队列的头结点，而队尾指针指向终端结点。（注：头结点不是必要的，但为了方便操作，我们加上了。）<br>    空队列时，front和rear都指向头结点。<br>    创建一个队列<br>    创建一个队列要完成两个任务：一是在内存中创建一个头结点，二是将队列的头指针和尾指针都指向这个生成的头结点，因为此时是空队列。<br>    入队列操作<br>    InsertQueue(LinkQueue *q, ElemType e)<br>    {<br>        QueuePtr p;</p><div class="hljs"><pre><code>    p = (QueuePtr)malloc(sizeof(QNode));    if( p == NULL )        exit(0);    p-&gt;data = e;    p-&gt;next = NULL;    q-&gt;rear-&gt;next = p;    q-&gt;rear = p;}出队列操作出队列操作是将队列中的第一个元素移出，队头指针不发生改变，改变头结点的next指针即可。DeleteQueue(LinkQueue *q, ELemType *e){    QueuePtr p;    if( q-&gt;front == q-&gt;rear )        return;    p = q-&gt;front-&gt;next;    *e = p-&gt;data;    q-&gt;front-&gt;next = p-&gt;next;    if( q-&gt;rear == p )        q-&gt;rear = q-&gt;front;    free(p);}销毁一个队列由于链队列建立在内存的动态区，因此当一个队列不再有用时应当把它及时销毁掉，以免过多地占用内存空间。DestroyQueue(LinkQueue *q){    while( q-&gt;front )    {        q-&gt;rear = q-&gt;front-&gt;next;        free( q-&gt;front );        q-&gt;front = q-&gt;rear;    }}树结构树(Tree)是n(n&gt;=0)个结点的有限集。当n=0时成为空树，在任意一棵非空树中：有且仅有一个特定的称为根(Root)的结点；当n&gt;1时，其余结点可分为m(m&gt;0)个互不相交的有限集T1、T2、…、Tm，其中每一个集合本身又是一棵树，并且称为根的子树(SubTree)。虽然从概念上很容易理解树，但是有两点还是需要大家注意下：n&gt;0时，根结点是唯一的，坚决不可能存在多个根结点。m&gt;0时，子树的个数是没有限制的，但它们互相是一定不会相交的。结点分类刚才所有图片中，每一个圈圈我们就称为树的一个结点。结点拥有的子树数称为结点的度-(Degree)，树的度取树内各结点的度的最大值。度为0的结点称为叶结点(Leaf)或终端结点；度不为0的结点称为分支结点或非终端结点，除根结点外，分支结点也称为内部结点。树中结点的最大层次称为树的深度(Depth)或高度。</code></pre></div><p>二叉树的特点<br>    每个结点最多有两棵子树，所以二叉树中不存在度大于2的结点。（注意：不是都需要两棵子树，而是最多可以是两棵，没有子树或者有一棵子树也都是可以的。）<br>    左子树和右子树是有顺序的，次序不能颠倒。<br>    即使树中某结点只有一棵子树，也要区分它是左子树还是右子树，<br>    二叉树的性质一：在二叉树的第i层上至多有2^(i-1)个结点(i&gt;=1)<br>    二叉树的性质二：深度为k的二叉树至多有2^k-1个结点(k&gt;=1)<br>    二叉树的性质三：对任何一棵二叉树T，如果其终端结点数为n0，度为2的结点数为n2，则n0=n2+1<br>        首先我们再假设度为1的结点数为n1，则二叉树T的结点总数n=n0+n1+n2<br>        其次我们发现连接数总是等于总结点数n-1，并且等于n1+2<em>n2<br>        所以n-1=n1+2</em>n2<br>        所以n0+n1+n2-1=n1+n2+n2<br>        最后n0=n2+1<br>    二叉树的性质四：具有n个结点的完全二叉树的深度为⌊log₂n⌋+1<br>    二叉树的性质五：如果对一棵有n个结点的完全二叉树(其深度为⌊log₂n⌋+1)的结点按层序编号，对任一结点i(1&lt;=i&lt;=n)有以下性质：<br>        如果i = 1，则结点 i 是二叉树的根，无双亲；如果i &gt; 1，则其双亲是结点⌊i/2⌋<br>        如果2i &gt; n，则结点 i 无做左孩子(结点 i 为叶子结点)；否则其左孩子是结点2i<br>        如果2i+1 &gt; n，则结点 i 无右孩子；否则其右孩子是结点2i+1</p><div class="hljs"><pre><code>    既然顺序存储方式的适用性不强，那么我们就要考虑链式存储结构啦。二叉树的存储按照国际惯例来说一般也是采用链式存储结构的。二叉树每个结点最多有两个孩子，所以为它设计一个数据域和两个指针域是比较自然的想法，我们称这样的链表叫做二叉链表。    typedef struct BiTNode{    ElemType data;    struct BiTNode *lchild, *rchild;} BiTNode, *BiTree;二叉树的遍历方式可以很多，如果我们限制了从左到右的习惯方式，那么主要就分为一下四种：前序遍历    若二叉树为空，则空操作返回，否则先访问根结点，然后前序遍历左子树，再前序遍历右子树。中序遍历    若树为空，则空操作返回，否则从根结点开始（注意并不是先访问根结点），中序遍历根结点的左子树，然后是访问根结点，最后中序遍历右子树。后序遍历    若树为空，则空操作返回，否则从左到右先叶子后结点的方式遍历访问左右子树，最后访问根结点。层序遍历    若树为空，则空操作返回，否则从树的第一层，也就是根结点开始访问，从上而下逐层遍历，在同一层中，按从左到右的顺序对结点逐个访问。赫夫曼树定义与原理    我们先把这两棵二叉树简化成叶子结点带权的二叉树（注：树结点间的连线相关的数叫做权，Weight）。    结点的路径长度：从根结点到该结点的路径上的连接数。    树的路径长度：树中每个叶子结点的路径长度之和。    结点带权路径长度：结点的路径长度与结点权值的乘积。    WPL的值越小，说明构造出来的二叉树性能越优。名词解释：定长编码，变长编码，前缀码定长编码：像ASCII编码变长编码：单个编码的长度不一致，可以根据整体出现频率来调节前缀码：所谓的前缀码，就是没有任何码字是其他码字的前缀图的定义    图（Graph）是由顶点的有穷非空集合和顶点之间边的集合组成，通常表示为：G(V,E)，其中，G表示一个图，V是图G中顶点的集合，E是图G中边的集合。对于图的定义，我们需要明确几个注意的地方：    线性表中我们把数据元素叫元素，树中叫结点，在图中数据元素我们则称之为顶点(Vertex)。    线性表可以没有数据元素，称为空表，树中可以没有结点，叫做空树，而图结构在咱国内大部分的教材中强调顶点集合V要有穷非空。    线性表中，相邻的数据元素之间具有线性关系，树结构中，相邻两层的结点具有层次关系，而图结构中，任意两个顶点之间都可能有关系，顶点之间的逻辑关系用边来表示，边集可以是空的。无向边：若顶点Vi到Vj之间的边没有方向，则称这条边为无向边(Edge)，用无序偶(Vi,Vj)来表示。有向边：若从顶点Vi到Vj的边有方向，则称这条边为有向边，也成为弧(Arc)，用有序偶&lt;Vi,Vj&gt;来表示，Vi称为弧尾，Vj称为弧头。简单图：在图结构中，若不存在顶点到其自身的边，且同一条边不重复出现，则称这样的图为简单图。无向完全图：在无向图中，如果任意两个顶点之间都存在边，则称该图为无向完全图。含有n个顶点的无向完全图有n*(n-1)/2条边。有向完全图：在有向图中，如果任意两个顶点之间都存在方向互为相反的两条弧，则称该图为有向完全图。含有n个顶点的有向完全图有n*(n-1)条边。稀疏图和稠密图：这里的稀疏和稠密是模糊的概念，都是相对而言的，通常认为边或弧数小于n*logn（n是顶点的个数）的图称为稀疏图，反之称为稠密图。有些图的边或弧带有与它相关的数字，这种与图的边或弧相关的数叫做权(Weight)，带权的图通常称为网(Network)。假设有两个图G1=(V1,E1)和G2=(V2,E2)，如果V2⊆V1，E2⊆E1，则称G2为G1的子图(Subgraph)。边(V1,V2)依附(incident)于顶点V1和V2，或者说边(V1,V2)与顶点V1和V2相关联。顶点V的度(Degree)是和V相关联的边的数目，记为TD(V)，如下图，顶点A与B互为邻接点，边(A,B)依附于顶点A与B上，顶点A的度为3。对于有向图G=(V,E)，如果有&lt;V1,V2&gt;∈E，则称顶点V1邻接到顶点V2，顶点V2邻接自顶点V1。以顶点V为头的弧的数目称为V的入度(InDegree)，记为ID(V)，以V为尾的弧的数目称为V的出度(OutDegree)，记为OD(V)，因此顶点V的度为TD(V)=ID(V)+OD(V)。如果G是有向图，则路径也是有向的。下图用红线列举顶点B到顶点D的两种路径，而顶点A到顶点B就不存在路径啦：路径的长度是路径上的边或弧的数目。第一个顶点到最后一个顶点相同的路径称为回路或环(Cycle)。序列中顶点不重复出现的路径称为简单路径，除了第一个顶点和最后一个顶点之外，其余顶点不重复出现的回路，称为简单回路或简单环。连通图:在无向图G中，如果从顶点V1到顶点V2有路径，则称V1和V2是连通的，如果对于图中任意两个顶点Vi和Vj都是连通的，则称G是连通图(ConnectedGraph)无向图中的极大连通子图称为连通分量。如果一个有向图恰有一个顶点入度为0，其余顶点的入度均为1，则是一棵有向树。邻接矩阵（无向图）:    图的邻接矩阵(Adjacency Matrix)存储方式是用两个数组来表示图。一个一维数组存储图中顶点信息，一个二维数组(称为邻接矩阵)存储图中的边或弧的信息。对称矩阵：所谓对称矩阵就是n阶矩阵的元满足a[i][j]=a[j][i](0&lt;=i,j&lt;=n)。即从矩阵的左上角到右下角的主对角线为轴，右上角的元与左下角相对应的元全都是相等的。邻接矩阵（有向图）可见顶点数组vertex[4]={V0,V1,V2,V3}，弧数组arc[4][4]也是一个矩阵，但因为是有向图，所以这个矩阵并不对称，例如由V1到V0有弧，得到arc[1][0]=1，而V0到V1没有弧，因此arc[0][1]=0。另外有向图是有讲究的，要考虑入度和出度，顶点V1的入度为1，正好是第V1列的各数之和，顶点V1的出度为2，正好是第V1行的各数之和。邻接矩阵（网）在图的术语中，我们提到了网这个概念，事实上也就是每条边上带有权的图就叫网。邻接表（无向图）邻接矩阵看上去是个不错的选择，首先是容易理解，第二是索引和编排都很舒服~但是我们也发现，对于边数相对顶点较少的图，这种结构无疑是存在对存储空间的极大浪费。因此我们可以考虑另外一种存储结构方式，例如把数组与链表结合一起来存储，这种方式在图结构也适用，我们称为邻接表(AdjacencyList)。图中顶点用一个一维数组存储，当然，顶点也可以用单链表来存储，不过数组可以较容易地读取顶点信息，更加方便。图中每个顶点Vi的所有邻接点构成一个线性表，由于邻接点的个数不确定，所以我们选择用单链表来存储。邻接表（有向图）若是有向图，邻接表结构也是类似的，我们先来看下把顶点当弧尾建立的邻接表，这样很容易就可以得到每个顶点的出度：但也有时为了便于确定顶点的入度或以顶点为弧头的弧，我们可以建立一个有向图的逆邻接表：邻接表（网）对于带权值的网图，可以在边表结点定义中再增加一个数据域来存储权值即可：十字链表    十字链表的好处就是因为把邻接表和逆邻接表整合在了一起，这样既容易找到以Vi为尾的弧，也容易找到以Vi为头的弧，因而容易求得顶点的出度和入度。    十字链表除了结构复杂一点外，其实创建图算法的时间复杂度是和邻接表相同的，因此，在有向图的应用中，十字链表也是非常好的数据结构模型。邻接多重表    其中iVex和jVex是与某条边依附的两个顶点在顶点表中的下标。iLink指向依附顶点iVex的下一条边，jLink指向依附顶点jVex的下一条边。    也就是说在邻接多重表里边，边表存放的是一条边，而不是一个顶点。边集数组    边集数组是由两个一维数组构成，一个是存储顶点的信息，另一个是存储边的信息，这个边数组每个数据元素由一条边的起点下标(begin)、终点下标(end)和权(weight)组成。图的遍历树的遍历我们谈了四种方式，大家回忆一下，树因为根结点只有一个，并且所有的结点都只有一个双亲，所以不是很难理解。    但是谈到图的遍历，那就复杂多了，因为它的任一顶点都可以和其余的所有顶点相邻接，因此极有可能存在重复走过某个顶点或漏了某个顶点的遍历过程。    对于图的遍历，如果要避免以上情况，那就需要科学地设计遍历方案，通常有两种遍历次序方案：它们是深度优先遍历和广度优先遍历。    深度优先遍历        我们可以约定右手原则：在没有碰到重复顶点的情况下，分叉路口始终是向右手边走，每路过一个顶点就做一个记号。回溯法：    之前我们谈过回溯法，还是那句话，指导思想很简单，就是一条路走到黑，碰壁了再回来一条路走到黑……一般和递归可以很好的搭配使用，还有深度优先搜索（DFS）。哈密尔顿路径：    图G中的哈密尔顿路径指的是经过图G中每个顶点，且只经过一次的一条轨迹。如果这条轨迹是一条闭合的路径（从起点出发不重复地遍历所有点后仍能回到起始点），那么这条路径称为哈密尔顿回路。</code></pre></div><p>图的遍历（广度优先遍历）<br>    广度优先遍历（BreadthFirstSearch），又称为广度优先搜索，简称BFS。<br>    一个无环的有向图称为无环图（Directed Acyclic Graph），简称DAG图。<br>    在一个表示工程的有向图中，用顶点表示活动，用弧表示活动之间的优先关系，这样的有向图为顶点表示活动的网，我们称之为AOV网（Active On Vertex Network）。<br>    拓扑序列含义：<br>    设G=(V,E)是一个具有n个顶点的有向图，V中的顶点序列V1,V2,……,Vn满足若从顶点Vi到Vj有一条路径，则在顶点序列中顶点Vi必在顶点Vj之前。则我们称这样的顶点序列为一个拓扑序列。<br>    对AOV网进行拓扑排序的方法和步骤如下：<br>    从AOV网中选择一个没有前趋的顶点（该顶点的入度为0）并且输出它；<br>    从网中删去该顶点，并且删去从该顶点发出的全部有向边；<br>    重复上述两步，直到剩余网中不再存在没有前趋的顶点为止。<br>        算法时间复杂度：<br>    对一个具有n个顶点，e条边的网来说，初始建立入度为零的顶点栈，要检查所有顶点一次，执行时间为O(n)。<br>    排序中，若AOV网无回路，则每个顶点入、出栈各一次，每个表结点被检查一次，因而执行时间是 O(n+e)。<br>    所以，整个算法的时间复杂度是 O(n+e)。<br>我们把AOE网中没有入边的顶点称为始点或源点，没有出边的顶点称为终点或汇点。<br>etv(Earliest Time Of Vertex)：事件最早发生时间，就是顶点的最早发生时间；<br>ltv(Latest Time Of Vertex)：事件最晚发生时间，就是每个顶点对应的事件最晚需要开始的时间，如果超出此时间将会延误整个工期。<br>ete(Earliest Time Of Edge)：活动的最早开工时间，就是弧的最早发生时间。<br>lte(Latest Time Of Edge)：活动的最晚发生时间，就是不推迟工期的最晚开工时间。<br>顺序查找<br>    顺序查找又叫线性查找，是最基本的查找技术，它的查找过程是：从第一个（或者最后一个）记录开始，逐个进行记录的关键字和给定值进行比较，若某个记录的关键字和给定值相等，则查找成功。如果查找了所有的记录仍然找不到与给定值相等的关键字，则查找不成功。<br>二叉排序数（Binary Sort Tree）又称为二叉查找树，它或者是一棵空树，或者是具有下列性质的二叉树：<br>    若它的左子树不为空，则左子树上所有结点的值均小于它的根结构的值；<br>    若它的右子树不为空，则右子树上所有结点的值均大于它的根结构的值；<br>    它的左、右子树也分别为二叉排序树（递归）。<br>散列表的查找步骤<br>当存储记录时，通过散列函数计算出记录的散列地址<br>当查找记录时，我们通过同样的是散列函数计算记录的散列地址，并按此散列地址访问该记录<br>排序的稳定性<br>    假设ki=kj(1&lt;=i&lt;=n,1&lt;=j&lt;=n,i!=j)，且在排序前的序列中ri领先于rj(即i&lt;j)。 如果排序后ri仍领先于rj，则称所用的排序方法是稳定的； 反之，若可能使得排序后的序列中rj领先ri，则称所用的排序方法是不稳定的。<br>冒泡排序的要点：<br>    1. 两两注意是相邻的两个元素的意思<br>    2. 如果有n个元素需要比较n-1次，每一轮减少1次比较<br>    3. 既然叫冒泡排序，那就是从下往上两两比较，所以看上去就跟泡泡往上冒一样。<br>优化冒泡排序算法<br>    我们发现如果使用正宗的冒泡排序算法，当i等于1执行完的时候，我们发现程序只进行两两相邻元素的比较，而不用进行任何移动，所以完全可以不用再继续循环。<br>希尔排序的原理<br>    希尔排序，也称递减增量排序算法，是插入排序的一种更高效的改进版本，希尔排序是非稳定排序算法。<br>    希尔排序是基于插入排序的以下两点性质而提出改进方法的：<br>    插入排序在对几乎已经排好序的数据操作时， 效率高， 即可以达到线性排序的效率<br>    但插入排序一般来说是低效的， 因为插入排序每次只能将数据移动一位<br>堆排序<br>    上节课我们介绍的希尔排序是对直接插入排序的改进，而我们这节课谈的堆排序是对选择排序进行改进的排序算法，堆排序算法的时间复杂度和希尔排序是一样的，都是O（nlogn）.<br>堆是具有下列性质的完全二叉树：每个结点的值都大于或者等于其左右孩子结点的值，称为大顶堆；或者每个结点的值都小于或者等于其左右孩子结点的值，称为小顶堆。<br>堆排序算法:<br>    堆排序（Heap Sort）就是利用堆进行排序的算法，它的基本思想是：<br>    将待排序的序列构造成一个大顶堆（或小顶堆）。<br>    此时，整个序列的最大值就是堆顶的根结点。将它移走（就是将其与堆数组的末尾元素交换，此时末尾元素就是最大值）。<br>    然后将剩余的n-1个序列重新构造成一个堆，这样就会得到n个元素中的此大值。<br>    如此反复执行，便能得到一个有序序列了。<br>归并排序（递归实现）<br>    归并”一词在中文含义中就是合并的意思，而在数据结构中的定义是将两个或者两个以上的有序表组合成一个新的有序表，就叫归并。<br>    归并排序（Merge Sort）就是利用归并的思想实现的排序方法。它的原理是假设初始序列有n个记录，则    可以看成是n个有序的子序列，每个子序列的长度为1，然后两两归并，得到⌈n/2⌉个长度为2或1的有序子序列；再两两归并，……，如此重复，直至得到一个长度为n的有序序列为止，这种排序方法称为2路归并排序。<br>快速排序<br>    排序算法（Quict Sort）的基本思想是：<br>        通过一趟排序将待排序记录分割成独立地两部分，其中一部分记录的关键字均比另一部分记录的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序的目的。</p><hr><p>1.activity的生命周期。<br>2.横竖屏切换时候activity的生命周期<br>  1.不设置Activity的android:configChanges时,切屏会重新调用各个生命周期,切横屏时会执行一次,切竖屏时会执行两次.<br>  2.设置Activity的android:configChanges=”orientation”时,切屏还是会重新调用各个生命周期,切横、竖屏时只会执行一次.<br>  3.设置Activity的android:configChanges=”orientation|keyboardHidden”时,切屏不会重新调用各个生命周期,只会执行onConfigurationChanged方法.<br>3.android中的动画有哪几类，它们的特点和区别是什么?<br>  两种，一种是Tween动画、还有一种是Frame动画。Tween动画，这种实现方式可以使视图组件移动、放大、缩小以及产生透明度的变化;另一种Frame动画，传统的动画方法，通过顺序的播放排列好的图片来实现，类似电影。<br>4.一条最长的短信息约占多少byte?<br>  中文70(包括标点)，英文160个字节。<br>5.handler机制的原理<br>    andriod提供了 Handler 和 Looper 来满足线程间的通信。Handler 先进先出原则。Looper类用来管理特定线程内对象之间的消息交换(Message Exchange)。<br>　　1)Looper: 一个线程可以产生一个Looper对象，由它来管理此线程里的Message Queue(消息队列)。<br>    2)Handler: 你可以构造Handler对象来与Looper沟通，以便push新消息到Message Queue里;或者接收Looper从Message Queue取出)所送来的消息。<br>　　3) Message Queue(消息队列):用来存放线程放入的消息。<br>　　4)线程：UI thread 通常就是main thread，而Android启动程序时会替它建立一个Message Queue。<br>6.什么是嵌入式实时操作系统, Android 操作系统属于实时操作系统吗?　<br>  嵌入式实时操作系统是指当外界事件或数据产生时，能够接受并以足够快的速度予以处理，其处理的结果又能在规定的时间之内来控制生产过程或对处理系统作出快速响应，并控制所有实时任务协调一致运行的嵌入式操作系统。主要用于工业控制、 军事设备、 航空航天等领域对系统的响应时间有苛刻的要求，这就需要使用实时系统。又可分为软实时和硬实时两种，而android是基于linux内核的，因此属于软实时。<br>7.android中线程与线程，进程与进程之间如何通信<br>  1、一个 Android 程序开始运行时，会单独启动一个Process。<br>   默认情况下，所有这个程序中的Activity或者Service都会跑在这个Process。<br>   默认情况下，一个Android程序也只有一个Process，但一个Process下却可以有许多个Thread。<br>  2、一个 Android 程序开始运行时，就有一个主线程Main Thread被创建。该线程主要负责UI界面的显示、更新和控件交互，所以又叫UI Thread。<br>   一个Android程序创建之初，一个Process呈现的是单线程模型–即Main Thread，所有的任务都在一个线程中运行。所以，Main Thread所调用的每一个函数，其耗时应该越短越好。而对于比较费时的工作，应该设法交给子线程去做，以避免阻塞主线程（主线程被阻塞，会导致程序假死 现象）。<br>  3、Android单线程模型：Android UI操作并不是线程安全的并且这些操作必须在UI线程中执行。如果在子线程中直接修改UI，会导致异常。<br>8.Android dvm的进程和Linux的进程, 应用程序的进程是否为同一个概念<br>  DVM指dalivk的虚拟机。每一个Android应用程序都在它自己的进程中运行，都拥有一个独立的Dalvik虚拟机实例。而每一个DVM都是在Linux 中的一个进程，所以说可以认为是同一个概念。<br>9.sim卡的EF 文件有何作用<br>  sim卡的文件系统有自己规范，主要是为了和手机通讯，sim本 身可以有自己的操作系统，EF就是作存储并和手机通讯用的<br>10.android中的动画有哪几类，它们的特点和区别是什么?<br>  两种，一种是Tween动画、还有一种是Frame动画。Tween动画，这种实现方式可以使视图组件移动、放大、缩小以及产生透明度的变化;另一种Frame动画，传统的动画方法，通过顺序的播放排列好的图片来实现，类似电影。<br>11.让Activity变成一个窗口：Activity属性设定<br>  讲点轻松的吧,可能有人希望做出来的应用程序是一个漂浮在手机主界面的东西，那么很 简单你只需要设置 一下Activity的主题就可以了在AndroidManifest.xml 中定义 Activity的 地方一句话：<br>  Xml代码<br>  1.android :theme=”@android:style/Theme.Dialog”<br>  　这就使你的应用程序变成对话框的形式弹出来了，或者<br>  Xml代码<br>  1.android:theme=”@android:style/Theme.Translucent”<br>  就变成半透明的，[友情提示-.-]类似的这种activity的属性可以在android.R.styleable 类的AndroidManifestActivity 方法中看到，AndroidManifest.xml中所有元素的属性的介绍都可以参考这个类android.R.styleable<br>  上面说的是属性名称，具体有什么值是在android.R.style中 可以看到，比如这个”@android:style/Theme.Dialog” 就对应于android.R.style.Theme_Dialog ,(‘_’换成’.’ &lt; –注意：这个是文章内容不是笑脸)就可以用在描述文件 中了,找找类定义和描述文件中的对应关系就都明白了。<br>12.如何将SQLite数据库(dictionary.db文件)与apk文件一起发布?<br>  解答：可以将dictionary.db文件复制到Eclipse Android工程中的res aw目录中。所有在res aw目录中的文件不会被压缩，这样可以直接提取该目录中的文件。可以将dictionary.db文件复制到res aw目录中<br>13.如何将打开res aw目录中的数据库文件?<br>  解答：在Android中不能直接打开res aw目录中的数据库文件，而需要在程序第一次启动时将该文件复制到手机内存或SD卡的某个目录中，然后再打开该数据库文件。复制的基本方法是使用getResources().openRawResource方法获得res aw目录中资源的 InputStream对象，然后将该InputStream对象中的数据写入其他的目录中相应文件中。在Android SDK中可以使用SQLiteDatabase.openOrCreateDatabase方法来打开任意目录中的SQLite数据库文件。<br>14.在android中mvc的具体体现<br>  Android 的官方建议应用程序的开发采用MVC 模式。何谓MVC？先看看下图<br>  MVC 是Model,View,Controller 的缩写，从上图可以看出MVC 包含三个部分：<br>  .. 模型（Model）对象：是应用程序的主体部分，所有的业务逻辑都应该写在该<br>  层。<br>  .. 视图（View）对象：是应用程序中负责生成用户界面的部分。也是在整个<br>  MVC 架构中用户唯一可以看到的一层，接收用户的输入，显示处理结果。<br>  .. 控制器（Control）对象：是根据用户的输入，控制用户界面数据显示及更新<br>  Model 对象状态的部分，控制器更重要的一种导航功能，想用用户出发的相<br>  关事件，交给M 哦得了处理。<br>  Android 鼓励弱耦合和组件的重用，在Android 中MVC 的具体体现如下<br>  1)视图层（view）：一般采用xml文件进行界面的描述，使用的时候可以非常方便的引入，当然，如何你对android了解的比较的多了话，就一定可 以想到在android中也可以使用javascript+html等的方式作为view层，当然这里需要进行java和javascript之间的通 信，幸运的是，android提供了它们之间非常方便的通信实现。<br>  2)控制层（controller）：android的控制层的重 任通常落在了众多的acitvity的肩上，这句话也就暗含了不要在acitivity中写代码，要通过activity交割model业务逻辑层处理， 这样做的另外一个原因是android中的acitivity的响应时间是5s，如果耗时的操作放在这里，程序就很容易被回收掉。<br>  3)模型层（model）：对数据库的操作、对网络等的操作都应该在model里面处理，当然对业务计算等操作也是必须放在的该层的。<br>15.Android系统的架构<br>  android的系统架构和其操作系统一样，采用了分层的架构。从架构图看，android分为四个层，从高层到低层分别是应用程序层、应用程序框架层、系统运行库层和linux核心层。<br>  1.应用程序　Android会同一系列核心应用程序包一起发布，该应用程序包包括email客户端，SMS短消息程序，日历，地图，浏览器，联系人管理程序等。所有的应用程序都是使用JAVA语言编写的。<br>  2.应用程序框架　开发人员也可以完全访问核心应用程序所使用的API框架。该应用程序的架构设计简化了组件的重用;任何一个应用程序都可以发布它的功能块并且任何其它的应用程序都可以使用其所发布的功能块(不过得遵循框架的安全性限制)。同样，该应用程序重用机制也使用户可以方便的替换程序组件。<br>  隐藏在每个应用后面的是一系列的服务和系统, 其中包括;</p><ul><li>丰富而又可扩展的视图(Views)，可以用来构建应用程序， 它包括列表(lists)，网格(grids)，文本框(text boxes)，按钮(buttons)， 甚至可嵌入的web浏览器。</li><li>内容提供器(Content Providers)使得应用程序可以访问另一个应用程序的数据(如联系人数据库)， 或者共享它们自己的数据</li><li>资源管理器(Resource Manager)提供 非代码资源的访问，如本地字符串，图形，和布局文件( layout files )。</li><li>通知管理器 (Notification Manager) 使得应用程序可以在状态栏中显示自定义的提示信息。</li><li>活动管理器( Activity Manager) 用来管理应用程序生命周期并提供常用的导航回退功能。<br>有关更多的细节和怎样从头写一个应用程序，请参考 如何编写一个 Android 应用程序.</li></ul><p>  3.系统运行库<br>  1)程序库<br>  Android 包含一些C/C++库，这些库能被Android系统中不同的组件使用。它们通过 Android 应用程序框架为开发者提供服务。以下是一些核心库：</p><ul><li>系统 C 库 - 一个从 BSD 继承来的标准 C 系统函数库( libc )， 它是专门为基于 embedded linux 的设备定制的。</li><li>媒体库 - 基于 PacketVideo OpenCORE;该库支持多种常用的音频、视频格式回放和录制，同时支持静态图像文件。编码格式包括MPEG4, H.264, MP3, AAC, AMR, JPG, PNG 。</li><li>Surface Manager - 对显示子系统的管理，并且为多个应用程序提 供了2D和3D图层的无缝融合。</li><li>LibWebCore - 一个最新的web浏览器引擎用，支持Android浏览器和一个可嵌入的web视图。</li><li>SGL - 底层的2D图形引擎</li><li>3D libraries - 基于OpenGL ES 1.0 APIs实现;该库可以使用硬件 3D加速(如果可用)或者使用高度优化的3D软加速。</li><li>FreeType -位图(bitmap)和矢量(vector)字体显示。</li><li>SQLite - 一个对于所有应用程序可用，功能强劲的轻型关系型数据库引擎。<br>2)Android 运行库<br>　Android 包括了一个核心库，该核心库提供了JAVA编程语言核心库的大多数功能。<br>　每一个Android应用程序都在它自己的进程中运行，都拥有一个独立的Dalvik虚拟机实例。Dalvik被设计成一个设备可以同时高效地运行多个虚拟系统。 Dalvik虚拟机执行(.dex)的Dalvik可执行文件，该格式文件针对小内存使用做了优化。同时虚拟机是基于寄存器的，所有的类都经由JAVA编译器编译，然后通过SDK中 的 “dx” 工具转化成.dex格式由虚拟机执行。<br>　Dalvik虚拟机依赖于linux内核的一些功能，比如线程机制和底层内存管理机制。</li></ul><p>  4.Linux 内核<br>  Android 的核心系统服务依赖于 Linux 2.6 内核，如安全性，内存管理，进程管理， 网络协议栈和驱动模型。 Linux 内核也同时作为硬件和软件栈之间的抽象层。<br>16.Android常用控件的信息<br>  单选框(RadioButton与RadioGroup)：<br>  RadioGroup用于对单选框进行分组，相同组内的单选框只有一个单选框被选中。<br>  事件：setOnCheckedChangeListener()，处理单选框被选择事件。把RadioGroup.OnCheckedChangeListener实例作为参数传入。<br>  多选框(CheckBox):<br>  每个多选框都是独立的，可以通过迭代所有的多选框，然后根据其状态是否被选中在获取其值。<br>  事件：setOnCheckChangeListener()处理多选框被选择事件。把CompoundButton.OnCheckedChangeListener实例作为参数传入<br>  下拉列表框(Spring)：<br>  Spinner.getItemAtPosition(Spinner.getSelectedItemPosition());获取下拉列表框的值。<br>  事件：setOnItemSelectedListener(),处理下拉列表框被选择事件把AdapterView.OnItemSelectedListener实例作为参数传入；<br>  拖动条(SeekBar)：<br>  SeekBar.getProgress()获取拖动条当前值<br>  事件:setOnSeekBarChangeListener()，处理拖动条值变化事件，把SeekBar.OnSeekBarChangeListener实例作为参数传入。<br>  菜单(Menu):<br>  重写Activity的onCreatOptionMenu(Menu menu)方法，该方法用于创建选项菜单，咋用户按下手机的”Menu”按钮时就会显示创建好的菜单，在onCreatOptionMenu(Menu Menu)方法内部可以调用Menu.add()方法实现菜单的添加。<br>  重写Activity的onMenuItemSelected()方法，该方法用于处理菜单被选择事件。<br>  进度对话框(ProgressDialog)：<br>  创建并显示一个进度对话框：ProgressDialog.show(ProgressDialogActivity.this,”请稍等”，”数据正在加载中….”，true)；<br>  设置对话框的风格：setProgressStyle()<br>  ProgressDialog.STYLE_SPINNER  旋转进度条风格(为默认风格)<br>  ProgressDialog.STYLE_HORIZONTAL 横向进度条风格<br>17.请介绍下Android中常用的五种布局<br>  Android布局是应用界面开发的重要一环，在Android中，共有五种布局方式，分别是：FrameLayout（框架布局），LinearLayout （线性布局），<br>  AbsoluteLayout（绝对布局），RelativeLayout（相对布局），TableLayout（表格布局）。<br>  1.FrameLayout<br>      这个布局可以看成是墙脚堆东西，有一个四方的矩形的左上角墙脚，我们放了第一个东西，要再放一个，那就在放在原来放的位置的上面，这样依次的放，会盖住原来的东西。这个布局比较简单，也只能放一点比较简单的东西。<br>  2.LinearLayout<br>  线性布局，这个东西，从外框上可以理解为一个div，他首先是一个一个从上往下罗列在屏幕上。每一个LinearLayout里面又可分为垂直布局 （android:orientation=”vertical”）和水平布局（android:orientation=”horizontal” ）。当垂直布局时，每一行就只有一个元素，多个元素依次垂直往下；水平布局时，只有一行，每一个元素依次向右排列。<br>  linearLayout中有一个重要的属性 android:layout_weight=”1”，这个weight在垂直布局时，代表行距；水平的时候代表列宽；weight值越大就越大。<br>  3.AbsoluteLayout<br>      绝对布局犹如div指定了absolute属性，用X,Y坐标来指定元素的位置android:layout_x=”20px” android:layout_y=”12px” 这种布局方式也比较简单，但是在垂直随便切换时，往往会出问题，而且多个元素的时候，计算比较麻烦。<br>  4.RelativeLayout<br>      相对布局可以理解为某一个元素为参照物，来定位的布局方式。主要属性有：<br>      相对于某一个元素<br>      android:layout_below=”@id/aaa” 该元素在 id为aaa的下面<br>      android:layout_toLeftOf=”@id/bbb” 改元素的左边是bbb<br>       相对于父元素的地方<br>       android:layout_alignParentLeft=”true”  在父元素左对齐<br>       android:layout_alignParentRight=”true” 在父元素右对齐<br>       还可以指定边距等，具体详见API<br>  5.TableLayout<br>       表格布局类似Html里面的Table。每一个TableLayout里面有表格行TableRow，TableRow里面可以具体定义每一个元素，设定他的对齐方式 android:gravity=”” 。<br>       每一个布局都有自己适合的方式，另外，这五个布局元素可以相互嵌套应用，做出美观的界面。<br>18.如何启用Service，如何停用Service<br>  Android中的服务和windows中的服务是类似的东西，服务一般没有用户操作界面，它运行于系统中不容易被用户发觉，可以使用它开发如监控之类的程序。服务的开发比较简单，如下：<br>  第一步：继承Service类<br>  public class SMSService extends Service {<br>  }<br>  第二步：在AndroidManifest.xml文件中的<application>节点里对服务进行配置:<br>  <service android:name=".SMSService" /><br>  服务不能自己运行，需要通过调用Context.startService()或Context.bindService()方法启动服务。这两个方法都可以启动Service，但是它们的使用场合有所不同。使用startService()方法启用服务，调用者与服务之间没有关连，即使调用者退出了，服务仍然运行。使用bindService()方法启用服务，调用者与服务绑定在了一起，调用者一旦退出，服务也就终止，大有“不求同时生，必须同时死”的特点。<br>  如果打算采用Context.startService()方法启动服务，在服务未被创建时，系统会先调用服务的onCreate()方法，接着调用onStart()方法。如果调用startService()方法前服务已经被创建，多次调用startService()方法并不会导致多次创建服务，但会导致多次调用onStart()方法。采用startService()方法启动的服务，只能调用Context.stopService()方法结束服务，服务结束时会调用onDestroy()方法。<br>  如果打算采用Context.bindService()方法启动服务，在服务未被创建时，系统会先调用服务的onCreate()方法，接着调用onBind()方法。这个时候调用者和服务绑定在一起，调用者退出了，系统就会先调用服务的onUnbind()方法，接着调用onDestroy()方法。如果调用bindService()方法前服务已经被绑定，多次调用bindService()方法并不会导致多次创建服务及绑定(也就是说onCreate()和onBind()方法并不会被多次调用)。如果调用者希望与正在绑定的服务解除绑定，可以调用unbindService()方法，调用该方法也会导致系统调用服务的onUnbind()–&gt;onDestroy()方法。<br>  服务常用生命周期回调方法如下：<br>  onCreate() 该方法在服务被创建时调用，该方法只会被调用一次，无论调用多少次startService()或bindService()方法，服务也只被创建一次。<br>  onDestroy()该方法在服务被终止时调用。<br>  与采用Context.startService()方法启动服务有关的生命周期方法<br>  onStart() 只有采用Context.startService()方法启动服务时才会回调该方法。该方法在服务开始运行时被调用。多次调用startService()方法尽管不会多次创建服务，但onStart() 方法会被多次调用。<br>  与采用Context.bindService()方法启动服务有关的生命周期方法<br>  onBind()只有采用Context.bindService()方法启动服务时才会回调该方法。该方法在调用者与服务绑定时被调用，当调用者与服务已经绑定，多次调用Context.bindService()方法并不会导致该方法被多次调用。<br>  onUnbind()只有采用Context.bindService()方法启动服务时才会回调该方法。该方法在调用者与服务解除绑定时被调用<br>  采用Context. bindService()方法启动服务的代码如下：<br>  public class HelloActivity extends Activity {<br>       ServiceConnection conn = new ServiceConnection() {<br>                public void onServiceConnected(ComponentName name, IBinder service) {<br>             }<br>             public void onServiceDisconnected(ComponentName name) {<br>             }<br>       };<br>      @Override<br>  public void onCreate(Bundle savedInstanceState) {<br>          Button button =(Button) this.findViewById(R.id.button);<br>          button.setOnClickListener(new View.OnClickListener(){<br>                 public void onClick(View v) {<br>                    Intent intent = new Intent(HelloActivity.this, SMSService.class);<br>                    bindService(intent, conn, Context.BIND_AUTO_CREATE);<br>                    //unbindService(conn);//解除绑定<br>            }});<br>      }<br>  }<br>  采用Context. bindService()方法启动服务的代码如下：<br>  public class HelloActivity extends Activity {<br>       ServiceConnection conn = new ServiceConnection() {<br>                public void onServiceConnected(ComponentName name, IBinder service) {<br>             }<br>             public void onServiceDisconnected(ComponentName name) {<br>             }<br>       };<br>      @Override<br>  public void onCreate(Bundle savedInstanceState) {<br>          Button button =(Button) this.findViewById(R.id.button);<br>          button.setOnClickListener(new View.OnClickListener(){<br>                 public void onClick(View v) {<br>                    Intent intent = new Intent(HelloActivity.this, SMSService.class);<br>                    bindService(intent, conn, Context.BIND_AUTO_CREATE);<br>                    //unbindService(conn);//解除绑定<br>            }});<br>      }<br>  }<br>  采用Context. bindService()方法启动服务的代码如下：<br>  public class HelloActivity extends Activity {<br>       ServiceConnection conn = new ServiceConnection() {<br>                public void onServiceConnected(ComponentName name, IBinder service) {<br>             }<br>             public void onServiceDisconnected(ComponentName name) {<br>             }<br>       };<br>      @Override<br>  public void onCreate(Bundle savedInstanceState) {<br>          Button button =(Button) this.findViewById(R.id.button);<br>          button.setOnClickListener(new View.OnClickListener(){<br>                 public void onClick(View v) {<br>                    Intent intent = new Intent(HelloActivity.this, SMSService.class);<br>                    bindService(intent, conn, Context.BIND_AUTO_CREATE);<br>                    //unbindService(conn);//解除绑定<br>            }});<br>      }<br>  }<br>19.ListView优化<br>  工作原理:<br>  ListView 针对List中每个item，要求 adapter “给我一个视图” (getView)。<br>  一个新的视图被返回并显示<br>  如果我们有上亿个项目要显示怎么办？为每个项目创建一个新视图？NO!这不可能！<br>  实际上Android为你缓存了视图。<br>  Android中有个叫做Recycler的构件，下图是他的工作原理：<br>  如果你有10亿个项目(item)，其中只有可见的项目存在内存中，其他的在Recycler中。</p><ol><li><p>ListView先请求一个type1视图(getView)然后请求其他可见的项目。convertView在getView中是空(null)的。</p></li><li><p>当item1滚出屏幕，并且一个新的项目从屏幕低端上来时，ListView再请求一个type1视图。convertView此时不是空值了，它的值是item1。你只需设定新的数据然后返回convertView，不必重新创建一个视图。<br>20.广播接收者生命周期<br>一个广播接收者有一个回调方法：void onReceive(Context curContext, Intent broadcastMsg)。当一个广播消息到达接收者是，Android调用它的onReceive()方法并传递给它包含消息的Intent对象。广播接收者被认为仅当它执行这个方法时是活跃的。当onReceive()返回后，它是不活跃的。<br>有一个活跃的广播接收者的进程是受保护的，不会被杀死。但是系统可以在任何时候杀死仅有不活跃组件的进程，当占用的内存别的进程需要时。<br>这带来一个问题，当一个广播消息的响应时费时的，因此应该在独立的线程中做这些事，远离用户界面其它组件运行的主线程。如果onReceive()衍生线程然后返回，整个进程，包括新的线程，被判定为不活跃的（除非进程中的其它应用程序组件是活跃的），将使它处于被杀的危机。解决这个问题的方法是onReceive()启动一个服务，及时服务做这个工作，因此系统知道进程中有活跃的工作在做。<br>21.设计模式和IoC(控制反转)<br>Android 框架魅力的源泉在于IoC，在开发Android 的过程中你会时刻感受到IoC 带来<br>的巨大方便，就拿Activity 来说，下面的函数是框架调用自动调用的：<br>protected void onCreate(Bundle savedInstanceState) ；<br>不是程序编写者主动去调用，反而是用户写的代码被框架调用，这也就反转<br>了！当然IoC 本身的内涵远远不止这些，但是从这个例子中也可以窥视出IoC<br>带来的巨大好处。此类的例子在Android 随处可见，例如说数据库的管理类，<br>例如说Android 中SAX 的Handler 的调用等。有时候，您甚至需要自己编写简<br>单的IoC 实现，上面展示的多线程现在就是一个说明。<br>22.Android中的长度单位详解<br>现在这里介绍一下dp 和sp。dp 也就是dip。这个和sp 基本类似。如果设置表示长度、高度等属性时可以使用dp 或sp。但如果设置字体，需要使用sp。dp 是与密度无关，sp 除了与密度无关外，还与scale 无关。如果屏幕密度为160，这时dp 和sp 和px 是一样的。1dp=1sp=1px，但如果使用px 作单位，如果屏幕大小不变（假设还是3.2 寸），而屏幕密度变成了320。那么原来TextView 的宽度设成160px，在密度为320 的3.2 寸屏幕里看要比在密度为160 的3.2 寸屏幕上看短了一半。但如果设置成160dp 或160sp 的话。系统会自动将width 属性值设置成320px 的。也就是160 * 320 / 160。其中320 / 160 可称为密<br>度比例因子。也就是说，如果使用dp 和sp，系统会根据屏幕密度的变化自动<br>进行转换。<br>下面看一下其他单位的含义<br>px：表示屏幕实际的象素。例如，320<em>480 的屏幕在横向有320个象素，<br>在纵向有480 个象素。<br>in：表示英寸，是屏幕的物理尺寸。每英寸等于2.54 厘米。例如，形容<br>手机屏幕大小，经常说，3.2（英）寸、3.5（英）寸、4（英）寸就是指这个<br>单位。这些尺寸是屏幕的对角线长度。如果手机的屏幕是3.2 英寸，表示手机<br>的屏幕（可视区域）对角线长度是3.2</em>2.54 = 8.128 厘米。读者可以去量<br>一量自己的手机屏幕，看和实际的尺寸是否一致。<br>23.4种activity的启动模式<br>standard: 标准模式，一调用startActivity()方法就会产生一个新的实例。<br>singleTop: 如果已经有一个实例位于Activity栈的顶部时，就不产生新的实例，而只是调用Activity中的newInstance()方法。如果不位于栈顶，会产生一个新的实例。<br>singleTask: 会在一个新的task中产生这个实例，以后每次调用都会使用这个，不会去产生新的实例了。<br>singleInstance: 这个跟singleTask基本上是一样，只有一个区别：在这个模式下的Activity实例所处的task中，只能有这个activity实例，不能有其他的实例。<br>24.什么是ANR 如何避免它?<br>ANR：Application Not Responding，五秒<br>在Android中，活动管理器和窗口管理器这两个系统服务负责监视应用程序的响应。当出现下列情况时，Android就会显示ANR对话框了：<br>　　对输入事件(如按键、触摸屏事件)的响应超过5秒<br>　　意向接受器(intentReceiver)超过10秒钟仍未执行完毕　Android应用程序完全运行在一个独立的线程中(例如main)。这就意味着，任何在主线程中运行的，需要消耗大量时间的操作都会引发ANR。因为此时，你的应用程序已经没有机会去响应输入事件和意向广播(Intent broadcast)。<br>　　因此，任何运行在主线程中的方法，都要尽可能的只做少量的工作。特别是活动生命周期中的重要方法如onCreate()和 onResume()等更应如此。潜在的比较耗时的操作，如访问网络和数据库;或者是开销很大的计算，比如改变位图的大小，需要在一个单独的子线程中完成(或者是使用异步请求，如数据库操作)。但这并不意味着你的主线程需要进入阻塞状态已等待子线程结束 – 也不需要调用Therad.wait()或者Thread.sleep()方法。取而代之的是，主线程为子线程提供一个句柄(Handler)，让子线程在即将结束的时候调用它(xing:可以参看Snake的例子，这种方法与以前我们所接触的有所不同)。使用这种方法涉及你的应用程序，能够保证你的程序对输入保持良好的响应，从而避免因为输入事件超过5秒钟不被处理而产生的ANR。这种实践需要应用到所有显示用户界面的线程，因为他们都面临着同样的超时问题。<br>25.Android Intent的使用<br>在一个Android应用中，主要是由一些组件组成，（Activity,Service,ContentProvider,etc.)在这些组件之间的通讯中，由Intent协助完成。<br>正如网上一些人解析所说，Intent负责对应用中一次操作的动作、动作涉及数据、附加数据进行描述，Android则根据此Intent的描述，负责找到对应的组件，将 Intent传递给调用的组件，并完成组件的调用。Intent在这里起着实现调用者与被调用者之间的解耦作用。<br>Intent传递过程中，要找到目标消费者（另一个Activity,IntentReceiver或Service），也就是Intent的响应者，有两种方法来匹配：<br>1，显示匹配（Explicit)：<br>public TestB extents Activity<br>{<br>………<br>};<br>public class Test extends Activity<br>{  </p><div class="hljs"><pre><code>......  public void switchActivity()  {         Intent i = new Intent(Test.this, TestB.class);         this.startActivity(i);  }  </code></pre></div><p>}<br>public TestB extents Activity<br>{<br>………<br>};<br>public class Test extends Activity<br>{  </p><div class="hljs"><pre><code>......  public void switchActivity()  {         Intent i = new Intent(Test.this, TestB.class);         this.startActivity(i);  }  </code></pre></div><p>}<br>public TestB extents Activity<br>{<br>………<br>};<br>public class Test extends Activity<br>{  </p><div class="hljs"><pre><code>......  public void switchActivity()  {         Intent i = new Intent(Test.this, TestB.class);         this.startActivity(i);  }  </code></pre></div><p>}<br>代码简洁明了，执行了switchActivity()函数，就会马上跳转到名为TestB的Activity中。<br>2，隐式匹配(Implicit):<br>隐式匹配，首先要匹配Intent的几项值：Action, Category, Data/Type,Component<br>如果填写了Componet就是上例中的Test.class)这就形成了显示匹配。所以此部分只讲前几种匹配。匹配规则为最大匹配规则，<br>1，如果你填写了Action，如果有一个程序的Manifest.xml中的某一个Activity的IntentFilter段中定义了包含了相同的Action那么这个Intent就与这个目标Action匹配，如果这个Filter段中没有定义Type,Category，那么这个Activity就匹配了。但是如果手机中有两个以上的程序匹配，那么就会弹出一个对话可框来提示说明。<br>Action的值在Android中有很多预定义，如果你想直接转到你自己定义的Intent接收者，你可以在接收者的IntentFilter中加入一个自定义的Action值（同时要设定Category值为”android.intent.category.DEFAULT”），在你的Intent中设定该值为Intent的Action,就直接能跳转到你自己的Intent接收者中。因为这个Action在系统中是唯一的。<br>2,data/type，你可以用Uri来做为data,比如Uri uri = Uri.parse(<a href="http://www.google.com" target="_blank" rel="noopener">http://www.google.com</a> );<br>Intent i = new Intent(Intent.ACTION_VIEW,uri);手机的Intent分发过程中，会根据<a href="http://www.google.com" target="_blank" rel="noopener">http://www.google.com</a> 的scheme判断出数据类型type<br>手机的Brower则能匹配它，在Brower的Manifest.xml中的IntenFilter中首先有ACTION_VIEW Action,也能处理http:的type，<br>3，至于分类Category，一般不要去在Intent中设置它，如果你写Intent的接收者，就在Manifest.xml的Activity的IntentFilter中包含android.category.DEFAULT,这样所有不设置Category（Intent.addCategory(String c);）的Intent都会与这个Category匹配。<br>4,extras（附加信息），是其它所有附加信息的集合。使用extras可以为组件提供扩展信息，比如，如果要执行“发送电子邮件”这个动作，可以将电子邮件的标题、正文等保存在extras里，传给电子邮件发送组件。<br>26.如果后台的Activity由于某原因被系统回收了，如何在被系统回收之前保存当前状态？<br>当你的程序中某一个Activity A 在运行时中，主动或被动地运行另一个新的Activity B<br>这个时候A会执行<br>Java代码<br>public void onSaveInstanceState(Bundle outState) {    super.onSaveInstanceState(outState);    outState.putLong(“id”, 1234567890);}<br>B 完成以后又会来找A, 这个时候就有两种情况，一种是A被回收，一种是没有被回收，被回<br>收的A就要重新调用onCreate()方法，不同于直接启动的是这回onCreate()里是带上参数savedInstanceState，没被收回的就还是onResume就好了。<br>savedInstanceState是一个Bundle对象，你基本上可以把他理解为系统帮你维护的一个Map对象。在onCreate()里你可能会 用到它，如果正常启动onCreate就不会有它，所以用的时候要判断一下是否为空。<br>Java代码<br>if(savedInstanceState != null){<br>long id = savedInstanceState.getLong(“id”);<br>}<br>就像官方的Notepad教程 里的情况，你正在编辑某一个note，突然被中断，那么就把这个note的id记住，再起来的时候就可以根据这个id去把那个note取出来，程序就完整 一些。这也是看你的应用需不需要保存什么，比如你的界面就是读取一个列表，那就不需要特殊记住什么，哦， 没准你需要记住滚动条的位置…<br>27.如何退出Activity<br>对于单一Activity的应用来说，退出很简单，直接finish()即可。当然，也可以用killProcess()和System.exit()这样的方法。现提供几个方法，供参考：<br>1、抛异常强制退出：该方法通过抛异常，使程序Force Close。验证可以，但是，需要解决的问题是，如何使程序结束掉，而不弹出Force Close的窗口。<br>2、记录打开的Activity：每打开一个Activity，就记录下来。在需要退出时，关闭每一个Activity即可。<br>3、发送特定广播：在需要结束应用时，发送一个特定的广播，每个Activity收到广播后，关闭即可。<br>4、递归退出在打开新的Activity时使用startActivityForResult，然后自己加标志，在onActivityResult中处理，递归关闭。除了第一个，都是想办法把每一个Activity都结束掉，间接达到目的。但是这样做同样不完美。你会发现，如果自己的应用程序对每一个Activity都设置了nosensor，在两个Activity结束的间隙，sensor可能有效了。但至少，我们的目的达到了，而且没有影响用户使用。为了编程方便，最好定义一个Activity基类，处理这些共通问题。<br>28.请解释下在单线程模型中Message、Handler、Message Queue、Looper之间的关系。<br>Message Queue(消息队列)：用来存放通过Handler发布的消息，通常附属于某一个创建它的线程，可以通过Looper.myQueue()得到当前线程的消息队列<br>　　 Handler：可以发布或者处理一个消息或者操作一个Runnable，通过Handler发布消息，消息将只会发送到与它关联的消息队列，然也只能处理该消息队列中的消息<br>Looper：是Handler和消息队列之间通讯桥梁，程序组件首先通过Handler把消息传递给Looper，Looper把消息放入队列。Looper也把消息队列里的消息广播给所有的Handler，Handler接受到消息后调用handleMessage进行处理<br>　　 Message：消息的类型，在Handler类中的handleMessage方法中得到单个的消息进行处理.<br>29.你如何评价Android系统？优缺点。<br>答：优点：1、学习的开源性<br>　　 2、软件兼容性比较好<br>　　 3、软件发展迅速<br>　　 4、界面布局好<br>　　 缺点：1、版本过多<br>　　       2、先有软件少  3、商务性能差<br>30.谈谈android数据存储方式。<br>Android提供了5种方式存储数据：<br>（1）使用SharedPreferences存储数据；它是Android提供的用来存储一些简单配置信息的一种机制，采用了XML格式将数据存储到设备中。只能在同一个包内使用，不能在不同的包之间使用。<br>（2）文件存储数据；文件存储方式是一种较常用的方法，在Android中读取/写入文件的方法，与Java中实现I/O的程序是完全一样的，提供了openFileInput()和openFileOutput()方法来读取设备上的文件。<br>（3）SQLite数据库存储数据；SQLite是Android所带的一个标准的数据库，它支持SQL语句，它是一个轻量级的嵌入式数据库。<br>（4）使用ContentProvider存储数据；主要用于应用程序之间进行数据交换，从而能够让其他的应用保存或读取此Content Provider的各种数据类型。<br>（5）网络存储数据；通过网络上提供给我们的存储空间来上传(存储)和下载(获取)我们存储在网络空间中的数据信息。<br>31.Android中Activity, Intent, Content Provider, Service各有什么区别。<br>Activity： 活动，是最基本的android应用程序组件。一个活动就是一个单独的屏幕，每一个活动都被实现为一个独立的类，并且从活动基类继承而来。<br>Intent： 意图，描述应用想干什么。最重要的部分是动作和动作对应的数据。<br>Content Provider：内容提供器，android应用程序能够将它们的数据保存到文件、SQLite数据库中，甚至是任何有效的设备中。当你想将你的应用数据和其他应用共享时，内容提供器就可以发挥作用了。<br>Service：服务，具有一段较长生命周期且没有用户界面的程序。<br>32.View, surfaceView, GLSurfaceView有什么区别。<br>view是最基础的，必须在UI主线程内更新画面，速度较慢。<br>SurfaceView 是view的子类，类似使用双缓机制，在新的线程中更新画面所以刷新界面速度比view快<br>GLSurfaceView 是SurfaceView的子类，opengl 专用的<br>33.Manifest.xml文件中主要包括哪些信息？<br>manifest：根节点，描述了package中所有的内容。<br>uses-permission：请求你的package正常运作所需赋予的安全许可。<br>permission： 声明了安全许可来限制哪些程序能你package中的组件和功能。<br>instrumentation：声明了用来测试此package或其他package指令组件的代码。<br>application：包含package中application级别组件声明的根节点。<br>activity：Activity是用来与用户交互的主要工具。<br>receiver：IntentReceiver能使的application获得数据的改变或者发生的操作，即使它当前不在运行。<br>service：Service是能在后台运行任意时间的组件。<br>provider：ContentProvider是用来管理持久化数据并发布给其他应用程序使用的组件。<br>34.根据自己的理解描述下Android数字签名。<br>(1)所有的应用程序都必须有数字证书，Android系统不会安装一个没有数字证书的应用程序<br>(2)Android程序包使用的数字证书可以是自签名的，不需要一个权威的数字证书机构签名认证<br>(3)如果要正式发布一个Android ，必须使用一个合适的私钥生成的数字证书来给程序签名，而不能使用adt插件或者ant工具生成的调试证书来发布。<br>(4)数字证书都是有有效期的，Android只是在应用程序安装的时候才会检查证书的有效期。如果程序已经安装在系统中，即使证书过期也不会影响程序的正常功能。<br>35.AIDL的全称是什么?如何工作?能处理哪些类型的数据?<br>AIDL全称Android Interface Definition Language（AndRoid接口描述语言）是一种借口描述语言; 编译器可以通过aidl文件生成一段代码，通过预先定义的接口达到两个进程内部通信进程跨界对象访问的目的.AIDL的IPC的机制和COM或CORBA类似, 是基于接口的，但它是轻量级的。它使用代理类在客户端和实现层间传递值. 如果要使用AIDL, 需要完成2件事情: 1. 引入AIDL的相关类.; 2. 调用aidl产生的class.理论上, 参数可以传递基本数据类型和String, 还有就是Bundle的派生类, 不过在Eclipse中,目前的ADT不支持Bundle做为参数,<br>具体实现步骤如下:<br>1、创建AIDL文件, 在这个文件里面定义接口, 该接口定义了可供客户端访问的方法和属性。<br>2、编译AIDL文件, 用Ant的话, 可能需要手动, 使用Eclipse plugin的话,可以根据adil文件自动生产java文件并编译, 不需要人为介入.<br>3、在Java文件中, 实现AIDL中定义的接口. 编译器会根据AIDL接口, 产生一个JAVA接口。这个接口有一个名为Stub的内部抽象类，它继承扩展了接口并实现了远程调用需要的几个方法。接下来就需要自己去实现自定义的几个接口了.<br>4、向客户端提供接口ITaskBinder, 如果写的是service，扩展该Service并重载onBind ()方法来返回一个实现上述接口的类的实例。<br>5、在服务器端回调客户端的函数. 前提是当客户端获取的IBinder接口的时候,要去注册回调函数, 只有这样, 服务器端才知道该调用那些函数<br>AIDL语法很简单,可以用来声明一个带一个或多个方法的接口，也可以传递参数和返回值。 由于远程调用的需要, 这些参数和返回值并不是任何类型.下面是些AIDL支持的数据类型:</p></li><li><p>不需要import声明的简单Java编程语言类型(int,boolean等)</p></li><li><p>String, CharSequence不需要特殊声明</p></li><li><p>List, Map和Parcelables类型, 这些类型内所包含的数据成员也只能是简单数据类型, String等其他比支持的类型.<br>(另外: 我没尝试Parcelables, 在Eclipse+ADT下编译不过, 或许以后会有所支持).<br>实现接口时有几个原则:<br>.抛出的异常不要返回给调用者. 跨进程抛异常处理是不可取的.<br>.IPC调用是同步的。如果你知道一个IPC服务需要超过几毫秒的时间才能完成地话，你应该避免在Activity的主线程中调用。也就是IPC调用会挂起应用程序导致界面失去响应. 这种情况应该考虑单起一个线程来处理.<br>.不能在AIDL接口中声明静态属性。<br>IPC的调用步骤:</p></li><li><p>声明一个接口类型的变量，该接口类型在.aidl文件中定义。</p></li><li><p>实现ServiceConnection。</p></li><li><p>调用ApplicationContext.bindService(),并在ServiceConnection实现中进行传递.</p></li><li><p>在ServiceConnection.onServiceConnected()实现中，你会接收一个IBinder实例(被调用的Service). 调用<br>YourInterfaceName.Stub.asInterface((IBinder)service)将参数转换为YourInterface类型。</p></li><li><p>调用接口中定义的方法。你总要检测到DeadObjectException异常，该异常在连接断开时被抛出。它只会被远程方法抛出。</p></li><li><p>断开连接，调用接口实例中的ApplicationContext.unbindService()<br>参考：<a href="http://buaadallas.blog.51cto.com/399160/372090" target="_blank" rel="noopener">http://buaadallas.blog.51cto.com/399160/372090</a><br>36.android:gravity与android:layout_gravity的区别<br>LinearLayout有两个非常相似的属性：android:gravity与android:layout_gravity。他们的区别在 于：android:gravity用于设置View组件的对齐方式，而android:layout_gravity用于设置Container组件的 对齐方式。<br>举个例子，我们可以通过设置android:gravity=”center”来让EditText中的文字在EditText组件中居中显示；同 时我们设置EditText的android:layout_gravity=”right”来让EditText组件在LinearLayout中居中 显示。来实践以下：<br>正如我们所看到的，在EditText中，其中的文字已经居中显示了，而EditText组件自己也对齐到了LinearLayout的右侧。<br><LinearLayout   xmlns:android="http://schemas.android.com/apk/res/android"   android:orientation="vertical"   android:layout_width="fill_parent"   android:layout_height="fill_parent"><br><EditText      android:layout_width="wrap_content"      android:gravity="center"      android:layout_height="wrap_content"      android:text="one"      android:layout_gravity="right"/>   </p>   </LinearLayout>  <p>   <LinearLayout      xmlns:android="http://schemas.android.com/apk/res/android"      android:orientation="vertical"      android:layout_width="fill_parent"      android:layout_height="fill_parent"><br>   &lt;EditText   </p><div class="hljs"><pre><code>android:layout_width=&quot;wrap_content&quot;   android:gravity=&quot;center&quot;   android:layout_height=&quot;wrap_content&quot;   android:text=&quot;one&quot;   android:layout_gravity=&quot;right&quot;/&gt;   </code></pre></div></LinearLayout>  <p><LinearLayout      xmlns:android="http://schemas.android.com/apk/res/android"      android:orientation="vertical"      android:layout_width="fill_parent"      android:layout_height="fill_parent"><br>   &lt;EditText   </p><div class="hljs"><pre><code>android:layout_width=&quot;wrap_content&quot;   android:gravity=&quot;center&quot;   android:layout_height=&quot;wrap_content&quot;   android:text=&quot;one&quot;   android:layout_gravity=&quot;right&quot;/&gt;   </code></pre></div></LinearLayout>  这两个属性也可以用于 Framlayout Textview 等等，表示的意思大同小异37.padding与margin的区别padding填充的意思，指的是view中的content与view边缘的距离，类似文本中的indent而margin表示的是view的左边缘与parent view的左边缘的距离margin一般用来描述控件间位置关系，而padding一般描述控件内容和控件的位置关系。简单，padding是站在父 view的角度描述问题，它规定它里面的内容必须与这个父view边界的距离。margin则是站在自己的角度描述问题，规定自己和其他（上下左右）的 view之间的距离，如果同一级只有一个view，那么它的效果基本上就和padding一样了。例如我的XML layout代码如下：view plaincopy to clipboardprint?<?xml version="1.0" encoding="utf-8"?>   <LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"    android:orientation="vertical"    android:layout_width="fill_parent"    android:layout_height="fill_parent"    android:paddingLeft="10dip"    android:paddingRight="10dip"    android:paddingTop="10dip"    android:paddingBottom="10dip"    >   <TextView       android:layout_width="wrap_content"      android:layout_height="wrap_content"      android:background="#FF0000"    android:text="@string/hello"    android:paddingLeft="50dip"    android:paddingRight="50dip"    android:paddingTop="50dip"    android:paddingBottom="50dip"    android:layout_marginBottom="10dip"    />    <TextView       android:layout_width="wrap_content"      android:layout_height="wrap_content"      android:background="#FF0000"    android:text="@string/hello"    android:paddingLeft="50dip"    android:paddingRight="50dip"    android:paddingTop="50dip"    android:paddingBottom="50dip"    android:layout_marginBottom="10dip"    />    <TextView       android:layout_width="wrap_content"      android:layout_height="wrap_content"      android:background="#FF0000"    android:text="@string/hello"    android:paddingLeft="50dip"    android:paddingRight="50dip"    android:paddingTop="50dip"    android:paddingBottom="50dip"    android:layout_marginBottom="10dip"    />    <TextView       android:layout_width="wrap_content"      android:layout_height="wrap_content"      android:background="#FF0000"    android:text="@string/hello"    android:paddingLeft="50dip"    android:paddingRight="50dip"    android:paddingTop="50dip"    android:paddingBottom="50dip"    android:layout_marginBottom="10dip"    />   </LinearLayout>    <?xml version="1.0" encoding="utf-8"?><p><br>&lt;LinearLayout xmlns:android=”<a href="http://schemas.android.com/apk/res/android&quot;" target="_blank" rel="noopener">http://schemas.android.com/apk/res/android&quot;</a><br> android:orientation=”vertical”<br> android:layout_width=”fill_parent”<br> android:layout_height=”fill_parent”<br> android:paddingLeft=”10dip”<br> android:paddingRight=”10dip”<br> android:paddingTop=”10dip”<br> android:paddingBottom=”10dip”   </p><blockquote><p><TextView       android:layout_width="wrap_content"      android:layout_height="wrap_content"      android:background="#FF0000"    android:text="@string/hello"    android:paddingLeft="50dip"    android:paddingRight="50dip"    android:paddingTop="50dip"    android:paddingBottom="50dip"    android:layout_marginBottom="10dip"    /><br> <TextView       android:layout_width="wrap_content"      android:layout_height="wrap_content"      android:background="#FF0000"    android:text="@string/hello"    android:paddingLeft="50dip"    android:paddingRight="50dip"    android:paddingTop="50dip"    android:paddingBottom="50dip"    android:layout_marginBottom="10dip"    /><br> <TextView       android:layout_width="wrap_content"      android:layout_height="wrap_content"      android:background="#FF0000"    android:text="@string/hello"    android:paddingLeft="50dip"    android:paddingRight="50dip"    android:paddingTop="50dip"    android:paddingBottom="50dip"    android:layout_marginBottom="10dip"    /><br> <TextView       android:layout_width="wrap_content"      android:layout_height="wrap_content"      android:background="#FF0000"    android:text="@string/hello"    android:paddingLeft="50dip"    android:paddingRight="50dip"    android:paddingTop="50dip"    android:paddingBottom="50dip"    android:layout_marginBottom="10dip"    />   </p></LinearLayout>    </blockquote><?xml version="1.0" encoding="utf-8"?><p><br>&lt;LinearLayout xmlns:android=”<a href="http://schemas.android.com/apk/res/android&quot;" target="_blank" rel="noopener">http://schemas.android.com/apk/res/android&quot;</a><br> android:orientation=”vertical”<br> android:layout_width=”fill_parent”<br> android:layout_height=”fill_parent”<br> android:paddingLeft=”10dip”<br> android:paddingRight=”10dip”<br> android:paddingTop=”10dip”<br> android:paddingBottom=”10dip”   </p><blockquote><p><TextView       android:layout_width="wrap_content"      android:layout_height="wrap_content"      android:background="#FF0000"    android:text="@string/hello"    android:paddingLeft="50dip"    android:paddingRight="50dip"    android:paddingTop="50dip"    android:paddingBottom="50dip"    android:layout_marginBottom="10dip"    /><br> <TextView       android:layout_width="wrap_content"      android:layout_height="wrap_content"      android:background="#FF0000"    android:text="@string/hello"    android:paddingLeft="50dip"    android:paddingRight="50dip"    android:paddingTop="50dip"    android:paddingBottom="50dip"    android:layout_marginBottom="10dip"    /><br> <TextView       android:layout_width="wrap_content"      android:layout_height="wrap_content"      android:background="#FF0000"    android:text="@string/hello"    android:paddingLeft="50dip"    android:paddingRight="50dip"    android:paddingTop="50dip"    android:paddingBottom="50dip"    android:layout_marginBottom="10dip"    /><br> <TextView       android:layout_width="wrap_content"      android:layout_height="wrap_content"      android:background="#FF0000"    android:text="@string/hello"    android:paddingLeft="50dip"    android:paddingRight="50dip"    android:paddingTop="50dip"    android:paddingBottom="50dip"    android:layout_marginBottom="10dip"    />   </p></LinearLayout>    那么我会得到如下的效果，图上已经很明确的标出来区别咯。38. 注册广播接收者两种方式的区别现在我们就来实现一个简单的广播程序。Android提供了两种注册广播接受者的形式，分别是在程序中动态注册和在xml中指定。他们之间的区别就是作用 的范围不同，程序动态注册的接收者只在程序运行过程中有效，而在xml注册的接收者不管你的程序有没有启动有会起作用。39.Dalvik基于JVM的改进</blockquote></li><li><p>几个class变为一个dex，constant pool，省内存</p></li><li><p>Zygote，copy-on-write shared,省内存，省cpu，省电</p></li><li><p>基于寄存器的bytecode，省指令，省cpu，省电</p></li><li><p>Trace-based JIT,省cpu，省电,省内存<br>40.android中有哪几种解析xml的类,官方推荐哪种？以及它们的原理和区别.<br>Ø DOM解析<br>优点:</p></li><li><p>XML树在内存中完整存储,因此可以直接修改其数据和结构.</p></li><li><p>可以通过该解析器随时访问XML树中的任何一个节点.</p></li><li><p>DOM解析器的API在使用上也相对比较简单.<br>缺点:如果XML文档体积比较大时,将文档读入内存是非常消耗系统资源的.<br>使用场景:DOM 是用与平台和语言无关的方式表示 XML 文档的官方 W3C 标准.DOM 是以层次结构组织的节点的集合.这个层次结构允许开发人员在树中寻找特定信息.分析该结构通常需要加载整个文档和构造层次结构,然后才能进行任何工作.DOM是基于对象层次结构的.<br>Ø SAX解析<br>优点:<br>SAX 对内存的要求比较低,因为它让开发人员自己来决定所要处理的标签.特别是当开发人员只需要处理文档中所包含的部分数据时,SAX 这种扩展能力得到了更好的体现.<br>缺点:<br>用SAX方式进行XML解析时,需要顺序执行,所以很难访问到同一文档中的不同数据.此外,在基于该方式的解析编码过程也相对复杂.<br>使用场景:<br>对于含有数据量十分巨大,而又不用对文档的所有数据进行遍历或者分析的时候,使用该方法十分有效.该方法不用将整个文档读入内存,而只需读取到程序所需的文档标签处即可.<br>Ø Xmlpull解析<br>android SDK提供了xmlpull api,xmlpull和sax类似,是基于流（stream）操作文件,然后根据节点事件回调开发者编写的处理程序.因为是基于流的处理,因此xmlpull和sax都比较节约内存资源,不会象dom那样要把所有节点以对橡树的形式展现在内存中.xmlpull比sax更简明,而且不需要扫描完整个流.<br>41.Android系统中GC什么情况下会出现内存泄露呢？<br>出现情况:</p></li><li><p>数据库的cursor没有关闭</p></li><li><p>构造adapter时,没有使用缓存contentview<br> 衍生listview的优化问题—–减少创建view的对象,充分使用contentview,可以使用一静态类来优化处理getview的过程/</p></li><li><p>Bitmap对象不使用时采用recycle()释放内存</p></li><li><p>activity中的对象的生命周期大于activity<br>调试方法: DDMS==&gt; HEAPSZIE==&gt;dataobject==&gt;[Total Size]<br>42.谈谈对Android NDK的理解<br>NDK 全称: Native Development Kit</p></li><li><p>误解<br>  误解一: NDK 发布之前, Android 不支持进行 C 开发<br>  在Google 中搜索 “NDK” ,很多 “Android 终于可以使用 C++ 开发 ” 之类的标题,这是一种对 Android 平台编程方式的误解.其实, Android 平台从诞生起,就已经支持 C . C++ 开发.众所周知, Android 的 SDK 基于 Java 实现,这意味着基于 Android SDK 进行开发的第三方应用都必须使用 Java 语言.但这并不等同于 “ 第三方应用只能使用 Java” .在 Android SDK 首次发布时, Google 就宣称其虚拟机 Dalvik 支持 JNI 编程方式,也就是第三方应用完全可以通过 JNI 调用自己的 C 动态库,即在 Android 平台上, “Java+C” 的编程方式是一直都可以实现的.<br>当然这种误解的产生是有根源的:在Android SDK 文档里,找不到任何 JNI 方面的帮助.即使第三方应用开发者使用 JNI 完成了自己的 C 动态链接库（ so ）开发,但是 so 如何和应用程序一起打包成 apk 并发布？这里面也存在技术障碍.我曾经花了不少时间,安装交叉编译器创建 so ,并通过 asset （资源）方式,实现捆绑 so 发布.但这种方式只能属于取巧的方式,并非官方支持.所以,在 NDK 出来之前,我们将 “Java+C” 的开发模式称之为灰色模式,即官方既不声明 “ 支持这种方式 ” ,也不声明 “ 不支持这种方式 ” .<br>误解二:有了 NDK ,我们可以使用纯 C 开发 Android 应用<br>Android SDK采用 Java 语言发布,把众多的 C 开发人员排除在第三方应用开发外（ 注意:我们所有讨论都是基于“ 第三方应用开发 ” , Android 系统基于 Linux ,系统级别的开发肯定是支持 C 语言的. ）.NDK 的发布,许多人会误以为,类似于 Symbian . WM ,在 Android 平台上终于可以使用纯 C . C++ 开发第三方应用了！其实不然, NDK 文档明确说明: it is not a good way .因为 NDK 并没有提供各种系统事件处理支持,也没有提供应用程序生命周期维护.此外,在本次发布的 NDK 中,应用程序 UI 方面的 API 也没有提供.至少目前来说,使用纯 C . C++ 开发一个完整应用的条件还不完备.<br> 1.NDK 是一系列工具的集合.<br>NDK提供了一系列的工具,帮助开发者快速开发 C （或 C++ ）的动态库,并能自动将 so 和 java 应用一起打包成 apk .这些工具对开发者的帮助是巨大的.<br>NDK集成了交叉编译器,并提供了相应的 mk 文件隔离 CPU .平台. ABI 等差异,开发人员只需要简单修改 mk 文件（指出 “ 哪些文件需要编译 ” . “ 编译特性要求 ” 等）,就可以创建出 NDK可以自动地将 so 和 Java 应用一起打包,极大地减轻了开发人员的打包工作.<br> 2.NDK 提供了一份稳定.功能有限的 API 头文件声明.<br>Google明确声明该 API 是稳定的,在后续所有版本中都稳定支持当前发布的 API .从该版本的 NDK 中看出,这些 API 支持的功能非常有限,包含有: C 标准库（ libc ）.标准数学库（ libm ）.压缩库（ libz ）. Log 库（ liblog ）.</p></li><li><p>NDK 带来什么</p></li><li><p>NDK 的发布,使 “Java+C” 的开发方式终于转正,成为官方支持的开发方式.<br>使用NDK ,我们可以将要求高性能的应用逻辑使用 C 开发,从而提高应用程序的执行效率.<br>使用NDK ,我们可以将需要保密的应用逻辑使用 C 开发.毕竟, Java 包都是可以反编译的.<br>NDK促使专业 so 组件商的出现.（乐观猜想,要视乎 Android 用户的数量）<br>  2.NDK 将是 Android 平台支持 C 开发的开端. NDK提供了的开发工具集合,使开发人员可以便捷地开发.发布 C 组件.同时, Google承诺在 NDK 后续版本中提高 “ 可调式 ” 能力,即提供远程的 gdb 工具,使我们可以便捷地调试 C 源码.在支持 Android 平台 C 开发,我们能感觉到 Google 花费了很大精力,我们有理由憧憬 “C 组件支持 ” 只是 Google Android 平台上C 开发的开端.毕竟, C 程序员仍然是码农阵营中的绝对主力,将这部分人排除在 Android 应用开发之外,显然是不利于 Android 平台繁荣昌盛的.<br>1、一个”.java”源文件中是否可以包括多个类（不是内部类）？有什么限制？</p></li></ol><hr><p>#Android面试题</p><p>四大组件很熟悉了吧，<br>ContentProvider的生命周期是什么；<br><a href="http://www.cnblogs.com/bravestarrhu/archive/2012/05/02/2479461.html" target="_blank" rel="noopener">http://www.cnblogs.com/bravestarrhu/archive/2012/05/02/2479461.html</a><br>Android设备开机的启动过程；<br><a href="http://blog.jobbole.com/67931/" target="_blank" rel="noopener">http://blog.jobbole.com/67931/</a><br>Activity的视图层次是什么？<br>打开一个对话框的时候，这个对话框是如何加入到视图上去的？<br>Dialog、PopupWindow、WindowManager加载视图的区别；<br>Service与Thread的区别；<br>ServiceManager、ActivityManager、XXXManager是干什么的；<br>为什么一定要在UI线程更新视图，为什么要这么设计；<br>打包APK的过程干了什么；<br>安装APK的过程干了什么；<br>启动APK的过程干了什么；<br>怎么玩DexLoader（动态升级）；<br>View的生命周期是啥；<br>TWEEN动画跟熟悉动画在View的绘制过程是怎么作用的；<br>自定义动画玩过吗，里面的Matrix怎么控制。<br>res里面的XML资源最终都要转化成JavaCode，怎么完全脱离res，用纯代码的方式实现res资源的功能，怎么缩放一张点九图；<br>Binder原理是什么，出了Binder之外，还能怎么跟Service交互；<br>Touch事件的分发机制；<br>能不能用代码模拟一组TOUCH事件（比如自动点击广告，自动滚动）；<br>ROOT的原理是什么，系统是怎么管理APP的权限的；<br>Material Desgin这么好看，为什么不出兼容包，让5.0以下的系统也能要动画效果；<br>ART模式与Dalvik有什么不同；<br>Render Thread是怎么工作的；<br>为什么TMD不把功能都用H5实现然后把需求都扔给前段的人去做；<br>ServiceManager、ActivityManager、packageManager 、*****Manager 都弄懂了？<br>Binder 也搞清楚了？<br>IPC 也弄明白了？<br>FrameWork 层的每个类都折腾了？<br>Hook 会玩了？<br>各种 SystemService 也知道怎么运行的了？<br>View 的渲染你明白是怎么回事了？<br>Intent 是如何实现 1 等之间的解耦合的？<br>单元测试会写了？<br>Monkey 能跑多长时间？<br>性能测试通过了？<br>ClassLoader 和 DexLoader 会玩了？<br>Context 是个啥你也知道了？<br>权限机制也弄清楚了？<br>触屏事件的分发呢？<br>Handler 、Message 和 Looper 是怎么跑起来的？<br>如果上面超过一半的东西题主还没有弄清楚，洗洗睡，明天早点起来看书。<br>1、 Service两种方式的区别</p><p>2、 Handler在项目怎么用的，线程间如何通信的</p><p>3、 AsyncTask和AsyncQueryHandler</p><p>5、 消息推送机制xmpp协议，客户端发送服务器好处理，只要知道服务器IP就可以，服务器如何给客户端推送消息呢</p><p>6、 oauth认证</p><p>7、 HTML和XML的区别</p><p>8、 多线程断点续传下载如何实现续传的</p><p>9、 TCP、UDP的区别</p><p>10、 aidl开发</p><p>11、 Android中JNI和NDK的使用，了解WebService调用技术</p><p>12、 Android安全机制，垃圾回收机制</p><p>13、 AJAX</p><p>14、 屏幕适配</p><p>15、 android ui的几个概念：px,dip(dp),sp,dpi,分辨率等，dpi是在Android资源随着不同手机的分辨率自动进行适配，res-》drawable-hdpi</p><p>16、 Launcher如何设置壁纸</p><hr><h1 id="Android面试试题"><a href="#Android面试试题" class="headerlink" title="Android面试试题"></a>Android面试试题</h1><h3 id="一般简单题"><a href="#一般简单题" class="headerlink" title="一般简单题"></a>一般简单题</h3><ol><li>Android dvm的进程和Linux的进程，应用程序的进程是否为同一个概念？<br>DVM指Dalivk的虚拟机，每一个Android应用程序都在它自己的进程中运行，都拥有一个独立的Dalivk虚拟机实例。而每一个DVM都是在Linux中的一个进程，所以说可以认为是同一个概念。</li><li>SIM卡的 EF 文件有何作用？<br>sim卡的文件系统有自己的规范，主要是为了和手机通讯，sim本身可以有自己的操作系统，EF就是做存储并和手机通讯用的。</li><li>嵌入式操作系统内存管理有哪几种，各有何特性？<br>页式，段式，段页，用到了MMU，虚拟控件等技术。</li><li>什么是嵌入式实时操作系统，Android 操作系统属于实时操作系统吗？<br>嵌入式实时操作系统是指当外界事件或数据产生时，能够接受并以足够快的速度予以处理，其处理的结果又能在规定的时间之内来控制生产过程或对处理系统作出快速响应，并控制所有实时任务协调一致运行的嵌入式操作系统。主要用于工业控制、军事设备、航空航天等领域对系统的响应时间有苛刻的要求，这就需要使用实时系统。又可分为软实时和硬实时两种，而android是基于linux内核的，因此属于软实时。</li><li>一条最长的短信息约占多少byte？<br>中文70(包括标点)，英文占160字节。</li><li>Android中的动画有哪几类，它们的特点和区别是什么？<br>两种，一中是Tween动画，一种是Frame动画。这种实现方式可以使视图组件移动、放大、缩小以及产生透明度的变化；另一种Frame动画，传统的动画方法，通过顺序的播放排列好的图片来实现，类似电影。</li><li>Handler机制的原理<br>Andriod提供了 Handler 和 Looper 来满足线程间的通信。Handler 先进先出原则。Looper类用来管理特定线程内对象之间的消息交换(Message Exchange)。<br>Looper: 一个线程可以产生一个Looper对象，由它来管理此线程里的Message Queue(消息队列)。<br>Handler: 你可以构造Handler对象来与Looper沟通，以便push新消息到Message Queue里；或者接收Looper从Message Queue取出)所送来的消息。<br>Message Queue(消息队列):用来存放线程放入的消息。<br>线程：UI thread 通常就是main thread，而Android启动程序时会替它建立一个Message Queue。  </li><li>说说MVC模式的原理，它在Android中的运用<br>MVC(Model_view_controller)” 模型-视图-控制器”。 MVC应用程序总是由这三个部分组成。Event(事件)导致Controller改变Model或View，或者同时改变两者。只要 Controller改变了Models的数据或者属性，所有依赖的View都会自动更新。类似的，只要Controller改变了View，View会从潜在的Model中获取数据来刷新自己。  </li></ol><hr><h3 id="View重绘和内存泄露"><a href="#View重绘和内存泄露" class="headerlink" title="View重绘和内存泄露"></a>View重绘和内存泄露</h3><ol start="9"><li>View的刷新<br>在需要刷新的地方，使用Handler.sendmessage发送消息，然后在Handler的getmessage里面执行invalidate或者invalidate  </li><li>GC内存泄露<br>出现情况：  <ul><li>数据库的cursor没有关闭。</li><li>构造adapter时，没有使用缓存contentview。衍生listview的优化问题：减少创建view的对象，充分使用contentview，可以使用一静态类来优化处理getview的过程。</li><li>Bitmap对象不使用时采用recycle()释放内存。</li><li>activity中的对象的生命周期大于activity。  </li></ul></li></ol><hr><h3 id="Activity"><a href="#Activity" class="headerlink" title="Activity"></a>Activity</h3><ol start="11"><li>Activity的生命周期  <div class="hljs"><pre><code class="hljs aspectj">  <span class="hljs-meta">@Override</span>   <span class="hljs-keyword">protected</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(Bundle savedInstanceState)</span> </span>&#123;       <span class="hljs-keyword">super</span>.onCreate(savedInstanceState);       setContentView(R.layout.activity_main);       <span class="hljs-comment">//在这里创建界面，做一些数据的初始化工作。</span>   &#125;   <span class="hljs-meta">@Override</span>   <span class="hljs-keyword">protected</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onStart</span><span class="hljs-params">()</span> </span>&#123;       <span class="hljs-keyword">super</span>.onStart();       <span class="hljs-comment">//到这一步变成用户可见不可交互的。</span>   &#125;   <span class="hljs-meta">@Override</span>   <span class="hljs-keyword">protected</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onRestart</span><span class="hljs-params">()</span> </span>&#123;       <span class="hljs-keyword">super</span>.onRestart();       <span class="hljs-comment">//從stop重新開始</span>   &#125;   <span class="hljs-meta">@Override</span>   <span class="hljs-keyword">protected</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onResume</span><span class="hljs-params">()</span> </span>&#123;       <span class="hljs-keyword">super</span>.onResume();       <span class="hljs-comment">//变成和用户可交互的</span>   &#125;   <span class="hljs-meta">@Override</span>   <span class="hljs-keyword">protected</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onPause</span><span class="hljs-params">()</span> </span>&#123;       <span class="hljs-keyword">super</span>.onPause();       <span class="hljs-comment">//到这一步是可见但不可交互的，系统会停止动画等消耗CPU的事情从上文的描述已经知道，应该在这里保存你的一些数据，</span>       <span class="hljs-comment">// 因为这个时候你的程序的优先级降低，有可能被系统收回。在这里保存的数据，应该在 onResume里读出来，</span>       <span class="hljs-comment">// 注意：这个方法里做的事情时间要短，因为下一个activity不会等到这个方法完成才启动。</span>   &#125;   <span class="hljs-meta">@Override</span>   <span class="hljs-keyword">protected</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onStop</span><span class="hljs-params">()</span> </span>&#123;       <span class="hljs-keyword">super</span>.onStop();       <span class="hljs-comment">//变得不可见，被下一个activity覆盖了。</span>   &#125;   <span class="hljs-meta">@Override</span>   <span class="hljs-keyword">protected</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onDestroy</span><span class="hljs-params">()</span> </span>&#123;       <span class="hljs-keyword">super</span>.onDestroy();       <span class="hljs-comment">//这是activity被干掉前最后一个被调用方法了，可能是外面类调用finish方法或者是系统为了</span>       <span class="hljs-comment">// 节省空间将它暂时性的干掉，可以用isFinishing()来判断它，</span>       <span class="hljs-comment">// 如果你有一个Progress Dialog在线程中转动，请在onDestroy里把他cancel掉，</span>       <span class="hljs-comment">// 不然等线程结束的时候，调用Dialog的cancel方法会抛异常的。</span>   &#125;  ```  <span class="hljs-number">12.</span> 让Activity变成一个窗口：Activity属性设定    可能有人希望做出来的应用程序是一个漂浮在手机主界面的东西，那么很简单你只需要设置一下Activity的主题就可以了在AndroidManifest.xml 中定义 Activity的地方一句话：</code></pre></div>android:theme=”@android:style/Theme.Dialog”<div class="hljs"><pre><code class="hljs plain">这就使你的应用程序变成对话框的形式弹出来了，或者</code></pre></div>android:theme=”@android:style/Theme.Translucent”<div class="hljs"><pre><code class="hljs reasonml">  就变成半透明的，类似的这种activity的属性可以在android.<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">R</span>.</span></span>styleable 类的AndroidManifestActivity 方法中看到，<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">AndroidManifest</span>.</span></span>xml中所有元素的属性的介绍都可以参考这个类android.<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">R</span>.</span></span>styleable上面说的是属性名称，具体有什么值是在android.<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">R</span>.</span></span>style中可以看到，比如这个<span class="hljs-string">"@android:style/Theme.Dialog"</span>就对应于android.<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">R</span>.</span></span>style.Theme_Dialog ,（<span class="hljs-character">'_'</span>换成<span class="hljs-character">'.'</span> ）就可以用在描述文件中了，找找类定义和描述文件中的对应关系就都明白了。   <span class="hljs-number">13.</span> 你后台的Activity被系统回收怎么办：onSaveInstanceState  当你的程序中某一个Activity A 在运行时中，主动或被动地运行另一个新的Activity B 这个时候A会执行Java代码：</code></pre></div>@Override<br>protected void onSaveInstanceState(Bundle outState) {<br>super.onSaveInstanceState(outState);<br>}<div class="hljs"><pre><code class="hljs angelscript"><span class="hljs-number">14.</span> 面試流程[!http:<span class="hljs-comment">//www.bubuko.com/infodetail-992911.html]   http://www.testtao.com/thread-32127-1-1.html</span><span class="hljs-number">14.</span> java.io包中定义了多个流类型来实现输入和输出功能，可以从不同的角度对其进行分                   类,按功能分为：(节点流和处理流),如果为读取的内容进行处理后再输出，需要使用下列哪种流?    Filter stream   <span class="hljs-number">15.</span> 下列代码的执行结果是：(B)</code></pre></div>public class Test3{<br>public static void main(String args[]){<br>  System.out.print(100%3);<br>  System.out.print(“,”);<br>  System.out.println(100%3.0);<br>  }<br>}<div class="hljs"><pre><code class="hljs angelscript">  A、<span class="hljs-number">1</span>,<span class="hljs-number">1</span> B、<span class="hljs-number">1</span>,<span class="hljs-number">1.0</span> C、<span class="hljs-number">1.0</span>,<span class="hljs-number">1</span> D、<span class="hljs-number">1.0</span>,<span class="hljs-number">1.0</span><span class="hljs-number">16.</span> 在继承中，关于构造方法的说明，下列说法错误的是(D)    A、子类无条件的继承父类的无参构造方法，   　　B、子类可以引用父类中的有参构造方法，使用<span class="hljs-keyword">super</span>关键字，   　　C、如果子类没有构造方法，则父类无参构造方法作为自已的构造方法，   　　D、如果子类有无参构造方法，而父类的无参构造方法则被覆盖。<span class="hljs-number">17.</span> 以下程序的运行结果为(B)</code></pre></div>public class IfTest{</li></ol><p>　　public static void main(String args[]){</p><p>　　int x=3;</p><p>　　int y=1;</p><p>　　if(x==y)</p><p>　　System.out.println(“Not equal”);</p><p>　　else</p><p>　　System.out.println(“Equal”);</p><p>　　}<br>　　}<br>  <div class="hljs"><pre><code class="hljs angelscript">  A、Not equal B、Equal C、无输出 D、编译出错<span class="hljs-number">18.</span> Java语言中字符串“学Java”所占的内存空间是(a)     A. <span class="hljs-number">6</span>个字节 B. <span class="hljs-number">7</span>个字节 C. <span class="hljs-number">10</span>个字节 D. <span class="hljs-number">11</span>个字节<span class="hljs-number">19.</span> 关于下列程序段的输出结果，说法正确的是：( D)</code></pre></div><br>  public class MyClass{</p><p>　　static int i; public static void main(Stringargv[]){ System.out.println(i); } }<br>  <div class="hljs"><pre><code class="hljs angelscript">  A、有错误，变量i没有初始化。 B、<span class="hljs-literal">null</span> C、<span class="hljs-number">1</span> D、<span class="hljs-number">0</span>   <span class="hljs-number">20.</span> 下列哪些语句关于内存回收的说明是正确的? (B )       A、 程序员必须创建一个线程来释放内存　　B、 内存回收程序负责释放无用内存　　C、 内存回收程序允许程序员直接释放内存　　D、 内存回收程序可以在指定的时间释放内存对象<span class="hljs-number">21.</span> 下面异常是属于Runtime Exception 的是(ABCD)(多选)       A、ArithmeticException　　B、IllegalArgumentException　　C、NullPointerException　　D、BufferUnderflowException<span class="hljs-number">22.</span> Math.round(<span class="hljs-number">11.5</span>)等于多少(). Math.round(<span class="hljs-number">-11.5</span>)等于多少(C).     A、<span class="hljs-number">11</span> ,<span class="hljs-number">-11</span> B、<span class="hljs-number">11</span> ,<span class="hljs-number">-12</span> C、<span class="hljs-number">12</span> ,<span class="hljs-number">-11</span> D、<span class="hljs-number">12</span> ,<span class="hljs-number">-12</span><span class="hljs-number">23.</span> 下列程序段的输出结果是：(B )</code></pre></div><br>  void complicatedexpression_r(){ int x=20, y=30; boolean b; b=x&gt;50&amp;&amp;y&gt;60||x&gt;50&amp;&amp;y&lt;-60||x&lt;-50&amp;&amp;y&gt;60||x&lt;-50&amp;&amp;y&lt;-60; System.out.println(b); }<br>  <div class="hljs"><pre><code class="hljs markdown">  A、true B、false C、1 D、0<span class="hljs-bullet">24. </span>activity对一些资源以及状态的操作保存，最好是保存在生命周期的哪个函数中进行(A)  A、onPause() B、onCreate() C、 onResume() D、onStart()<span class="hljs-bullet">25. </span>Intent传递数据时，下列的数据类型哪些可以被传递(ABCD)(多选)  A、Serializable B、charsequence C、Parcelable D、Bundle<span class="hljs-bullet">26. </span>android 中下列属于Intent的作用的是(C)   <span class="hljs-code">    A、实现应用程序间的数据共享</span>　　B、是一段长的生命周期，没有用户界面的程序，可以保持应用在后台运行，而不会因为切换页面而消失　　C、可以实现界面间的切换，可以包含动作和动作数据，连接四大组件的纽带　　D、处理一个应用程序整体性的工作<span class="hljs-bullet">27. </span>下列属于SAX解析xml文件的优点的是(B)   <span class="hljs-code">    A、将整个文档树在内存中，便于操作，支持删除，修改，重新排列等多种功能</span>　　B、不用事先调入整个文档，占用资源少　　C、整个文档调入内存，浪费时间和空间　　D、不是长久驻留在内存，数据不是持久的，事件过后，若没有保存数据，数据就会　　消失<span class="hljs-bullet">28. </span>在android中使用Menu时可能需要重写的方法有(AC)。(多选)<span class="hljs-code">    A、onCreateOptionsMenu(AC)</span>　　B、onCreateMenu()　　C、onOptionsItemSelected()　　D、onItemSelected()<span class="hljs-bullet">29. </span>在android中使用SQLiteOpenHelper这个辅助类时，可以生成一个数据库，并可以对数 据库版本进行管理的方法可以是(AB)   <span class="hljs-code">    A、getWriteableDatabase()</span>　　B、getReadableDatabase()　　C、getDatabase()　　D、getAbleDatabase()   <span class="hljs-bullet">30. </span>android 关于service生命周期的onCreate()和onStart()说法正确的是(AD)(多选题)   <span class="hljs-code">    A、当第一次启动的时候先后调用onCreate()和onStart()方法</span>　　B、当第一次启动的时候只会调用onCreate()方法　　C、如果service已经启动，将先后调用onCreate()和onStart()方法　　D、如果service已经启动，只会执行onStart()方法，不在执行onCreate()方法<span class="hljs-bullet">31. </span>下面是属于GLSurFaceView特性的是(ABC)(多选)   <span class="hljs-code">    A、管理一个surface，这个surface就是一块特殊的内存，能直接排版到android的视图</span>　　view上。　　B、管理一个EGL display，它能让opengl把内容渲染到上述的surface上。　　C、让渲染器在独立的线程里运作，和UI线程分离。　　D、可以直接从内存或者DMA等硬件接口取得图像数据   <span class="hljs-bullet">32. </span>关于ContenValues类说法正确的是(A)   <span class="hljs-code">    A、他和Hashtable比较类似，也是负责存储一些名值对，但是他存储的名值对当中的</span>　　名是String类型，而值都是基本类型　　B、他和Hashtable比较类似，也是负责存储一些名值对，但是他存储的名值对当中的　　名是任意类型，而值都是基本类型　　C、他和Hashtable比较类似，也是负责存储一些名值对，但是他存储的名值对当中的　　名，可以为空，而值都是String类型　　D、他和Hashtable比较类似，也是负责存储一些名值对，但是他存储的名值对当中　　的名是String类型，而值也是String类型<span class="hljs-bullet">33. </span>我们都知道Hanlder是线程与Activity通信的桥梁,如果线程处理不当，你的机器　　就会变得越慢，那么线程销毁的方法是(A)   <span class="hljs-code">    A、onDestroy()</span>　　B、onClear()　　C、onFinish()　　D、onStop()<span class="hljs-bullet">34. </span>下面退出Activity错误的方法是(C)   <span class="hljs-code">    A、finish()</span>　　B、抛异常强制退出　　C、System.exit()　　D、onStop()<span class="hljs-bullet">35. </span>下面属于android的动画分类的有(AB)(多项)  A、Tween B、FrameC、Draw D、Animation<span class="hljs-bullet">36. </span>Android项目工程下面的assets目录的作用是什么   B<span class="hljs-code">    A、放置应用到的图片资源。</span>　　B、主要放置多媒体等数据文件　　C、放置字符串，颜色，数组等常量数据　　D、放置一些与UI相应的布局文件，都是xml文件<span class="hljs-bullet">37. </span>关于res/raw目录说法正确的是   A<span class="hljs-code">    A、 这里的文件是原封不动的存储到设备上不会转换为二进制的格式</span>　　B、 这里的文件是原封不动的存储到设备上会转换为二进制的格式　　C、 这里的文件最终以二进制的格式存储到指定的包中　　D、 这里的文件最终不会以二进制的格式存储到指定的包中<span class="hljs-bullet">38. </span>下列对android NDK的理解正确的是(ABCD )<span class="hljs-code">    A、 NDK是一系列工具的集合</span>　　B、 NDK 提供了一份稳定、功能有限的 API 头文件声明。　　C、 使“Java+C” 的开发方式终于转正，成为官方支持的开发方式　　D、 NDK 将是 Android 平台支持 C 开发的开端<span class="hljs-bullet">39. </span>我们用<span class="hljs-strong">____int__</span><span class="hljs-emphasis">_来定义一个整数，用_</span><span class="hljs-strong">___char__</span>_来定义一个字符类型，称为原始数据类型。   <span class="hljs-bullet">40. </span>android中常用的四个布局是<span class="hljs-strong">_____</span><span class="hljs-strong">_____</span>，<span class="hljs-strong">_____</span><span class="hljs-strong">_____</span>，<span class="hljs-strong">_____</span><span class="hljs-strong">_____</span>和<span class="hljs-strong">_____</span><span class="hljs-strong">_____</span>。   FrameLayout,LilnearLayout,RelativeLayout,TableLayout<span class="hljs-bullet">41. </span>android 的四大组件是<span class="hljs-strong">_____</span><span class="hljs-strong">_____</span>，Activity,Broadcast,Service,ContentProvide<span class="hljs-bullet">42. </span>java.io包中的<span class="hljs-strong">_____</span><span class="hljs-strong">_____</span><span class="hljs-strong">__和__</span><span class="hljs-strong">_____</span><span class="hljs-strong">_____</span>类主要用于对对象(Object)的读写。   ObjectInputStream ObjectOutputSteam<span class="hljs-bullet">43. </span>android 中service的实现方法是：<span class="hljs-strong">_____</span><span class="hljs-strong">_____</span><span class="hljs-strong">___和__</span><span class="hljs-strong">_____</span><span class="hljs-strong">_____</span>_。startService ,bindService44.activity一般会重载7个方法用来维护其生命周期，除了onCreate(),onStart(),onDestory()外还有<span class="hljs-strong">_____</span><span class="hljs-strong">_____</span><span class="hljs-strong">___,__</span><span class="hljs-strong">_____</span><span class="hljs-strong">_____</span><span class="hljs-strong">__,__</span><span class="hljs-strong">_____</span><span class="hljs-strong">_____</span>,<span class="hljs-strong">_____</span><span class="hljs-strong">_____</span>_。   onRestart(),onResume(),onPause(),onStop()<span class="hljs-bullet">45. </span>android的数据存储的方式<span class="hljs-strong">_____</span><span class="hljs-strong">____,__</span><span class="hljs-strong">_____</span><span class="hljs-strong">____,__</span><span class="hljs-strong">_____</span><span class="hljs-strong">___,__</span><span class="hljs-strong">_____</span><span class="hljs-strong">__,__</span><span class="hljs-strong">_____</span>_。SharedPreferences存储，文件存储，SQLite存储，ContentProvider，网络存储<span class="hljs-bullet">46. </span>当启动一个Activity并且新的Activity执行完后需要返回到启动它的Activity来执行的回调函数是<span class="hljs-strong">____startActivityResult()__</span><span class="hljs-strong">_____</span><span class="hljs-strong">_____</span>_。<span class="hljs-bullet">47. </span>请使用命令行的方式创建一个名字为myAvd,sdk版本为2.2,sd卡是在d盘的根目录下，名字为scard.img，并指定屏幕大小HVGA.<span class="hljs-strong">_____</span><span class="hljs-strong">_____</span><span class="hljs-strong">_____</span><span class="hljs-strong">_____</span><span class="hljs-strong">_____</span><span class="hljs-strong">_____</span><span class="hljs-strong">_____</span>_。adnroid create acd -n myAvd -t 8 -s HVDA - Cd:\card.img<span class="hljs-bullet">48. </span>程序运行的结果是：<span class="hljs-strong">_____</span><span class="hljs-strong">__good and gbc__</span><span class="hljs-strong">_____</span>_。</code></pre></div><br>  public classExample{<br>　　Stringstr=new String(“good”);<br>　　char[]ch={‘a’,’b’,’c’};<br>　　publicstatic void main(String args[]){<br>　　Exampleex=new Example();<br>　　ex.change(ex.str,ex.ch);<br>　　System.out.print(ex.str+”and “);<br>　　Sytem.out.print(ex.ch);<br>　　}<br>　　public voidchange(String str,char ch[]){<br>　　str=”testok”;<br>　　ch[0]=’g’;<br>　　}<br>　　}<br>  <div class="hljs"><pre><code class="hljs processing">  <span class="hljs-number">49.</span> 横竖屏切换时候 activity 的生命周期     <span class="hljs-number">1.</span> 不设置 Activity 的 android:configChanges 时 , 切屏会重新调用各个生命周期 , 切横屏时会执行一次 , 切竖屏时会执行两次 .  <span class="hljs-number">2.</span> 设置 Activity 的 android:configChanges=<span class="hljs-string">"orientation"</span> 时 , 切屏还是会重新调用各个生命周期 , 切横、竖屏时只会执行一次 .  <span class="hljs-number">3.</span> 设置 Activity 的 android:configChanges=<span class="hljs-string">"orientation|keyboardHidden"</span> 时 , 切屏不会重新调用各个生命周期 ,            只会执行onConfigurationChanged 方法 .  <span class="hljs-number">50.</span> android 中线程与线程，进程与进程之间如何通信       <span class="hljs-number">1</span> 、一个 Android 程序开始运行时，会单独启动一个 Process 。       默认情况下，所有这个程序中的 Activity 或者 Service 都会跑在这个 Process 。        默认情况下，一个 Android 程序也只有一个 Process ，但一个 Process 下却可以有许多个 Thread 。        <span class="hljs-number">2</span> 、一个 Android 程序开始运行时，就有一个主线程 Main Thread 被创建。该线程主要负责 UI 界面的显示、更新和控件交互，所以又叫 UI Thread 。        一个 Android 程序创建之初，一个 Process 呈现的是单线程模型 -- 即 Main Thread ，所有的任务都在一个线程中运行。所以， Main Thread 所调用的每一个函数，其耗时应该越短越好。而对于比较费时的工作，应该设法交给子线程去做，以避免阻塞主线程（主线程被阻塞，会导致程序假死 现象）。        <span class="hljs-number">3</span> 、 Android 单线程模型： Android UI 操作并不是线程安全的并且这些操作必须在 UI 线程中执行。如果在子线程中直接修改 UI ，会导致异常。     <span class="hljs-number">51.</span> 如何将 SQLite 数据库 (dictionary.db 文件 ) 与 apk 文件一起发布 ?      解答：可以将 dictionary.db 文件复制到 Eclipse Android 工程中的 res aw 目录中。所有在 res aw 目录中的文件不会被压缩，这样可以直接提取该目录中的文件。可以将 dictionary.db 文件复制到 res aw 目录中   <span class="hljs-number">52.</span> 如何将打开 res aw 目录中的数据库文件 ?      解答：在 Android 中不能直接打开 res aw 目录中的数据库文件，而需要在程序第一次启动时将该文件复制到手机内存或 SD 卡的某个目录中，然后再打开该数据库文件。复制的基本方法是使用 getResources().openRawResource 方法获得 res aw 目录中资源的 InputStream 对象，然后将该 InputStream 对象中的数据写入其他的目录中相应文件中。在 Android SDK 中可以使用 SQLiteDatabase.openOrCreateDatabase 方法来打开任意目录中的 SQLite 数据库文件。     <span class="hljs-number">53.</span> Android中五种数据存储方式分别是什么？他们的特点？     (<span class="hljs-number">1</span>)SharedPreference，存放较少的五种类型的数据，只能在同一个包内使         用，生成<span class="hljs-keyword">XML</span>的格式存放在设备中 (<span class="hljs-number">2</span>) SQLite数据库，存放各种数据，是一个轻量级的嵌入式数据库 (<span class="hljs-number">3</span>) File文件，通过读取写入方式生成文件存放数据 (<span class="hljs-number">4</span>) ContentProvider，主要用于让其他应用程序使用保存的数据 (<span class="hljs-number">5</span>) 通过网络获取数据和写入数据到网络存储空间     答：Android提供了五种存取数据的方式     <span class="hljs-number">54.</span> 说说 android 中 mvc 的具体体现     mvc是model,view,controller的缩写，mvc包含三个部分：模型（model）对象：是应用程序的主体部分，所有的业务逻辑都应该写在该层。视图（view）对象：是应用程序中负责生成用户界面的部分。也是在整个mvc架构中用户唯一可以看到的一层，接收用户的输入，显示处理结果。控制器（control）对象：是根据用户的输入，控制用户界面数据显示及更新model对象状态的部分，控制器更重要的一种导航功能，响应用户出发的相关事件，交给m层处理。android鼓励弱耦合和组件的重用，在android中mvc的具体体现如下：   <span class="hljs-number">1</span>)视图（view）：一般采用xml文件进行界面的描述，使用的时候可以非常方便的引入。<span class="hljs-number">2</span>)控制层（controller）：android的控制层的重任通常落在了众多的acitvity的肩上，这句话也就暗含了不要在acitivity中写过多的代码，要通过activity交割model业务逻辑层处理，这样做的另外一个原因是android中的acitivity的响应时间是<span class="hljs-number">5</span>s，如果耗时的操作放在这里，程序就很容易被回收掉。<span class="hljs-number">3</span>)模型层（model）：对数据库的操作、对网络等的操作都应该在model里面处理，当然对业务计算等操作也是必须放在的该层的。   <span class="hljs-number">55.</span> 简述SharedPreferences存储方式以及SharedPreferences与SQLite数据库的区别     SharedPreferences也是一种轻型的数据存储方式，它的本质是基于<span class="hljs-keyword">XML</span>文件存储<span class="hljs-built_in">key</span>-value键值对数据，通常用来存储一些简单的配置信息。其存储位置在/data/data/&lt;包名&gt;/shared_prefs目录下。SharedPreferences对象本身只能读取数据而不支持写入数据，存储修改是通过Editor对象实现。SharedPreferences对象与SQLite数据库相比，免去了创建数据库，创建表，写SQL语句等诸多操作，相对而言更加方便，简洁。但是SharedPreferences也有其自身缺陷，比如其职能存储<span class="hljs-built_in">boolean</span>，<span class="hljs-built_in">int</span>，<span class="hljs-built_in">float</span>，<span class="hljs-keyword">long</span>和<span class="hljs-keyword">String</span>五种简单的数据类型，比如其无法进行条件查询等。所以不论SharedPreferences的数据存储操作是如何简单，它也只能是存储方式的一种补充，而无法完全替代如SQLite数据库这样的其他数据存储方式。  <span class="hljs-number">56.</span> 描述handler 机制的原理     andriod提供了 Handler 和 Looper 来满足线程间的通信。Handler 先进先出原则。Looper类用来管理特定线程内对象之间的消息交换(Message Exchange)。<span class="hljs-number">1</span>)Looper: 一个线程可以产生一个Looper对象，由它来管理此线程里的Message Queue(消息队列)。<span class="hljs-number">2</span>)Handler: 你可以构造Handler对象来与Looper沟通，以便push新消息到Message Queue里;或者接收Looper从Message Queue取出)所送来的消息。<span class="hljs-number">3</span>) Message Queue(消息队列):用来存放线程放入的消息。<span class="hljs-number">4</span>)线程：UI thread 通常就是main thread，而Android启动程序时会替它建立一个Message Queue。<span class="hljs-number">57.</span> 显式intent和隐式intent的区别是什么（android）   答：Intent定义：Intent是一种在不同组件之间传递的请求消息，是应用程序发出的请求和意图。作为一个完整的消息传递机制，Intent不仅需要发送端，还需要接收端。显式Intent定义：对于明确指出了目标组件名称的Intent，我们称之为显式Intent。隐式Intent定义：对于没有明确指出目标组件名称的Intent，则称之为隐式Intent。说明：Android系统使用IntentFilter 来寻找与隐式Intent相关的对象。<span class="hljs-number">58.</span> sqlite升级步骤：   <span class="hljs-number">1.</span>自己写一个类继承自SqliteOpenHelper  <span class="hljs-number">2.</span>会实现SqliteOpenHelper的两个方法 onCreate与onUpgrade，google文档对两个回调方法的解释是创建数据库的时候调用与更新数据库的版本的时候调用  <span class="hljs-number">3.</span>Sqlite数据库主要是用来缓存应用的数据,而应用却是一直在更新版本，相应的数据的表的字段也会一直增加会改变或减少  <span class="hljs-number">4.</span>这个时候就需要控制数据库的版本,因为Sqlite数据库中的字段假设新版的应用里面设计的表是<span class="hljs-number">10</span>个字段，而缓存却是之前缓存的只有<span class="hljs-number">9</span>个字段的话，查询数据库之后的列  然后取的值会出现空指针异常或报错  <span class="hljs-number">5.</span>所以android中引入了Sqlite数据库的版本，让应用的旧版数据库能够与新版的数据库的字段兼容  <span class="hljs-number">6.</span>为了兼容之前的数据库的版本,只需要在应用的版本更新的时候,添加字段或者删除字段即可  <span class="hljs-number">7.</span>你开发程序当前是<span class="hljs-number">1.0</span><span class="hljs-number">.0</span>的版本，该程序用到了数据库，但是版本迭代之后到<span class="hljs-number">1.0</span><span class="hljs-number">.1</span>的时候，数据库的某个表添加了某个字段在软件<span class="hljs-number">1.0</span><span class="hljs-number">.1</span>的版本就需要升级  <span class="hljs-number">8.</span>数据库升级可以为了能够让旧的数据不能丢，所以不能删除掉之前数据库中的所有数据，那么就需要有地方能够检测到版本的变化，这个跟Android的APP升级是一个道理  当然这个检测就是在SqliteOpenHelper的onUpgrade方法中<span class="hljs-number">59.</span> 数据库升级应该注意什么？   软件的<span class="hljs-number">1.0</span>版本升级到<span class="hljs-number">1.1</span>版本时，老的数据不能丢。那么在<span class="hljs-number">1.1</span>版本的程序中就要有地方能够检测出来新的软件版本与老的  数据库不兼容，并且能够有办法把<span class="hljs-number">1.0</span>软件的数据库升级到<span class="hljs-number">1.1</span>软件能够使用的数据库。换句话说，要在<span class="hljs-number">1.0</span>软件的数据库的那个表中增加那个字段，并赋予这个字段默认值。<span class="hljs-number">60.</span> 程序如何知道数据库需要升级？   SQLiteOpenHelper类的构造函数有一个参数是<span class="hljs-built_in">int</span> version，它的意思就是指数据库版本号。比如在软件<span class="hljs-number">1.0</span>版本中，我们使用SQLiteOpenHelper访问数据库时，该参数为<span class="hljs-number">1</span>，那么数据库版本号<span class="hljs-number">1</span>就会写在我们的数据库中。 到了<span class="hljs-number">1.1</span>版本，我们的数据库需要发生变化，那么我们<span class="hljs-number">1.1</span>版本的程序中就要使用一个大于<span class="hljs-number">1</span>的整数来构造SQLiteOpenHelper类，用于访问新的数据库，比如<span class="hljs-number">2</span>。 当我们的<span class="hljs-number">1.1</span>新程序读取<span class="hljs-number">1.0</span>版本的老数据库时，就发现老数据库里存储的数据库版本是<span class="hljs-number">1</span>，而我们新程序访问它时填的版本号为<span class="hljs-number">2</span>，系统就知道数据库需要升级。<span class="hljs-number">61.</span>  android版本适配(如何兼容<span class="hljs-number">4.3</span><span class="hljs-number">-2.3</span>版本)   比如产品设计中想要一些<span class="hljs-number">4.3</span>以上的新特效，但是如何去兼容<span class="hljs-number">4.3</span><span class="hljs-number">-2.3</span>的用户群体呢， 前提是我们apk在友盟数据上显示<span class="hljs-number">4.3</span><span class="hljs-number">-2.3</span>占有<span class="hljs-number">25</span>%的用户群体。 居于这个的考虑，我们目前的做法就是新设计的页面使用新特效的话需要根据手机版本号判断， 如果是低版本的手机并且大部分新特效是无法兼容我们展示老页面. <span class="hljs-number">62.</span> 一个apk如何快速方便的打多个不同包名的产品（多渠道多产品推广）    我们市场在推广apk的时候有时候需要根据渠道打不同包名的apk并且这些打出来的apk风格和内容展示以及文字展现略有不同。   我们现在的做法是，把主工程项目当做libs形式关联到想要打包的工程，这样打不同包名的时候就方便，直接创建一个工程，   把主工程关联，然后可以在新创建的工程里面略修改一些比如title风格，首页面进入风格  （因为首页我们做了好几套可以根据类型来判断你走的是哪一个风格），就是一个新的apk出现了。<span class="hljs-number">63.</span> android 适配   <span class="hljs-number">1</span>、不要使用绝对布局<span class="hljs-number">2</span>、尽量使用match_parent 而不是fill_parent 。<span class="hljs-number">3</span>、能够使用权重的地方尽量使用权重（android:layout_weight）<span class="hljs-number">4</span>、如果是纯色背景，尽量使用android的<span class="hljs-built_in">shape</span> 自定义。<span class="hljs-number">5</span>、如果需要在特定分辨率下适配，可以在res目录上新建layout-HxW.xml的文件夹。比如要适配<span class="hljs-number">1080</span>*<span class="hljs-number">1800</span>的屏幕（魅族MX3采用此分辨率）则新建layout<span class="hljs-number">-1800</span>x1080.xml的文件夹，然后在下面定义布局。Android系统会优先查找分辨率相同的布局，如果不存在则换使用默认的layout下的布局。<span class="hljs-number">64.</span> ArrayList,Vector,LinkedList的区别           ArrayList         Vector          LinkedList   实现原理 数组               数组             双向链表   线程安全 否                  是               否优点     <span class="hljs-number">1.</span>数组实现优于遍历  <span class="hljs-number">1.</span>数组实现优于遍历  <span class="hljs-number">1.</span>节点的增删无需对象的重建        <span class="hljs-number">2.</span>非线程安全，效率较高 <span class="hljs-number">2.</span>线程安全      <span class="hljs-number">2.</span>空间利用毫无浪费缺点     <span class="hljs-number">1.</span>非线程安全        <span class="hljs-number">1.</span>数组中未使用的元素造成空间的浪费   <span class="hljs-number">1.</span>遍历效率较低        <span class="hljs-number">2.</span>数组中未使用元素照成了空间的浪费 <span class="hljs-number">2.</span>扩容可能引起对象的重建  <span class="hljs-number">2.</span>非线程安全        <span class="hljs-number">3.</span>扩容可能引起对象的重建 <span class="hljs-number">3.</span>线程安全，效率相对低        <span class="hljs-number">4.</span>增删有可能引起数组元素的移动 <span class="hljs-number">4.</span>增删有可能引起数组元素的移动扩容     <span class="hljs-number">0.5</span>倍增量         <span class="hljs-number">1</span>倍增量            按需增删使用场景  <span class="hljs-number">1.</span>无线程的要求    <span class="hljs-number">1.</span>有线程安全的要求    增删场景较多的时候          <span class="hljs-number">2.</span>遍历较多，增删较少 <span class="hljs-number">2.</span>遍历场景较多，增删场景较少   <span class="hljs-number">65.</span> <span class="hljs-built_in">int</span>与Integer的区别         <span class="hljs-built_in">int</span>                               Integer类型    基本类型                          复合类型默认值     <span class="hljs-number">0</span>                                 <span class="hljs-keyword">null</span>存储      栈（局部变量）堆（成员变量，有待进一步确认）    堆上（只能通过<span class="hljs-keyword">new</span>创建）方法      基本类型无方法                   有速度      快（栈上 的操作相对快）            慢泛型支持    否（java中的泛型不支持，C++中的模板支持）    支持容器类支持   否（直接使用通常会进行装箱操作）      支持存在意义      <span class="hljs-number">1.</span>历史原因（顺延C/C++中存在）<span class="hljs-number">2.</span>方便快速（无需<span class="hljs-keyword">new</span>）   基本类型<span class="hljs-built_in">int</span>的包装类,提供了对泛型，容器类的支持   <span class="hljs-number">66.</span> RuntimeException与普通异常，error的区别。     Checked Exception：在编译时就能够被Java编译器所检测到的。     UncheckedException：则是编译时，java编译器不能检查到。             RuntimeException        普通Exception           Error受控异常        否                     是                     否产生原因        开发者的编程错误          由于外界环境所限，本身潜在的一些问题      Java运行时的系统错误，资源耗尽，是一种严重的，程序无法修复的问题  例子        NullPointerException      ClassNotFoundException        VirtualMachineError          ArrayOutOfIndexException    IOException                   StackOverflowError          ClassCastException          FileNotFoundException         OutOfMemoryError          ArithmeticException          UnsupportedOperationException<span class="hljs-number">67.</span> <span class="hljs-keyword">final</span>,finalize,<span class="hljs-keyword">finally</span>的区别        <span class="hljs-keyword">final</span>:关键字，表不变 方法：方法不可Override  类：不可被继承  基本类型量：常量，值不可变  符合类型量：引用不可变，即引用的值不可变       <span class="hljs-keyword">finally</span>:关键字，Java异常处理机制的一部分，在异常发生时，用来提供一个必要的清理的机会。       finalize：<span class="hljs-keyword">Object</span>类的方法 意义：Java技术允许使用finalize()方法在垃圾回收器将对象回收之前，做一些必要的清理操作。    调用前提：这个对象确定没有被引用到。    工作原理：        垃圾收集器准备好释放对象占用的空间。        首先调用其finalize方法。        下一次垃圾收集过程中，真正回收内存。    不确定性：        finalize的执行时间是不缺定的。        一个对象引用另一个对象，并不能保证finalize的方法按照特定的执行顺序。<span class="hljs-number">68.</span> Override,Overload                   Override            Overload    签名+返回值      相同              方法名相同，签名不同    关系            父子类继承关系       通常是同一类层次中    识别            运行时多态           编译时多态                    根据具体的对象       由对象的外观类型（即声明类型）决定                    查询对象的虚方法表，确定调用关系    修饰符限制         非<span class="hljs-keyword">private</span>        无特别                      非<span class="hljs-keyword">static</span>                       非<span class="hljs-keyword">final</span>   异常关系            子类方法不能抛出被父类方法更多的异常   无特别   可见性关系        子类不能比父类访问权限更窄（里氏替换原则决定）     无特别<span class="hljs-number">59.</span> Collection Collections     Collection:接口，集合类的接口，一个契约，提供了集合基本的大小，添加，清除，遍历方法等。  Collections:工具类，提供了很多静态方法，给集合提供一些查询，比较，排序，交换，线程安全化等方法。<span class="hljs-number">60.</span> sleep方法和wait方法的区别                       wait                        sleep  所属类               <span class="hljs-keyword">Object</span>                    Thread  意义                让线程挂起                   让线程休眠指定的时间  释放锁               是                         否（这个跟锁本来就没有关系）  恢复            <span class="hljs-number">1.</span>有参：wait指定时间<span class="hljs-number">2.</span>无参：等待其他线程notify   <span class="hljs-number">1.</span>根据参数长度自动恢复。<span class="hljs-number">2.</span>异常打断  使用限制         wait，notify必须持有当前对象锁的情况下调用   无特别  抛出异常            否                           是  静态方法           否                           是<span class="hljs-number">61.</span> <span class="hljs-keyword">HashMap</span>和Hashtable的区别。        <span class="hljs-keyword">HashMap</span>是Hashtable的轻量级实现（非线程安全的实现），他们都完成了Map接口，主要区别在于<span class="hljs-keyword">HashMap</span>允许空（<span class="hljs-keyword">null</span>）键值（<span class="hljs-built_in">key</span>）,由于非线程安全，效率上可能高于Hashtable。       <span class="hljs-keyword">HashMap</span>允许将<span class="hljs-keyword">null</span>作为一个entry的<span class="hljs-built_in">key</span>或者value，而Hashtable不允许。       <span class="hljs-keyword">HashMap</span>把Hashtable的contains方法去掉了，改成containsvalue和containsKey。因为contains方法容易让人引起误解。<span class="hljs-number">62.</span> 算法 <span class="hljs-number">1.</span>冒泡 <span class="hljs-number">2.</span>选择 <span class="hljs-number">3.</span>插入 <span class="hljs-number">4.</span>并归 <span class="hljs-number">5.</span>快速<span class="hljs-number">63.</span> 深入探索Java工作原理：JVM内存回收及其他       <span class="hljs-number">1</span>．Java虚拟机：       Java源程序通过编译器编译成.Class文件,然后java虚拟机中的java 解释器负责将字节码文件解释成为特定的机器码进行运行。      java是一种半编译半解释型语言。半编译是指：java源代码，会经过javac命令变成 .class文件。半解释是指： .class文件被jvm解释的过程。也就是因为jvm的半解释才有了java的动态语言特性：反射和annotation。    <span class="hljs-number">2.</span>和android区别       alvik有自己的libdex库负责对.class进行处理。libdex主要对.class进行处理生成自己的dex文件。主要做的工作是，对虚拟机指令进行转换(dalvik是基于寄存器的，sun虚拟机是基于栈的)，对类的静态数据进行归类、压缩。dalvik基于寄存器，而JVM基于stack，Dalvik执行的是特有的DEX文件格式，而JVM运行的是*.class文件格式。    <span class="hljs-number">3.</span>优势       <span class="hljs-number">1</span>、在编译时提前优化代码而不是等到运行时    <span class="hljs-number">2</span>、 虚拟机很小，使用的空间也小；被设计来满足可高效运行多种虚拟机实例。    Java虚拟机的建立需要针对不同的软硬件平台来实现，既要考虑处理器的型号，也要考虑操作系统的种类。由此在SPARC结构、X86结构、MIPS和PPC等嵌入式处理芯片上，在UNIX、Linux、Windows和部分实时操作系统上都可实现Java虚拟机。    <span class="hljs-number">4.</span>无用内存自动回收机制    而在Java运行环境中，始终存在着一个系统级的线程，专门跟踪内存的使用情况， 定期检测出不再使用的内存，并自动进行回收，避免了内存的泄露，也减轻了程序员的工作量。    <span class="hljs-number">5.</span>JVM    JVM是Java平台的核心，为了让编译产生的字节码能更好地解释与执行，因此把JVM分成了<span class="hljs-number">6</span>个部分：JVM解释器、指令系统、寄存器、栈、存储区和碎片回收区。<span class="hljs-number">64.</span> Android框架  http:<span class="hljs-comment">//www.cnblogs.com/forlina/archive/2011/06/29/2093332.html</span><span class="hljs-number">65.</span> 基于android的Socket通信    一、Socket通信简介    Android 与服务器的通信方式主要有两种，一是Http通信，一是Socket通信。两者的最大差异在于，http连接使用的是“请求—响应方式”，即在请求时建立 连接通道，当客户端向服务器发送请求后，服务器端才能向客户端返回数据。而Socket通信则是在双方建立起连接后就可以直接进行数据的传输，在连接时可 实现信息的主动推送，而不需要每次由客户端想服务器发送请求。 那么，什么是socket？Socket又称套接字，在程序内部提供了与外界通信的端口，即端口通信。通过建立socket连接，可为通信双方的数据传输 传提供通道。socket的主要特点有数据丢失率低，使用简单且易于移植。    <span class="hljs-number">1.2</span>Socket的分类     根据不同的的底层协议，Socket的实现是多样化的。本指南中只介绍TCP/IP协议族的内容，在这个协议族当中主要的Socket类型为流套接字 （streamsocket）和数据报套接字(datagramsocket)。流套接字将TCP作为其端对端协议，提供了一个可信赖的字节流服务。数据 报套接字使用UDP协议，提供数据打包发送服务。    二、Socket 基本通信模型 【http:<span class="hljs-comment">//www.itlanbao.com/ns/news.aspx?s=600031】</span>    三、Socket基本实现原理    <span class="hljs-number">3.1</span>基于TCP协议的Socket      服务器端首先声明一个ServerSocket对象并且指定端口号，然后调 用Serversocket的accept（）方法接收客户端的数据。accept（）方法在没有数据进行接收的处于堵塞状态。 （Socketsocket=serversocket.accept()）,一旦接收到数据，通过inputstream读取接收的数据。        客户端创建一个Socket对象，指定服务器端的ip地址和端口号 （Socketsocket=newSocket(<span class="hljs-string">"172.168.10.108"</span>,<span class="hljs-number">8080</span>);）,通过inputstream读取数据，获取服务器 发出的数据（OutputStreamoutputstream=socket.getOutputStream()），最后将要发送的数据写入到 outputstream即可进行TCP协议的socket数据传输。    <span class="hljs-number">3.2</span>基于UDP协议的数据传输    服务器端首先创建一个DatagramSocket对象，并且指点监听的端 口。接下来创建一个空的DatagramSocket对象用于接收数据 （bytedata[]=newbyte[<span class="hljs-number">1024</span>;]DatagramSocketpacket=newDatagramSocket（data，data.length））,    使用DatagramSocket的receive方法接收客户端发送的数据，receive（）与serversocket的accepet（）类似， 在没有数据进行接收的处于堵塞状态。    客户端也创建个DatagramSocket对象，并且指点监听的端口。接 下来创建一个InetAddress对象，这个对象类似与一个网络的发送地址    （InetAddressserveraddress=InetAddress.getByName（<span class="hljs-string">"172.168.1.120"</span>））    .定义要发送的 一个字符串，创建一个DatagramPacket对象，并制定要讲这个数据报包发送到网络的那个地址以及端口号，    最后使用DatagramSocket 的对象的send（）发送数据。    *（Stringstr=<span class="hljs-string">"hello"</span>;bytedata[]=<span class="hljs-built_in">str</span>.getByte(); DatagramPacketpacket=<span class="hljs-keyword">new</span> DatagramPacket(data,data.length,serveraddress,<span class="hljs-number">4567</span>);socket.send(packet);）    四、android 实现socket简单通信    <span class="hljs-number">4.1</span>使用TCP协议通信      android端实现：        <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> connectServerWithTCPSocket() &#123;              Socket socket;              <span class="hljs-keyword">try</span> &#123;<span class="hljs-comment">// 创建一个Socket对象，并指定服务端的IP及端口号  </span>                socket = <span class="hljs-keyword">new</span> Socket(<span class="hljs-string">"192.168.1.32"</span>, <span class="hljs-number">1989</span>);                  <span class="hljs-comment">// 创建一个InputStream用户读取要发送的文件。  </span>                InputStream inputStream = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">"e://a.txt"</span>);                  <span class="hljs-comment">// 获取Socket的OutputStream对象用于发送数据。  </span>                OutputStream outputStream = socket.getOutputStream();                  <span class="hljs-comment">// 创建一个byte类型的buffer字节数组，用于存放读取的本地文件  </span>                <span class="hljs-built_in">byte</span> buffer[] = <span class="hljs-keyword">new</span> <span class="hljs-built_in">byte</span>[<span class="hljs-number">4</span> * <span class="hljs-number">1024</span>];                  <span class="hljs-built_in">int</span> temp = <span class="hljs-number">0</span>;                  <span class="hljs-comment">// 循环读取文件  </span>                <span class="hljs-keyword">while</span> ((temp = inputStream.read(buffer)) != <span class="hljs-number">-1</span>) &#123;                      <span class="hljs-comment">// 把数据写入到OuputStream对象中  </span>                    outputStream.write(buffer, <span class="hljs-number">0</span>, temp);                  &#125;                  <span class="hljs-comment">// 发送读取的数据到服务端  </span>                outputStream.flush();                  <span class="hljs-comment">/** 或创建一个报文，使用BufferedWriter写入,看你的需求 **/</span>      <span class="hljs-comment">//          String socketData = "[2143213;21343fjks;213]";  </span>    <span class="hljs-comment">//          BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(  </span>    <span class="hljs-comment">//                  socket.getOutputStream()));  </span>    <span class="hljs-comment">//          writer.write(socketData.replace("\n", " ") + "\n");  </span>    <span class="hljs-comment">//          writer.flush();  </span>                <span class="hljs-comment">/************************************************/</span>              &#125; <span class="hljs-keyword">catch</span> (UnknownHostException e) &#123;                  e.printStackTrace();              &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;                  e.printStackTrace();              &#125;          &#125;      服务器端简单实现：    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> ServerReceviedByTcp() &#123;          <span class="hljs-comment">// 声明一个ServerSocket对象  </span>        ServerSocket serverSocket = <span class="hljs-keyword">null</span>;          <span class="hljs-keyword">try</span> &#123;              <span class="hljs-comment">// 创建一个ServerSocket对象，并让这个Socket在1989端口监听  </span>            serverSocket = <span class="hljs-keyword">new</span> ServerSocket(<span class="hljs-number">1989</span>);              <span class="hljs-comment">// 调用ServerSocket的accept()方法，接受客户端所发送的请求，  </span>            <span class="hljs-comment">// 如果客户端没有发送数据，那么该线程就停滞不继续  </span>            Socket socket = serverSocket.accept();              <span class="hljs-comment">// 从Socket当中得到InputStream对象  </span>            InputStream inputStream = socket.getInputStream();              <span class="hljs-built_in">byte</span> buffer[] = <span class="hljs-keyword">new</span> <span class="hljs-built_in">byte</span>[<span class="hljs-number">1024</span> * <span class="hljs-number">4</span>];              <span class="hljs-built_in">int</span> temp = <span class="hljs-number">0</span>;              <span class="hljs-comment">// 从InputStream当中读取客户端所发送的数据  </span>            <span class="hljs-keyword">while</span> ((temp = inputStream.read(buffer)) != <span class="hljs-number">-1</span>) &#123;                  System.out.<span class="hljs-built_in">println</span>(<span class="hljs-keyword">new</span> <span class="hljs-keyword">String</span>(buffer, <span class="hljs-number">0</span>, temp));              &#125;              serverSocket.close();          &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;              e.printStackTrace();          &#125;      &#125;      <span class="hljs-number">4.2</span>使用UDP协议通信      客户端发送数据实现：      <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> connectServerWithUDPSocket() &#123;          DatagramSocket socket;          <span class="hljs-keyword">try</span> &#123;              <span class="hljs-comment">//创建DatagramSocket对象并指定一个端口号，注意，如果客户端需要接收服务器的返回数据,  </span>            <span class="hljs-comment">//还需要使用这个端口号来receive，所以一定要记住  </span>            socket = <span class="hljs-keyword">new</span> DatagramSocket(<span class="hljs-number">1985</span>);              <span class="hljs-comment">//使用InetAddress(Inet4Address).getByName把IP地址转换为网络地址    </span>            InetAddress serverAddress = InetAddress.getByName(<span class="hljs-string">"192.168.1.32"</span>);              <span class="hljs-comment">//Inet4Address serverAddress = (Inet4Address) Inet4Address.getByName("192.168.1.32");    </span>            <span class="hljs-keyword">String</span> <span class="hljs-built_in">str</span> = <span class="hljs-string">"[2143213;21343fjks;213]"</span>;<span class="hljs-comment">//设置要发送的报文    </span>            <span class="hljs-built_in">byte</span> data[] = <span class="hljs-built_in">str</span>.getBytes();<span class="hljs-comment">//把字符串str字符串转换为字节数组    </span>            <span class="hljs-comment">//创建一个DatagramPacket对象，用于发送数据。    </span>            <span class="hljs-comment">//参数一：要发送的数据  参数二：数据的长度  参数三：服务端的网络地址  参数四：服务器端端口号   </span>            DatagramPacket packet = <span class="hljs-keyword">new</span> DatagramPacket(data, data.length ,serverAddress ,<span class="hljs-number">10025</span>);                socket.send(packet);<span class="hljs-comment">//把数据发送到服务端。    </span>        &#125; <span class="hljs-keyword">catch</span> (SocketException e) &#123;              e.printStackTrace();          &#125; <span class="hljs-keyword">catch</span> (UnknownHostException e) &#123;              e.printStackTrace();          &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;              e.printStackTrace();          &#125;        &#125;      客户端接收服务器返回的数据：    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> ReceiveServerSocketData() &#123;          DatagramSocket socket;          <span class="hljs-keyword">try</span> &#123;              <span class="hljs-comment">//实例化的端口号要和发送时的socket一致，否则收不到data  </span>            socket = <span class="hljs-keyword">new</span> DatagramSocket(<span class="hljs-number">1985</span>);              <span class="hljs-built_in">byte</span> data[] = <span class="hljs-keyword">new</span> <span class="hljs-built_in">byte</span>[<span class="hljs-number">4</span> * <span class="hljs-number">1024</span>];              <span class="hljs-comment">//参数一:要接受的data 参数二：data的长度  </span>            DatagramPacket packet = <span class="hljs-keyword">new</span> DatagramPacket(data, data.length);              socket.receive(packet);              <span class="hljs-comment">//把接收到的data转换为String字符串  </span>            <span class="hljs-keyword">String</span> result = <span class="hljs-keyword">new</span> <span class="hljs-keyword">String</span>(packet.getData(), packet.getOffset(),                      packet.getLength());              socket.close();<span class="hljs-comment">//不使用了记得要关闭  </span>            System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">"the number of reveived Socket is  :"</span> + flag                      + <span class="hljs-string">"udpData:"</span> + result);          &#125; <span class="hljs-keyword">catch</span> (SocketException e) &#123;              e.printStackTrace();          &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;              e.printStackTrace();          &#125;      &#125;      服务器接收客户端实现：    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> ServerReceviedByUdp()&#123;          <span class="hljs-comment">//创建一个DatagramSocket对象，并指定监听端口。（UDP使用DatagramSocket）    </span>        DatagramSocket socket;          <span class="hljs-keyword">try</span> &#123;              socket = <span class="hljs-keyword">new</span> DatagramSocket(<span class="hljs-number">10025</span>);              <span class="hljs-comment">//创建一个byte类型的数组，用于存放接收到得数据    </span>            <span class="hljs-built_in">byte</span> data[] = <span class="hljs-keyword">new</span> <span class="hljs-built_in">byte</span>[<span class="hljs-number">4</span>*<span class="hljs-number">1024</span>];                <span class="hljs-comment">//创建一个DatagramPacket对象，并指定DatagramPacket对象的大小    </span>            DatagramPacket packet = <span class="hljs-keyword">new</span> DatagramPacket(data,data.length);                <span class="hljs-comment">//读取接收到得数据    </span>            socket.receive(packet);                <span class="hljs-comment">//把客户端发送的数据转换为字符串。    </span>            <span class="hljs-comment">//使用三个参数的String方法。参数一：数据包 参数二：起始位置 参数三：数据包长    </span>            <span class="hljs-keyword">String</span> result = <span class="hljs-keyword">new</span> <span class="hljs-keyword">String</span>(packet.getData(),packet.getOffset() ,packet.getLength());            &#125; <span class="hljs-keyword">catch</span> (SocketException e) &#123;              e.printStackTrace();          &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;              e.printStackTrace();          &#125;        &#125;      五、总结：    使用UDP方式android端和服务器端接收可以看出，其实android端和服务器端的发送和接收大庭相径，只要端口号正确了，相互通信就没有问题，TCP使用的是流的方式发送，UDP是以包的形式发送。    Android操作HTTP实现与服务器通信 【http:<span class="hljs-comment">//www.cnblogs.com/hanyonglu/archive/2012/02/19/2357842.html】</span># Android四大组件  http:<span class="hljs-comment">//www.cnblogs.com/pepcod/archive/2013/02/11/2937403.html</span># 三级缓存  http:<span class="hljs-comment">//blog.saymagic.cn/2015/01/30/android-pic-three-cache.html</span># 图片的处理和优化  http:<span class="hljs-comment">//www.cnblogs.com/elliotta/p/3633752.html</span>  http:<span class="hljs-comment">//blog.csdn.net/yudajun/article/details/9323941</span># Android5<span class="hljs-number">.0</span>新特性  技术方面说明  http:<span class="hljs-comment">//blog.csdn.net/lwyygydx/article/details/41870377</span>  功能改进方面说明  http:<span class="hljs-comment">//digi.tech.qq.com/a/20150121/012030.htm</span># 图文混排  http:<span class="hljs-comment">//blog.csdn.net/fancylovejava/article/details/39927539</span># 第三方框架:xUtils,Gson  极光推送 第三方登录  友盟第三方登录  http:<span class="hljs-comment">//blog.umeng.com/uncategorized/4160.html</span>  第三方登录案例  http:<span class="hljs-comment">//blog.csdn.net/yueqinglkong/article/details/15028041</span># 线程池  http:<span class="hljs-comment">//blog.csdn.net/lyf_007217/article/details/8542238</span>  http:<span class="hljs-comment">//www.cnblogs.com/devinzhang/p/3856200.html</span># lru算法底层  http:<span class="hljs-comment">//www.360doc.com/content/14/0402/09/10504424_365635496.shtml</span>  http:<span class="hljs-comment">//blog.csdn.net/androidzhaoxiaogang/article/details/7910364</span># ListView的局部刷新  http:<span class="hljs-comment">//www.2cto.com/kf/201409/335964.html</span>  http:<span class="hljs-comment">//blog.csdn.net/u200814499/article/details/40391443</span># 及时通讯  http:<span class="hljs-comment">//blog.csdn.net/jiangliloveyou/article/details/9849775</span>  http:<span class="hljs-comment">//blog.csdn.net/lnb333666/article/details/7471292</span>  http:<span class="hljs-comment">//skywen.iteye.com/blog/1811310</span># GC原理  http:<span class="hljs-comment">//blog.csdn.net/wuqiong_524itcast/article/details/25378685</span>  http:<span class="hljs-comment">//blog.csdn.net/wangshione/article/details/8490245</span>  http:<span class="hljs-comment">//blog.csdn.net/lnb333666/article/details/8031770</span>  <span class="hljs-number">1.</span>垃圾收集算法的核心思想  Java语言建立了垃圾收集机制，用以跟踪正在使用的对象和发现并回收不再使用(引用)的对象。该机制可以有效防范动态内存分配中因内存垃圾过多而引发的内存耗尽，以及不恰当的内存释放所造成的内存非法引用。  　垃圾收集算法的核心思想是：对虚拟机可用内存空间，即堆空间中的对象进行识别，如果对象正在被引用，那么称其为存活对象，反之，如果对象不再被引用，则 为垃圾对象，可以回收其占据的空间，用于再分配。垃圾收集算法的选择和垃圾收集系统参数的合理调节直接影响着系统性能，因此需要开发人员做比较深入的了解。      触发主GC(Garbage Collector)的条件　JVM进行次GC的频率很高,但因为这种GC占用时间极短,所以对系统产生的影响不大。更值得关注的是主GC的触发条件,因为它对系统影响很明显。总的来说,有两个条件会触发主GC:  　　①当应用程序空闲时,即没有应用线程在运行时,GC会被调用。因为GC在优先级最低的线程中进行,所以当应用忙时,GC线程就不会被调用,但以下条件除外。  　　②Java堆内存不足时,GC会被调用。当应用线程在运行,并在运行过程中创建新对象,若这时内存空间不足,JVM就会强制地调用GC线程,以 便回收内存用于新的分配。若GC一次之后仍不能满足内存分配的要求,JVM会再进行两次GC作进一步的尝试,若仍无法满足要求,则 JVM将报“out of memory”的错误,Java应用将停止。  <span class="hljs-number">3.</span>减少GC开销的措施  根据上述GC的机制,程序的运行会直接影响系统环境的变化,从而影响GC的触发。若不针对GC的特点进行设计和编码,就会出现内存驻留等一系列负面影响。为了避免这些影响,基本的原则就是尽可能地减少垃圾和减少GC过程中的开销。具体措施包括以下几个方面:  　　(<span class="hljs-number">1</span>)不要显式调用System.gc()  　　此函数建议JVM进行主GC,虽然只是建议而非一定,但很多情况下它会触发主GC,从而增加主GC的频率,也即增加了间歇性停顿的次数。  　　(<span class="hljs-number">2</span>)尽量减少临时对象的使用  　　临时对象在跳出函数调用后,会成为垃圾,少用临时变量就相当于减少了垃圾的产生,从而延长了出现上述第二个触发条件出现的时间,减少了主GC的机会。  　　(<span class="hljs-number">3</span>)对象不用时最好显式置为Null  　　一般而言,为Null的对象都会被作为垃圾处理,所以将不用的对象显式地设为Null,有利于GC收集器判定垃圾,从而提高了GC的效率。  　　(<span class="hljs-number">4</span>)尽量使用StringBuffer,而不用<span class="hljs-keyword">String</span>来累加字符串(详见blog另一篇文章JAVA中<span class="hljs-keyword">String</span>与StringBuffer)  　　由于<span class="hljs-keyword">String</span>是固定长的字符串对象,累加<span class="hljs-keyword">String</span>对象时,并非在一个<span class="hljs-keyword">String</span>对象中扩增,而是重新创建新的<span class="hljs-keyword">String</span>对象,如 Str5=Str1+Str2+Str3+Str4,这条语句执行过程中会产生多个垃圾对象,因为对次作“+”操作时都必须创建新的<span class="hljs-keyword">String</span>对象,但 这些过渡对象对系统来说是没有实际意义的,只会增加更多的垃圾。避免这种情况可以改用StringBuffer来累加字符串,因StringBuffer 是可变长的,它在原有基础上进行扩增,不会产生中间对象。  　　(<span class="hljs-number">5</span>)能用基本类型如Int,Long,就不用Integer,Long对象  　　基本类型变量占用的内存资源比相应对象占用的少得多,如果没有必要,最好使用基本变量。  　　(<span class="hljs-number">6</span>)尽量少用静态对象变量  　　静态变量属于全局变量,不会被GC回收,它们会一直占用内存。  　　(<span class="hljs-number">7</span>)分散对象创建或删除的时间  　　集中在短时间内大量创建新对象,特别是大对象,会导致突然需要大量内存,JVM在面临这种情况时,只能进行主GC,以回收内存或整合内存碎片, 从而增加主GC的频率。集中删除对象,道理也是一样的。它使得突然出现了大量的垃圾对象,空闲空间必然减少,从而大大增加了下一次创建新对象时强制主GC 的机会。     gc()函数的作用只是提醒虚拟机：程序员希望进行一次垃圾回收。但是它不能保证垃圾回收一定会进行，而且具体什么时候进行是取决于具体的虚拟机的，不同的虚拟机有不同的对策。在Davilk中，给程序分配的内存是根据机型厂商的不同而不同(现在大部分为<span class="hljs-number">32</span>MB),在VM内部会将内存分为：java使用的内存，Native使用的内存，他们之间不能共享，当某一方面不足的时候必须向VM申请，而不能直接使用另外一个的内存。  # 出现内存泄漏的可能性：  出现情况:  <span class="hljs-number">1.</span> 数据库的<span class="hljs-built_in">cursor</span>没有关闭  <span class="hljs-number">2.</span>构造adapter时,没有使用缓存contentview    衍生listview的优化问题-----减少创建view的对象,充分使用contentview,可以使用一静态类来优化处理getview的过程  <span class="hljs-number">3.</span>Bitmap对象不使用时采用recycle()释放内存  <span class="hljs-number">4.</span>activity中的对象的生命周期大于activity  调试方法: DDMS==&gt; HEAPSZIE==&gt;dataobject==&gt;[Total Size]# Android 内存浅析【管理、机制、分析】  一、 Android的内存机制    Android的程序由Java语言编写，所以Android的内存管理与Java的内存管理相似。程序员通过<span class="hljs-keyword">new</span>为对象分配内存，所有对象在java 堆内分配空间；然而对象的释放是由垃圾回收器来完成的。C／C++中的内存机制是“谁污染，谁治理”，java的就比较人性化了，给我们请了一个专门的清 洁工（GC）  二、GC是什么? 为什么要有GC? 　　      GC是垃圾收集的意思（Gabage Collection）,内存处理是编程人员容易出现问题的地方，忘记或者错误的内存回收会导致程序或系统的不稳定甚至崩溃，Java提供的GC功能可以 自动监测对象是否超过作用域从而达到自动回收内存的目的，Java语言没有提供释放已分配内存的显示操作方法。  三、垃圾回收器的基本原理是什么？垃圾回收器可以马上回收内存吗？有什么办法主动通知虚拟机进行垃圾回收？      对于GC来说，当程序员创建对象时，GC就开始监控这个对象的地址、大小以及使用情况。通常，GC采用有向图的方式记录和管理堆(heap)中的所有对 象。通过这种方式确定哪些对象是<span class="hljs-string">"可达的"</span>，哪些对象是<span class="hljs-string">"不可达的"</span>。当GC确定一些对象为<span class="hljs-string">"不可达"</span>时，GC就有责任回收这些内存空间。可以。程序员可 以手动执行System.gc()，通知GC运行，但是Java语言规范并不保证GC一定会执行。间而忘记了释放。如果程序中存在对无用对象的引用，那么这些对象就会驻留内存，消耗内存，因为无法让垃圾回收器GC验证这些对象是否不再需要。如果存在对象的引用，这个对象就被定义为<span class="hljs-string">"有效的活动"</span>，同时不会被释放。要确定对象所占内存将被回收，我们就要务必确认该对象不再会被使用。典型的做法就是把对象数据成员设为<span class="hljs-keyword">null</span>或者从集合中移除该对象。但当局部变量不需要时，不需明显的设为<span class="hljs-keyword">null</span>，因为一个方法执行完毕时，这些引用会自动被清理。    Vector v = <span class="hljs-keyword">new</span> Vector(<span class="hljs-number">10</span>);              <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;                  <span class="hljs-keyword">Object</span> o = <span class="hljs-keyword">new</span> <span class="hljs-keyword">Object</span>();                  v.<span class="hljs-built_in">add</span>(o);                  o = <span class="hljs-keyword">null</span>;              &#125;<span class="hljs-comment">// 此时，所有的Object对象都没有被释放，因为变量v引用这些对象。  </span>    Java 内存泄露的根本原因就是 保存了不可能再被访问的变量类型的引用  六、Android的内存溢出  Android的内存溢出是如何发生的?  Android的虚拟机是基于寄存器的Dalvik，它的最大堆大小一般是<span class="hljs-number">16</span>M，有的机器为<span class="hljs-number">24</span>M。也就是说我们所能利用的内存空间是有限的。如果我们的内存占用超过了一定的水平就会出现OutOfMemory的错误。  为什么会出现内存不够用的情况呢？我想原因主要有两个：  由于我们程序的失误，长期保持某些资源（如Context）的引用，造成内存泄露，资源造成得不到释放。保存了多个耗用内存过大的对象（如Bitmap），造成内存超出限制。# 在Android适配方案小结    <span class="hljs-number">600</span>dp的含义是：代表这个设备的最短的那一边。    获取设备的最短边的代码是：Configuration config = getResources().getConfiguration();    <span class="hljs-built_in">int</span> smallestScreenWidth = config.smallestScreenWidthDp;    这个时候拿smallestScreenWidth 与<span class="hljs-number">600</span>想比较就可以知道该设备能否读取里面的资源了。    除此之外，为了方便适配，在编码时我们还应该注意什么呢，主要有以下几点：    除此之外，为了方便适配，在编码时我们还应该注意什么呢，主要有以下几点：    （<span class="hljs-number">1</span>）多使用权重(android:layout_weight)    尤其是在tab切换布局，listview title及Item布局等情况下；    （<span class="hljs-number">2</span>）设置宽度和高度时，尽量使用match_parent和wrap_content，避免把控件宽高设死；    （<span class="hljs-number">3</span>）父容器布局选用    多使用RelativeLayout，FrameLayout，GridLayout等，减少布局层次。当然，在使用    权重时，得采用LinearLayout；    (<span class="hljs-number">4</span>) 在xml里，设置高度、宽度采用dp(dip)，设置字体采用sp。    （应该注意，在代码里面，我们写的setHeight(...)单位是px）    那么在具体开发中，我们应该注意什么呢。    首先，我们必须要知道，其实适配的关键在于两点：    （<span class="hljs-number">1</span>）不同分辨率设备的适配，这点在单位的使用上用dp、sp以及图片资源存放于不同的drawable文件夹就可以解决问题；    （<span class="hljs-number">2</span>）不同尺寸的适配，这点主要靠将相关值以及布局文件放置于不同的文件夹中来解决。    <span class="hljs-number">2.1</span> values文件夹    可以在工程下创建不同的values文件夹：values-sw480dp， values-sw600dp，    values-sw720dp-land等。比如一个控件的宽度，在<span class="hljs-number">10</span>寸pad上是<span class="hljs-number">10</span>dp，在<span class="hljs-number">8</span>寸pad    上是<span class="hljs-number">5</span>dp。这时，你可以定义一个变量，button_width，然后在values-sw600dp    下写<span class="hljs-number">5</span>dp，在values-sw720-land下写    <span class="hljs-number">10</span>dp。这样就达到了在不同尺寸pad上，    相应控件大小不一样的效果。    <span class="hljs-number">2.1</span> layout文件夹    如果在不同尺寸设备上展示的布局有明显差别，仅仅用values不同已经难以控制，    那么就可以考虑写不同的布局文件置于不同的layout文件夹下，android会根据设备    尺寸去加载相应文件夹下的布局文件。如:layout-sw480dp，layout-sw600dp，    layout-sw700dp等。    值得注意的是，如果不是很有必要，尽量采用<span class="hljs-number">2.1</span>方案，方便维护。如果尺寸和分辨率都不同，    那么就要结合（<span class="hljs-number">1</span>）、（<span class="hljs-number">2</span>）考虑了。    （补充：其实values文件夹和layout文件夹不仅仅是根据尺寸判断，也和分辨率有关，不过在通常情况下，    综合计算考虑，仅根据尺寸判断就可以了：# Java 基础    <span class="hljs-number">1</span>：    <span class="hljs-built_in">int</span> a = <span class="hljs-number">1</span>;    <span class="hljs-built_in">int</span> m1 = ++a +<span class="hljs-number">3</span>;    结果 ：m1 = <span class="hljs-number">5</span>；a=<span class="hljs-number">2</span>;    ++a表示先赋值    <span class="hljs-number">2</span>:    <span class="hljs-built_in">int</span> a = <span class="hljs-number">1</span>;    <span class="hljs-built_in">int</span> m = a+++<span class="hljs-number">3</span>;    结果 m = <span class="hljs-number">4</span>; a= <span class="hljs-number">2</span>;    a++表示后赋值    <span class="hljs-number">3</span>：     m&lt;&lt;<span class="hljs-number">2</span> 表示 m*<span class="hljs-number">2</span>*<span class="hljs-number">2</span>     m&lt;&lt; <span class="hljs-number">3</span> 表示 m*<span class="hljs-number">2</span>*<span class="hljs-number">2</span>*<span class="hljs-number">2</span>     <span class="hljs-built_in">int</span> result =<span class="hljs-number">5</span>&lt;&lt;<span class="hljs-number">2</span> ;<span class="hljs-comment">//a  20  5*2*2 ;</span>     <span class="hljs-built_in">int</span> result1 =<span class="hljs-number">6</span>&lt;&lt;<span class="hljs-number">3</span> ;<span class="hljs-comment">//   48  6*2*2*2</span>     <span class="hljs-built_in">int</span> result2 =<span class="hljs-number">7</span>&lt;&lt;<span class="hljs-number">4</span> ;<span class="hljs-comment">//112  7*2*2*2*2</span>     <span class="hljs-number">4</span>:    a++ 表示a+<span class="hljs-number">1</span>    <span class="hljs-built_in">int</span> a = <span class="hljs-number">2</span>;    <span class="hljs-built_in">int</span> result = (a++ &gt; <span class="hljs-number">2</span>)?(++a):(a+=<span class="hljs-number">3</span>);    结果是<span class="hljs-comment">//6</span>    <span class="hljs-number">5.</span> 下面程序的运行结果是（）    <span class="hljs-keyword">String</span> str1 = <span class="hljs-string">"hello"</span>;<span class="hljs-keyword">String</span> str2 = <span class="hljs-string">"he"</span> + <span class="hljs-keyword">new</span> <span class="hljs-keyword">String</span>(<span class="hljs-string">"llo"</span>);System.err.<span class="hljs-built_in">println</span>(str1 == str2);    答案：<span class="hljs-keyword">false</span>    解析：因为str2中的llo是新申请的内存块，而==判断的是对象的地址而非值，所以不一样。如果是<span class="hljs-keyword">String</span> str2 .equals(str1)，那么就是<span class="hljs-keyword">true</span>了。    <span class="hljs-number">4.</span> 下列说法正确的有（）    A． class中的constructor不可省略    B． constructor必须与class同名，但方法不能与class同名    C． constructor在一个对象被<span class="hljs-keyword">new</span>时执行    D．一个class只能定义一个constructor    答案：C    解析：这里可能会有误区，其实普通的类方法是可以和类名同名的，和构造方法唯一的区分就是，构造方法没有返回值。    下面程序的运行结果：（）    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> main(<span class="hljs-keyword">String</span> args[]) &#123;        Thread t = <span class="hljs-keyword">new</span> Thread() &#123;             <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> run() &#123;                pong();            &#125;        &#125;;             t.run();        System.out.<span class="hljs-built_in">print</span>(<span class="hljs-string">"ping"</span>);     &#125;     <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> pong() &#123;         System.out.<span class="hljs-built_in">print</span>(<span class="hljs-string">"pong"</span>);     &#125;    A pingpong        B pongping       C pingpong和pongping都有可能       D 都不输出    答案：B    解 析：这里考的是Thread类中start()和run()方法的区别了。start()用来启动一个线程，当调用start方法后，系统才会开启一个新 的线程，进而调用run()方法来执行任务，    而单独的调用run()就跟调用普通方法是一样的，已经失去线程的特性了。因此在启动一个线程的时候一定要使 用start()而不是run()。    <span class="hljs-number">7.</span> 下列属于关系型数据库的是（）    A. Oracle    B MySql    C IMS     D MongoDB    答案：AB    解答：IMS（Information Management System ）数据库是IBM公司开发的两种数据库类型之一;    一种是关系数据库，典型代表产品：DB2；    另一种则是层次数据库，代表产品：IMS层次数据库。    非关系型数据库有MongoDB、memcachedb、Redis等。    <span class="hljs-number">8.</span> GC线程是否为守护线程？（）    答案：是    解析：线程分为守护线程和非守护线程（即用户线程）。    只要当前JVM实例中尚存在任何一个非守护线程没有结束，守护线程就全部工作；只有当最后一个非守护线程结束时，守护线程随着JVM一同结束工作。    守护线程最典型的应用就是 GC (垃圾回收器)    <span class="hljs-number">9.</span> <span class="hljs-keyword">volatile</span>关键字是否能保证线程安全？（）    答案：不能    解析：<span class="hljs-keyword">volatile</span>关键字用在多线程同步中，可保证读取的可见性，JVM只是保证从主内存加载到线程工作内存的值是最新的读取值，而非cache中。但多个线程对    <span class="hljs-keyword">volatile</span>的写操作，无法保证线程安全。例 如假如线程<span class="hljs-number">1</span>，线程<span class="hljs-number">2</span> 在进行read,load 操作中，发现主内存中count的值都是<span class="hljs-number">5</span>，那么都会加载这个最新的值，在线程<span class="hljs-number">1</span>堆count进行修改之后，    会write到主内存中，主内存中的 count变量就会变为<span class="hljs-number">6</span>；线程<span class="hljs-number">2</span>由于已经进行read,load操作，在进行运算之后，也会更新主内存count的变量值为<span class="hljs-number">6</span>；导致两个线程及时用 <span class="hljs-keyword">volatile</span>关键字修改之后，还是会存在并发的情况。    <span class="hljs-number">10.</span> 下列说法正确的是（AC）    A LinkedList继承自List    B AbstractSet继承自Set    C HashSet继承自AbstractSet    D WeakMap继承自<span class="hljs-keyword">HashMap</span>    解析：下面是一张下载的Java中的集合类型的继承关系图，一目了然。 http:<span class="hljs-comment">//www.itlanbao.com/ns/news.aspx?s=600034</span>    <span class="hljs-number">11.</span> 存在使i + <span class="hljs-number">1</span> &lt; i的数吗（）      答案：存在      解析：如果i为<span class="hljs-built_in">int</span>型，那么当i为<span class="hljs-built_in">int</span>能表示的最大整数时，i+<span class="hljs-number">1</span>就溢出变成负数了，此时不就&lt;i了吗。      扩展：存在使i &gt; j || i &lt;= j不成立的数吗（）      答案：存在      解析：比如Double.NaN或Float.NaN，      <span class="hljs-number">12.</span> <span class="hljs-number">0.6332</span>的数据类型是（）      A <span class="hljs-built_in">float</span>     B <span class="hljs-keyword">double</span>     C Float      D Double      答案：B      解析：默认为<span class="hljs-keyword">double</span>型，如果为<span class="hljs-built_in">float</span>型需要加上f显示说明，即<span class="hljs-number">0.6332</span>f、      <span class="hljs-number">13.</span> 下面哪个流类属于面向字符的输入流(  )      A  BufferedWriter           B  FileInputStream          C  ObjectInputStream          D  InputStreamReader       答案：D       解析：Java的IO操作中有面向字节(Byte)和面向字符(Character)两种方式。      面向字节的操作为以<span class="hljs-number">8</span>位为单位对二进制的数据进行操作，对数据不进行转换，这些类都是InputStream和OutputStream的子类。      面向字符的操作为以字符为单位对数据进行操作，在读的时候将二进制数据转为字符，在写的时候将字符转为二进制数据，这些类都是Reader和Writer的子类。      总结：以InputStream（输入）/OutputStream（输出）为后缀的是字节流；      以Reader（输入）/Writer（输出）为后缀的是字符流。    下面程序能正常运行吗（）    <span class="hljs-keyword">public</span> class NULL &#123;     <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> haha()&#123;        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">"haha"</span>);    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> main(<span class="hljs-keyword">String</span>[] args) &#123;        ((NULL)<span class="hljs-keyword">null</span>).haha();    &#125; &#125;    答案：能正常运行    解析：输出为haha，因为<span class="hljs-keyword">null</span>值可以强制转 换为任何java类类型,(<span class="hljs-keyword">String</span>)<span class="hljs-keyword">null</span>也是合法的。但<span class="hljs-keyword">null</span>强制转换后是无效对象，其返回值还是为<span class="hljs-keyword">null</span>，而<span class="hljs-keyword">static</span>方法的调用是和 类名绑定的，    不借助对象进行访问所以能正确输出。反过来，没有<span class="hljs-keyword">static</span>修饰就只能用对象进行访问，使用<span class="hljs-keyword">null</span>调用对象肯定会报空指针错了。这里和 C++很类似。    下面程序的运行结果是什么（）       class HelloA &#123;     <span class="hljs-keyword">public</span> HelloA() &#123;        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">"HelloA"</span>);    &#125;        &#123; System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">"I'm A class"</span>); &#125;         <span class="hljs-keyword">static</span> &#123; System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">"static A"</span>); &#125; &#125;<span class="hljs-keyword">public</span> class HelloB extends HelloA &#123;    <span class="hljs-keyword">public</span> HelloB() &#123;        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">"HelloB"</span>);    &#125;    &#123; System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">"I'm B class"</span>); &#125;      <span class="hljs-keyword">static</span> &#123; System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">"static B"</span>); &#125;        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> main(<span class="hljs-keyword">String</span>[] args) &#123; 　　　　 <span class="hljs-keyword">new</span> HelloB(); 　　 &#125; &#125;    答案：    <span class="hljs-keyword">static</span> Astatic BI<span class="hljs-string">'m A classHelloAI'</span>m B classHelloB    解析：说实话我觉得这题很好，考查静态语句块、构造语句块（就是只有大括号的那块）以及构造函数的执行顺序。    对象的初始化顺序：（<span class="hljs-number">1</span>）类加载之后，按从上到下（从父类到子类）执行被<span class="hljs-keyword">static</span>修饰的语句；（<span class="hljs-number">2</span>）当<span class="hljs-keyword">static</span>语句执行完之后,再执行main方法；    （<span class="hljs-number">3</span>）如果有语句<span class="hljs-keyword">new</span>了自身的对象，将从上到下执行构造代码块、构造器（两者可以说绑定在一起）。    下面稍微修改下上面的代码，以便更清晰的说明情况：    class HelloA &#123;     <span class="hljs-keyword">public</span> HelloA() &#123;        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">"HelloA"</span>);    &#125;        &#123; System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">"I'm A class"</span>); &#125;      <span class="hljs-keyword">static</span> &#123; System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">"static A"</span>); &#125; &#125;<span class="hljs-keyword">public</span> class HelloB extends HelloA &#123;    <span class="hljs-keyword">public</span> HelloB() &#123;        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">"HelloB"</span>);    &#125;           &#123; System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">"I'm B class"</span>); &#125;        <span class="hljs-keyword">static</span> &#123; System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">"static B"</span>); &#125;        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> main(<span class="hljs-keyword">String</span>[] args) &#123;         System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">"-------main start-------"</span>);            <span class="hljs-keyword">new</span> HelloB();        <span class="hljs-keyword">new</span> HelloB();        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">"-------main end-------"</span>);    &#125;&#125;    <span class="hljs-keyword">static</span> Astatic B-------main start-------I<span class="hljs-string">'m A classHelloAI'</span>m B classHelloBI<span class="hljs-string">'m A classHelloAI'</span>m B classHelloB-------main end-------    Java7中的<span class="hljs-keyword">switch</span>支持<span class="hljs-keyword">String</span>的实现细节    在Java7之前，<span class="hljs-keyword">switch</span>只能支持 <span class="hljs-built_in">byte</span>、<span class="hljs-keyword">short</span>、<span class="hljs-built_in">char</span>、<span class="hljs-built_in">int</span>或者其对应的封装类以及Enum类型。在Java7中，呼吁很久的<span class="hljs-keyword">String</span>支持也终于被加上了。    <span class="hljs-keyword">public</span> class Test &#123;     <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> test(<span class="hljs-keyword">String</span> <span class="hljs-built_in">str</span>) &#123;        <span class="hljs-keyword">switch</span>(<span class="hljs-built_in">str</span>) &#123;        <span class="hljs-keyword">case</span> <span class="hljs-string">"abc"</span>:            System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">"abc"</span>);            <span class="hljs-keyword">break</span>;        <span class="hljs-keyword">case</span> <span class="hljs-string">"def"</span>:         System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">"def"</span>);            <span class="hljs-keyword">break</span>;        <span class="hljs-keyword">default</span>:            System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">"default"</span>);        &#125;    &#125; &#125;    <span class="hljs-number">5</span>：    <span class="hljs-number">16</span>进制数必须以 <span class="hljs-number">0</span>x开头    &amp;是位操作符，“按位与”    <span class="hljs-number">1</span>转成二进制 <span class="hljs-number">01</span>    <span class="hljs-number">2</span>转成二进制 <span class="hljs-number">10</span>      与运算符    与运算符用符号“&amp;”表示，其使用规律如下：    两个操作数中位都为<span class="hljs-number">1</span>，结果才为<span class="hljs-number">1</span>，否则结果为<span class="hljs-number">0</span>，例如下面的程序段。    <span class="hljs-keyword">public</span> class data13    &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> main(<span class="hljs-keyword">String</span>[] args)    &#123;    <span class="hljs-built_in">int</span> a=<span class="hljs-number">129</span>;    <span class="hljs-built_in">int</span> b=<span class="hljs-number">128</span>;    System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">"a 和b 与的结果是："</span>+(a&amp;b));    &#125;    &#125;    运行结果    a 和b 与的结果是：<span class="hljs-number">128</span>    下面分析这个程序：    “a”的值是<span class="hljs-number">129</span>，转换成二进制就是<span class="hljs-number">10000001</span>，而“b”的值是<span class="hljs-number">128</span>，转换成二进制就是<span class="hljs-number">10000000</span>。根据与运算符的运算规律，只有两个位都是<span class="hljs-number">1</span>，结果才是<span class="hljs-number">1</span>，可以知道结果就是<span class="hljs-number">10000000</span>，即<span class="hljs-number">128</span>。  <span class="hljs-number">2</span>*<span class="hljs-number">2</span>*<span class="hljs-number">2</span>*<span class="hljs-number">2</span>*<span class="hljs-number">2</span>*<span class="hljs-number">2</span>*<span class="hljs-number">2</span>        <span class="hljs-built_in">int</span> a = <span class="hljs-number">1234566</span>;    查询a的二进制Integer.toBinaryString(a);# 学生面试被问到的问题总结  ## <span class="hljs-number">1.</span> 网络传输数据如何加密，比如账户密码，视频？  可以这么回答：  进行安全保证的方式有很多种，如果进行简单的加密可以使用MD5或者DES，但是这些都是相对的，  如果在开发安全性较高的应用时，可以考虑模仿HTTP协议那样，自定义一个协议，  然后封装一下，在协议里使用时间戳+算法加密技术提高安全系数.  Android网络传输中必用的两个加密算法:MD5 和 RSA  答案参考：http:<span class="hljs-comment">//blog.csdn.net/yanzi1225627/article/details/26508035</span>  ## <span class="hljs-number">2.</span> 支付功能如何实现？  回答：    目前主流的支付有三大，微信支付，支付宝支付，第三方银联支付。   如果是我，我的回答是，我做android的目前只是用到第三方开放平台来实现接入这些支付功能，   但是我不知道这些第三方支付功能具体怎么实现的，这个我真不知道，没研究。   如果是接入第三方支付功能的话就比较简单了：参考文章http:<span class="hljs-comment">//blog.163.com/benben_long/blog/static/19945824320142279427395/</span>  支付宝集成：    注意事项    <span class="hljs-number">1.</span>添加android.permission.INTERNET权限和android.permission.ACCESS_NETWORK_STATE权限    <span class="hljs-number">2.</span>代码中出现注释的地方重点看，没注释的地方可以不看    <span class="hljs-number">3.</span>想获取支付宝合作商户ID，及支付宝公钥请点击支付宝链接，生成密钥及PKCS8转码工具在文档中      微信支付集成注意：参考：http:<span class="hljs-comment">//blog.csdn.net/jdsjlzx/article/details/47422279</span>        <span class="hljs-number">1.</span>在你的项目测试微信的组件（分享、支付等）的时候，一定要用你自己的keystore签名出来测试，          如果用debug.keystore肯定是不成功的，        <span class="hljs-number">2.</span>支付成功通知：在WXPayEntryActivity的OnResp中处理，不能以微信返回的通知界面为准         （我遇到的情况，网络不稳定的时候，微信返回界面提示支付失败，但是收到微信通知其实已经支付成功了），          必须要去自己的服务器查询支付状态，这里微信建议用轮循机制去查询    @Override    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> onResp(BaseResp resp) &#123;        Log.d(TAG, <span class="hljs-string">"onPayFinish, errCode = "</span> + resp.errCode);        <span class="hljs-keyword">if</span> (resp.getType() == ConstantsAPI.COMMAND_PAY_BY_WX) &#123;            AlertDialog.Builder builder = <span class="hljs-keyword">new</span> AlertDialog.Builder(<span class="hljs-keyword">this</span>);            builder.setTitle(R.string.app_tip);            builder.setMessage(getString(R.string.pay_result_callback_msg, resp.errStr +<span class="hljs-string">";code="</span> + <span class="hljs-keyword">String</span>.valueOf(resp.errCode)));            builder.show();        &#125;    &#125;    ## <span class="hljs-number">3.</span> 在开发中你都遇到了哪些难题，如何解决的？    如何降低apk包的大小，    apk大小，跟你工程文件大小有直接关系，其中关系最为密切的还是你的图片多少，图片上能用<span class="hljs-number">.9</span>处理的图片尽量用。    如果你一个apk需要适配多种手机，那么你最好只搞一套图片，另外图片的大小也应该做适当压缩，    保证图片显示质量的前提下，尽量优化图片的存储空间 。     <span class="hljs-number">1</span> 删除项目中没有到的文件，包括资源文件，java代码等等     <span class="hljs-number">2</span> 避免jar包的重复引用     <span class="hljs-number">3</span> 可以考虑压缩一下图片，前提是尽量保持图片别失真。     ## <span class="hljs-number">4.</span>android 适配     适配也是一个头疼的事，去年年底我们就开始正对<span class="hljs-number">720</span>为主流做适配了，详细适配 百度  还有有的面试官会问你，你们设计师出的图时根据ios的出还是android的出图  有几种回答， （<span class="hljs-number">1</span>）直接根据android的出图直接做一套<span class="hljs-number">720</span>*<span class="hljs-number">1280</span> （<span class="hljs-number">2</span>）根据ios出图    众所周知iOS设计的像素尺寸是<span class="hljs-number">640</span>*<span class="hljs-number">960</span>/<span class="hljs-number">1136</span>，Android主流的hdpi模式下的像素尺寸是<span class="hljs-number">480</span>*<span class="hljs-number">800</span>。如图，   他们的换算关系是，iOS像素尺寸的<span class="hljs-number">75</span>%是Android的像素尺寸    大概算法，大家可以看看：  其实经过以上整个过程之后，我们已经得出了一个更简单的换算关系：iOS像素尺寸*<span class="hljs-number">75</span>%=Android像素尺寸，    Android像素尺寸*<span class="hljs-number">2</span>/<span class="hljs-number">3</span>=Android的dp尺寸。进而得出：iOS像素尺寸*<span class="hljs-number">75</span>%*<span class="hljs-number">2</span>/<span class="hljs-number">3</span>=Android的dp尺寸。    所以，iOS里一个宽<span class="hljs-number">600</span>px的东西，在Android的hdpi模式下，正好<span class="hljs-number">300</span>dp，正好是<span class="hljs-number">50</span>%，很容易算是吧？     简单说一下：    一、关于布局适配    <span class="hljs-number">1</span>、不要使用绝对布局    <span class="hljs-number">2</span>、尽量使用match_parent 而不是fill_parent 。    <span class="hljs-number">3</span>、能够使用权重的地方尽量使用权重（android:layout_weight）    <span class="hljs-number">4</span>、如果是纯色背景，尽量使用android的<span class="hljs-built_in">shape</span> 自定义。    <span class="hljs-number">5</span>、如果需要在特定分辨率下适配，可以在res目录上新建layout-HxW.xml的文件夹。比如要适配<span class="hljs-number">1080</span>*<span class="hljs-number">1800</span>的屏幕    （魅族MX3采用此分辨率）则新建layout<span class="hljs-number">-1800</span>x1080.xml的文件夹，然后在下面定义布局。Android系统会优先查找分    辨率相同的布局，如果不存在则换使用默认的layout下的布局。    ## <span class="hljs-number">5.</span>一个apk如何快速方便的打多个不同包名的产品（多渠道多产品推广）    我们市场在推广apk的时候有时候需要根据渠道打不同包名的apk并且这些打出来的apk风格和内容展示以及文字展现略有不同。  我们现在的做法是，把主工程项目当做libs形式关联到想要打包的工程，这样打不同包名的时候就方便，直接创建一个工程，  把主工程关联，然后可以在新创建的工程里面略修改一些比如title风格，首页面进入风格 （因为首页我们做了好几套可以根据类型来判断你走的是哪一个风格），就是一个新的apk出现了。  ##  <span class="hljs-number">6.</span>如何在webview中实现点击事件的监听处理？  http:<span class="hljs-comment">//blog.csdn.net/zzf112/article/details/19618101</span>  ## <span class="hljs-number">1</span>、联网请求的时候HTTP协议的哪个部分耗时比较多，导致APP运行缓慢，该怎么优化      这个问题问得应该有问题，个人觉得你需要把http协议原理给他理清楚，这个问题都是与网络快慢有关的，在与服务器交互的时候尽量减少数据量，    这篇文章不错：blog.csdn.net/lmh12506/article/details/<span class="hljs-number">7794512</span>    http:<span class="hljs-comment">//www.cnblogs.com/jdsjlzx/archive/2011/07/25/2116351.html</span>## <span class="hljs-number">2</span>、集成环信的及时通讯SDK如果遇到消息遗漏或者消息重复该怎么解决## <span class="hljs-number">3</span>、如何实现上传和离线上传    Android离线数据同步方案    参考文章：    http:<span class="hljs-comment">//wenku.baidu.com/link?url=3SvxuKV03wXR6LbjJYmXtrtiX7jPehmDTQRklcf_oXRX2FKoP2RzZVFp0Obl8cjZQED3en8orizKI9wFrYkdx3-izxjN8H2gjcpsiUXa98G</span>    略熟悉第三方sdk: Android 版 SugarSync 加入更多离线功能    WebView实现离线缓存阅读    参考文章：http:<span class="hljs-comment">//blog.csdn.net/wwj_748/article/details/44835865</span>    ArcGIS <span class="hljs-keyword">for</span> Android离线数据编辑实现原理    http:<span class="hljs-comment">//blog.csdn.net/arcgis_mobile/article/details/7565877</span>    ## <span class="hljs-number">4</span>、文件的加密    文件加密AES加密算法    AES加密算法是目前比较流行加密方式，目前还没有针对AES有效的破解方式，比较靠谱。    AES加密数据块和密钥长度可以是<span class="hljs-number">128</span>比特、<span class="hljs-number">192</span>比特、<span class="hljs-number">256</span>比特中的任意一个。    AES加密有很多轮的重复和变换。大致步骤如下：    <span class="hljs-number">1</span>、密钥扩展（KeyExpansion），    <span class="hljs-number">2</span>、初始轮（Initial Round），    <span class="hljs-number">3</span>、重复轮（Rounds），每一轮又包括：SubBytes、ShiftRows、MixColumns、AddRoundKey，    <span class="hljs-number">4</span>、最终轮（Final Round），最终轮没有MixColumns。    我以前对文件加密的时候就是参考如下文章    请参考：http:<span class="hljs-comment">//blog.csdn.net/yudajun/article/details/40481135</span>    http:<span class="hljs-comment">//blog.csdn.net/dalancon/article/details/20924823</span>  ## （一）：Android卸载程序之后如何跳转到指定的反馈页面      比如：<span class="hljs-number">360</span>被卸载之后会跳转到指定的反馈页面如何实现？    本题解析：本题目的回答需要从C层出发，不过java层也需要接受一些android BroadcastReceiver机制，              以及BroadcastReceiver无法实现原因，    回答： 参考文章http:<span class="hljs-comment">//blog.csdn.net/jiangwei0910410003/article/details/42177117</span>## （二）：FragmentManager内部如何维护fragment队列，以及fragment事务的回退栈实现原理    本题解析：回答本题需要从以下几点去出发    <span class="hljs-number">1</span>，fragment的生命周期    <span class="hljs-number">2</span>，FragmentManager的作用，以及如何维护fragment队列    <span class="hljs-number">3</span>，如何管理Fragment回退栈和回退栈实现原理    回答：    fragment的生命周期 参考：http:<span class="hljs-comment">//blog.csdn.net/t12x3456/article/details/8104531</span>    FragmentManager的作用，以及如何维护fragment队列    参考：http:<span class="hljs-comment">//longshuai2007.blog.163.com/blog/static/142094414201362631129902/</span>    http:<span class="hljs-comment">//www.cnblogs.com/mybkn/articles/2455138.html</span>    http:<span class="hljs-comment">//www.mamicode.com/info-detail-612467.html</span>    ## （三）：如何保证后台Service不被杀掉        本题解析：先大体介绍一下android的Service以及他的生命周期，其二 介绍出现哪些手机出现service被杀掉的问题，    比如红米手机，service运行一段时间后很容易就被杀掉问题，然后你如何解决Service不被杀掉的方法。    回答：参考 http:<span class="hljs-comment">//blog.csdn.net/mad1989/article/details/22492519</span>------国内一线互联网公司内部面试题库，从一个老码农转载的以下面试题来自于百度、小米、乐视、美团、<span class="hljs-number">58</span>、猎豹、<span class="hljs-number">360</span>、新浪、搜狐内部题库熟悉本文中列出的知识点会大大增加通过前两轮技术面试的几率。欢迎一线公司员工提交内部面试题库，欢迎star。一、java基础<span class="hljs-number">1.</span>接口的意义（百度）规范、扩展、回调<span class="hljs-number">2.</span>抽象类的意义（乐视）为其子类提供一个公共的类型 封装子类中得重复内容 定义抽象方法，子类虽然有不同的实现 但是定义是一致的<span class="hljs-number">3.</span>内部类的作用(百度，乐视)内部类可以用多个实例，每个实例都有自己的状态信息，并且与其他外围对象的信息相互独立。在单个外围类中，可以让多个内部类以不同的方式实现同一个接口，或者继承同一个类。创建内部类对象的时刻并不依赖于外围类对象的创建。内部类并没有令人迷惑的“is-a”关系，他就是一个独立的实体。内部类提供了更好的封装，除了该外围类，其他类都不能访问<span class="hljs-number">4.</span>父类的静态方法能否被子类重写，为什么？（猎豹）不能子类继承父类后，用相同的静态方法和非静态方法，这时非静态方法覆盖父类中的方法（即方法重写），父类的该静态方法被隐藏（如果对象是父类则调用该隐藏的方法），另外子类可继承父类的静态与非静态方法，至于方法重载我觉得它其中一要素就是在同一类中，不能说父类中的什么方法与子类里的什么方法是方法重载的体现<span class="hljs-number">5.</span>举<span class="hljs-number">1</span><span class="hljs-number">-2</span>个排序算法，并使用java代码实现（美团）http:<span class="hljs-comment">//blog.csdn.net/qy1387/article/details/7752973</span><span class="hljs-number">6.</span>列举java的集合和继承关系（百度、美团）http:<span class="hljs-comment">//blog.csdn.net/sdhgood/article/details/38849477</span><span class="hljs-number">7.</span>java虚拟机的特性（百度、乐视）Java语言的一个非常重要的特点就是与平台的无关性。而使用Java虚拟机是实现这一特点的关键。一般的高级语言如果要在不同的平台上运行，至少需要编译成不同的目标代码。而引入Java语言虚拟机后，Java语言在不同平台上运行时不需要重新编译。Java语言使用模式Java虚拟机屏蔽了与具体平台相关的信息，使得Java语言编译程序只需生成在Java虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行。Java虚拟机在执行字节码时，把字节码解释成具体平台上的机器指令执行。<span class="hljs-number">8.</span>哪些情况下的对象会被垃圾回收机制处理掉（乐视、美团、小米）Java 垃圾回收机制最基本的做法是分代回收。内存中的区域被划分成不同的世代，对象根据其存活的时间被保存在对应世代的区域中。一般的实现是划分成<span class="hljs-number">3</span>个世代：年轻、年老和永久。内存的分配是发生在年轻世代中的。当一个对象存活时间足够长的时候，它就会被复制到年老世代中。对于不同的世代可以使用不同的垃圾回收算法。进行世代划分的出发点是对应用中对象存活时间进行研究之后得出的统计规律。一般来说，一个应用中的大部分对象的存活时间都很短。比如局部变量的存活时间就只在方法的执行过程中。基于这一点，对于年轻世代的垃圾回收算法就可以很有针对性。<span class="hljs-number">9.</span>进程和线程的区别（猎豹）简而言之,一个程序至少有一个进程,一个进程至少有一个线程。线程的划分尺度小于进程，使得多线程程序的并发性高。另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别。进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是系统进行资源分配和调度的一个独立单位.线程是进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位.线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源.一个线程可以创建和撤销另一个线程;同一个进程中的多个线程之间可以并发执行.进程和线程的主要差别在于它们是不同的操作系统资源管理方式。进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。但对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程。如果有兴趣深入的话，我建议你们看看《现代操作系统》或者《操作系统的设计与实现》。对就个问题说得比较清楚。<span class="hljs-number">10.</span>Java中==和equals的区别，equals和hashCode的区别（乐视）http:<span class="hljs-comment">//blog.csdn.net/tiantiandjava/article/details/46988461</span><span class="hljs-number">11.</span>常见的排序算法时间复杂度（小米）<span class="hljs-number">12.</span><span class="hljs-keyword">HashMap</span>的实现原理（美团）<span class="hljs-keyword">HashMap</span>概述：    <span class="hljs-keyword">HashMap</span>是基于哈希表的Map接口的非同步实现。此实现提供所有可选的映射操作，并允许使用<span class="hljs-keyword">null</span>值和<span class="hljs-keyword">null</span>键。此类不保证映射的顺序，特别是它不保证该顺序恒久不变。<span class="hljs-keyword">HashMap</span>的数据结构： 在java编程语言中，最基本的结构就是两种，一个是数组，另外一个是模拟指针（引用），所有的数据结构都可以用这两个基本结构来构造的，<span class="hljs-keyword">HashMap</span>也不例外。<span class="hljs-keyword">HashMap</span>实际上是一个“链表散列”的数据结构，即数组和链表的结合体。从上图中可以看出，<span class="hljs-keyword">HashMap</span>底层就是一个数组结构，数组中的每一项又是一个链表。当新建一个<span class="hljs-keyword">HashMap</span>的时候，就会初始化一个数组。<span class="hljs-number">13.</span>java 状态机http:<span class="hljs-comment">//www.jdon.com/designpatterns/designpattern_State.htm</span><span class="hljs-number">14.</span>java中<span class="hljs-built_in">int</span> <span class="hljs-built_in">char</span> <span class="hljs-keyword">long</span>各占多少字节数<span class="hljs-built_in">byte</span> 位数 <span class="hljs-number">8</span> 字节数 <span class="hljs-number">1</span><span class="hljs-keyword">short</span> <span class="hljs-number">16</span> <span class="hljs-number">2</span><span class="hljs-built_in">int</span> <span class="hljs-number">32</span> <span class="hljs-number">4</span><span class="hljs-keyword">long</span> <span class="hljs-number">64</span> <span class="hljs-number">8</span><span class="hljs-built_in">float</span> <span class="hljs-number">32</span> <span class="hljs-number">4</span><span class="hljs-keyword">double</span> <span class="hljs-number">64</span> <span class="hljs-number">8</span><span class="hljs-built_in">char</span> <span class="hljs-number">16</span> <span class="hljs-number">2</span><span class="hljs-number">15.</span>java <span class="hljs-built_in">int</span>与integer的区别http:<span class="hljs-comment">//www.cnblogs.com/shenliang123/archive/2011/10/27/2226903.html</span><span class="hljs-number">16.</span>string stringbuffer stringbuilder 区别（小米、乐视、百度）<span class="hljs-keyword">String</span> 字符串常量StringBuffer 字符串变量（线程安全）StringBuilder 字符串变量（非线程安全）简要的说， <span class="hljs-keyword">String</span> 类型和 StringBuffer 类型的主要性能区别其实在于 <span class="hljs-keyword">String</span> 是不可变的对象, 因此在每次对 <span class="hljs-keyword">String</span> 类型进行改变的时候其实都等同于生成了一个新的 <span class="hljs-keyword">String</span> 对象，然后将指针指向新的 <span class="hljs-keyword">String</span> 对象，所以经常改变内容的字符串最好不要用<span class="hljs-keyword">String</span> ，因为每次生成对象都会对系统性能产生影响，特别当内存中无引用对象多了以后,JVM 的 GC 就会开始工作，那速度是一定会相当慢的。而如果是使用 StringBuffer 类则结果就不一样了，每次结果都会对 StringBuffer 对象本身进行操作，而不是生成新的对象，再改变对象引用。所以在一般情况下我们推荐使用 StringBuffer ，特别是字符串对象经常改变的情况下。而在某些特别情况下， <span class="hljs-keyword">String</span> 对象的字符串拼接其实是被 JVM 解释成了 StringBuffer 对象的拼接，所以这些时候 <span class="hljs-keyword">String</span> 对象的速度并不会比 StringBuffer 对象慢，而特别是以下的字符串对象生成中， <span class="hljs-keyword">String</span> 效率是远要比 StringBuffer 快的：<span class="hljs-keyword">String</span> S1 = “This is only a” + “ simple” + “ test”;StringBuffer Sb = <span class="hljs-keyword">new</span> StringBuilder(“This is only a”).<span class="hljs-built_in">append</span>(“ simple”).<span class="hljs-built_in">append</span>(“ test”); 你会很惊讶的发现，生成 <span class="hljs-keyword">String</span> S1 对象的速度简直太快了，而这个时候 StringBuffer 居然速度上根本一点都不占优势。其实这是 JVM 的一个把戏，在 JVM 眼里，这个  <span class="hljs-keyword">String</span> S1 = “This is only a” + “ simple” + “test”; 其实就是：  <span class="hljs-keyword">String</span> S1 = “This is only a simple test”; 所以当然不需要太多的时间了。但大家这里要注意的是，如果你的字符串是来自另外的 <span class="hljs-keyword">String</span> 对象的话，速度就没那么快了，譬如：  <span class="hljs-keyword">String</span> S2 = “This is only a”; <span class="hljs-keyword">String</span> S3 = “ simple”; <span class="hljs-keyword">String</span> S4 = “ test”; <span class="hljs-keyword">String</span> S1 = S2 +S3 + S4; 这时候 JVM 会规规矩矩的按照原来的方式去做在大部分情况下 StringBuffer &gt; <span class="hljs-keyword">String</span>StringBufferJava.lang.StringBuffer线程安全的可变字符序列。一个类似于 <span class="hljs-keyword">String</span> 的字符串缓冲区，但不能修改。虽然在任意时间点上它都包含某种特定的字符序列，但通过某些方法调用可以改变该序列的长度和内容。可将字符串缓冲区安全地用于多个线程。可以在必要时对这些方法进行同步，因此任意特定实例上的所有操作就好像是以串行顺序发生的，该顺序与所涉及的每个线程进行的方法调用顺序一致。StringBuffer 上的主要操作是 <span class="hljs-built_in">append</span> 和 insert 方法，可重载这些方法，以接受任意类型的数据。每个方法都能有效地将给定的数据转换成字符串，然后将该字符串的字符追加或插入到字符串缓冲区中。<span class="hljs-built_in">append</span> 方法始终将这些字符添加到缓冲区的末端；而 insert 方法则在指定的点添加字符。例如，如果 z 引用一个当前内容是“start”的字符串缓冲区对象，则此方法调用 z.<span class="hljs-built_in">append</span>(<span class="hljs-string">"le"</span>) 会使字符串缓冲区包含“startle”，而 z.insert(<span class="hljs-number">4</span>, <span class="hljs-string">"le"</span>) 将更改字符串缓冲区，使之包含“starlet”。在大部分情况下 StringBuilder &gt; StringBufferjava.lang.StringBuilderjava.lang.StringBuilder一个可变的字符序列是<span class="hljs-number">5.0</span>新增的。此类提供一个与 StringBuffer 兼容的 API，但不保证同步。该类被设计用作 StringBuffer 的一个简易替换，用在字符串缓冲区被单个线程使用的时候（这种情况很普遍）。如果可能，建议优先采用该类，因为在大多数实现中，它比 StringBuffer 要快。两者的方法基本相同<span class="hljs-number">17.</span>Java多态（乐视）Java多态性理解Java中多态性的实现什么是多态面向对象的三大特性：封装、继承、多态。从一定角度来看，封装和继承几乎都是为多态而准备的。这是我们最后一个概念，也是最重要的知识点。多态的定义：指允许不同类的对象对同一消息做出响应。即同一消息可以根据发送对象的不同而采用多种不同的行为方式。（发送消息就是函数调用）实现多态的技术称为：动态绑定（dynamic binding），是指在执行期间判断所引用对象的实 际类型，根据其实际的类型调用其相应的方法。多态的作用：消除类型之间的耦合关系。现实中，关于多态的例子不胜枚举。比方说按下 F1 键这个动作，如果当前在 Flash 界面下弹出的就是 AS <span class="hljs-number">3</span> 的帮助文档；如果当前在 Word 下弹出的就是 Word 帮助；在 Windows 下弹出的就是 Windows 帮助和支持。同一个事件发生在不同的对象上会产生不同的结果。 下面是多态存在的三个必要条件，要求大家做梦时都能背出来！多态存在的三个必要条件 一、要有继承； 二、要有重写； 三、父类引用指向子类对象。 多态的好处：<span class="hljs-number">1.</span>可替换性（substitutability）。多态对已存在代码具有可替换性。例如，多态对圆Circle类工作，对其他任何圆形几何体，如圆环，也同样工作。<span class="hljs-number">2.</span>可扩充性（extensibility）。多态对代码具有可扩充性。增加新的子类不影响已存在类的多态性、继承性，以及其他特性的运行和操作。实际上新加子类更容易获得多态功能。例如，在实现了圆锥、半圆锥以及半球体的多态基础上，很容易增添球体类的多态性。<span class="hljs-number">3.</span>接口性（interface-ability）。多态是超类通过方法签名，向子类提供了一个共同接口，由子类来完善或者覆盖它而实现的。如图<span class="hljs-number">8.3</span> 所示。图中超类Shape规定了两个实现多态的接口方法，computeArea()以及computeVolume()。子类，如Circle和Sphere为了实现多态，完善或者覆盖这两个接口方法。<span class="hljs-number">4.</span>灵活性（flexibility）。它在应用中体现了灵活多样的操作，提高了使用效率。<span class="hljs-number">5.</span>简化性（simplicity）。多态简化对应用软件的代码编写和修改过程，尤其在处理大量对象的运算和操作时，这个特点尤为突出和重要。Java中多态的实现方式：接口实现，继承父类进行方法重写，同一个类中进行方法重载。<span class="hljs-number">18.</span>什么导致线程阻塞（<span class="hljs-number">58</span>、美团）线程的阻塞为了解决对共享存储区的访问冲突，Java 引入了同步机制，现在让我们来考察多个线程对共享资源的访问，显然同步机制已经不够了，因为在任意时刻所要求的资源不一定已经准备好了被访问，反过来，同一时刻准备好了的资源也可能不止一个。为了解决这种情况下的访问控制问题，Java 引入了对阻塞机制的支持.阻塞指的是暂停一个线程的执行以等待某个条件发生（如某资源就绪），学过操作系统的同学对它一定已经很熟悉了。Java 提供了大量方法来支持阻塞，下面让我们逐一分析。sleep() 方法：sleep() 允许 指定以毫秒为单位的一段时间作为参数，它使得线程在指定的时间内进入阻塞状态，不能得到CPU 时间，指定的时间一过，线程重新进入可执行状态。 典型地，sleep() 被用在等待某个资源就绪的情形：测试发现条件不满足后，让线程阻塞一段时间后重新测试，直到条件满足为止。suspend() 和 resume() 方法：两个方法配套使用，suspend()使得线程进入阻塞状态，并且不会自动恢复，必须其对应的resume() 被调用，才能使得线程重新进入可执行状态。典型地，suspend() 和 resume() 被用在等待另一个线程产生的结果的情形：测试发现结果还没有产生后，让线程阻塞，另一个线程产生了结果后，调用 resume() 使其恢复。yield() 方法：yield() 使得线程放弃当前分得的 CPU 时间，但是不使线程阻塞，即线程仍处于可执行状态，随时可能再次分得 CPU 时间。调用 yield() 的效果等价于调度程序认为该线程已执行了足够的时间从而转到另一个线程.wait() 和 notify() 方法：两个方法配套使用，wait() 使得线程进入阻塞状态，它有两种形式，一种允许 指定以毫秒为单位的一段时间作为参数，另一种没有参数，前者当对应的 notify() 被调用或者超出指定时间时线程重新进入可执行状态，后者则必须对应的 notify() 被调用.初看起来它们与 suspend() 和 resume() 方法对没有什么分别，但是事实上它们是截然不同的。区别的核心在于，前面叙述的所有方法，阻塞时都不会释放占用的锁（如果占用了的话），而这一对方法则相反。上述的核心区别导致了一系列的细节上的区别。首先，前面叙述的所有方法都隶属于 Thread 类，但是这一对却直接隶属于 <span class="hljs-keyword">Object</span> 类，也就是说，所有对象都拥有这一对方法。初看起来这十分不可思议，但是实际上却是很自然的，因为这一对方法阻塞时要释放占用的锁，而锁是任何对象都具有的，调用任意对象的 wait() 方法导致线程阻塞，并且该对象上的锁被释放。而调用 任意对象的notify()方法则导致因调用该对象的 wait() 方法而阻塞的线程中随机选择的一个解除阻塞（但要等到获得锁后才真正可执行）。其次，前面叙述的所有方法都可在任何位置调用，但是这一对方法却必须在 <span class="hljs-keyword">synchronized</span> 方法或块中调用，理由也很简单，只有在<span class="hljs-keyword">synchronized</span> 方法或块中当前线程才占有锁，才有锁可以释放。同样的道理，调用这一对方法的对象上的锁必须为当前线程所拥有，这样才有锁可以释放。因此，这一对方法调用必须放置在这样的 <span class="hljs-keyword">synchronized</span> 方法或块中，该方法或块的上锁对象就是调用这一对方法的对象。若不满足这一条件，则程序虽然仍能编译，但在运行时会出现IllegalMonitorStateException 异常。wait() 和 notify() 方法的上述特性决定了它们经常和<span class="hljs-keyword">synchronized</span> 方法或块一起使用，将它们和操作系统的进程间通信机制作一个比较就会发现它们的相似性：<span class="hljs-keyword">synchronized</span>方法或块提供了类似于操作系统原语的功能，它们的执行不会受到多线程机制的干扰，而这一对方法则相当于 block 和wakeup 原语（这一对方法均声明为 <span class="hljs-keyword">synchronized</span>）。它们的结合使得我们可以实现操作系统上一系列精妙的进程间通信的算法（如信号量算法），并用于解决各种复杂的线程间通信问题。关于 wait() 和 notify() 方法最后再说明两点：第一：调用 notify() 方法导致解除阻塞的线程是从因调用该对象的 wait() 方法而阻塞的线程中随机选取的，我们无法预料哪一个线程将会被选择，所以编程时要特别小心，避免因这种不确定性而产生问题。第二：除了 notify()，还有一个方法 notifyAll() 也可起到类似作用，唯一的区别在于，调用 notifyAll() 方法将把因调用该对象的 wait() 方法而阻塞的所有线程一次性全部解除阻塞。当然，只有获得锁的那一个线程才能进入可执行状态。谈到阻塞，就不能不谈一谈死锁，略一分析就能发现，suspend() 方法和不指定超时期限的 wait() 方法的调用都可能产生死锁。遗憾的是，Java 并不在语言级别上支持死锁的避免，我们在编程中必须小心地避免死锁。以上我们对 Java 中实现线程阻塞的各种方法作了一番分析，我们重点分析了 wait() 和 notify() 方法，因为它们的功能最强大，使用也最灵活，但是这也导致了它们的效率较低，较容易出错。实际使用中我们应该灵活使用各种方法，以便更好地达到我们的目的。<span class="hljs-number">19.</span>抽象类接口区别（<span class="hljs-number">360</span>）默认的方法实现 抽象类可以有默认的方法实现完全是抽象的。接口根本不存在方法的实现实现 子类使用extends关键字来继承抽象类。如果子类不是抽象类的话，它需要提供抽象类中所有声明的方法的实现。子类使用关键字implements来实现接口。它需要提供接口中所有声明的方法的实现构造器抽象类可以有构造器 接口不能有构造器与正常Java类的区别除了你不能实例化抽象类之外，它和普通Java类没有任何区 接口是完全不同的类型访问修饰符抽象方法可以有<span class="hljs-keyword">public</span>、<span class="hljs-keyword">protected</span>和<span class="hljs-keyword">default</span>这些修饰符 接口方法默认修饰符是<span class="hljs-keyword">public</span>。你不可以使用其它修饰符。main方法抽象方法可以有main方法并且我们可以运行它接口没有main方法，因此我们不能运行它。多继承抽象类在java语言中所表示的是一种继承关系，一个子类只能存在一个父类，但是可以存在多个接口。速度它比接口速度要快接口是稍微有点慢的，因为它需要时间去寻找在类中实现的方法。添加新方法如果你往抽象类中添加新的方法，你可以给它提供默认的实现。因此你不需要改变你现在的代码。如果你往接口中添加方法，那么你必须改变实现该接口的类。<span class="hljs-number">20.</span>容器类之间的区别（乐视、美团）http:<span class="hljs-comment">//www.cnblogs.com/yuanermen/archive/2009/08/05/1539917.html http://alexyyek.github.io/2015/04/06/Collection/ http://tianmaying.com/tutorial/java_collection</span><span class="hljs-number">21.</span>java 内部类（小米）http:<span class="hljs-comment">//www.cnblogs.com/chenssy/p/3388487.html</span><span class="hljs-number">22.</span>Java中hashmap和hashtable的区别（乐视、小米）http:<span class="hljs-comment">//www.233.com/ncre2/JAVA/jichu/20100717/084230917.html</span><span class="hljs-number">23.</span>ArrayMap VS <span class="hljs-keyword">HashMap</span>http:<span class="hljs-comment">//lvable.com/?p=217</span>二、android基础<span class="hljs-number">1.</span>数据库的操作类型有哪些，如何导入外部数据库？把原数据库包括在项目源码的 res/rawandroid系统下数据库应该存放在 /data/data/com..（<span class="hljs-keyword">package</span> name）/ 目录下，所以我们需要做的是把已有的数据库传入那个目录下.操作方法是用FileInputStream读取原数据库，再用FileOutputStream把读取到的东西写入到那个目录.<span class="hljs-number">2.</span>是否使用过本地广播，和全局广播有什么差别？因广播数据在本应用范围内传播，不用担心隐私数据泄露的问题。 不用担心别的应用伪造广播，造成安全隐患。 相比在系统内发送全局广播，它更高效。<span class="hljs-number">3.</span>是否使用过intentServer，作用是什么，AIDL解决了什么问题？(小米)生成一个默认的且与主线程互相独立的工作者线程来执行所有传送至onStartCommand() 方法的Intetnt。生成一个工作队列来传送Intent对象给你的onHandleIntent()方法，同一时刻只传送一个Intent对象，这样一来，你就不必担心多线程的问题。在所有的请求(Intent)都被执行完以后会自动停止服务，所以，你不需要自己去调用stopSelf()方法来停止。该服务提供了一个onBind()方法的默认实现，它返回<span class="hljs-keyword">null</span>提供了一个onStartCommand()方法的默认实现，它将Intent先传送至工作队列，然后从工作队列中每次取出一个传送至onHandleIntent()方法，在该方法中对Intent对相应的处理。AIDL (Android Interface Definition Language) 是一种IDL 语言，用于生成可以在Android设备上两个进程之间进行进程间通信(interprocess communication, IPC)的代码。如果在一个进程中（例如Activity）要调用另一个进程中（例如Service）对象的操作，就可以使用AIDL生成可序列化的参数。 AIDL IPC机制是面向接口的，像COM或Corba一样，但是更加轻量级。它是使用代理类在客户端和实现端传递数据。<span class="hljs-number">4.</span>Activity、Window、View三者的差别，fragment的特点？（<span class="hljs-number">360</span>）Activity像一个工匠（控制单元），Window像窗户（承载模型），View像窗花（显示视图） LayoutInflater像剪刀，Xml配置像窗花图纸。在Activity中调用attach，创建了一个Window创建的window是其子类PhoneWindow，在attach中创建PhoneWindow在Activity中调用setContentView(R.layout.xxx)其中实际上是调用的getWindow().setContentView()调用PhoneWindow中的setContentView方法创建ParentView:作为ViewGroup的子类,实际是创建的DecorView(作为FramLayout的子类)将指定的R.layout.xxx 通过布局填充器进行填充[其中的parent指的就是DecorView]调用到ViewGroup调用ViewGroup的removeAllView(),先将所有的view移除掉添加新的view:addView()fragment 特点Fragment可以作为Activity界面的一部分组成出现；可以在一个Activity中同时出现多个Fragment，并且一个Fragment也可以在多个Activity中使用；在Activity运行过程中，可以添加、移除或者替换Fragment；Fragment可以响应自己的输入事件，并且有自己的生命周期，它们的生命周期会受宿主Activity的生命周期影响。<span class="hljs-number">5.</span>描述一次网络请求的流程（新浪）￼<span class="hljs-number">6.</span>Handler、Thread和HandlerThread的差别（小米）http:<span class="hljs-comment">//blog.csdn.net/guolin_blog/article/details/9991569</span>http:<span class="hljs-comment">//droidyue.com/blog/2015/11/08/make-use-of-handlerthread/</span>从Android中Thread（java.lang.Thread -&gt; java.lang.<span class="hljs-keyword">Object</span>）描述可以看出，Android的Thread没有对Java的Thread做任何封装，但是Android提供了一个继承自Thread的类HandlerThread（android.os.HandlerThread -&gt; java.lang.Thread），这个类对Java的Thread做了很多便利Android系统的封装。android.os.Handler可以通过Looper对象实例化，并运行于另外的线程中，Android提供了让Handler运行于其它线程的线程实现，也是就HandlerThread。HandlerThread对象start后可以获得其Looper对象，并且使用这个Looper对象实例Handler。<span class="hljs-number">7.</span>低版本SDK实现高版本api（小米）自己实现或@TargetApi annotation<span class="hljs-number">8.</span>Ubuntu编译安卓系统（百度）进入源码根目录. build/envsetup.shlunchfull(编译全部)userdebug(选择编译版本)make -j8(开启<span class="hljs-number">8</span>个线程编译)<span class="hljs-number">9.</span>launch mode应用场景（百度、小米、乐视）standard，创建一个新的Activity。singleTop，栈顶不是该类型的Activity，创建一个新的Activity。否则，onNewIntent。singleTask，回退栈中没有该类型的Activity，创建Activity，否则，onNewIntent+ClearTop。注意:设置了<span class="hljs-string">"singleTask"</span>启动模式的Activity，它在启动的时候，会先在系统中查找属性值affinity等于它的属性值taskAffinity的Task存在； 如果存在这样的Task，它就会在这个Task中启动，否则就会在新的任务栈中启动。因此， 如果我们想要设置了<span class="hljs-string">"singleTask"</span>启动模式的Activity在新的任务中启动，就要为它设置一个独立的taskAffinity属性值。如果设置了<span class="hljs-string">"singleTask"</span>启动模式的Activity不是在新的任务中启动时，它会在已有的任务中查看是否已经存在相应的Activity实例， 如果存在，就会把位于这个Activity实例上面的Activity全部结束掉，即最终这个Activity 实例会位于任务的Stack顶端中。在一个任务栈中只有一个”singleTask”启动模式的Activity存在。他的上面可以有其他的Activity。这点与singleInstance是有区别的。singleInstance，回退栈中，只有这一个Activity，没有其他Activity。singleTop适合接收通知启动的内容显示页面。例如，某个新闻客户端的新闻内容页面，如果收到<span class="hljs-number">10</span>个新闻推送，每次都打开一个新闻内容页面是很烦人的。singleTask适合作为程序入口点。例如浏览器的主界面。不管从多少个应用启动浏览器，只会启动主界面一次，其余情况都会走onNewIntent，并且会清空主界面上面的其他页面。singleInstance应用场景：闹铃的响铃界面。 你以前设置了一个闹铃：上午<span class="hljs-number">6</span>点。在上午<span class="hljs-number">5</span>点<span class="hljs-number">58</span>分，你启动了闹铃设置界面，并按 Home 键回桌面；在上午<span class="hljs-number">5</span>点<span class="hljs-number">59</span>分时，你在微信和朋友聊天；在<span class="hljs-number">6</span>点时，闹铃响了，并且弹出了一个对话框形式的 Activity(名为 AlarmAlertActivity) 提示你到<span class="hljs-number">6</span>点了(这个 Activity 就是以 SingleInstance 加载模式打开的)，你按返回键，回到的是微信的聊天界面，这是因为 AlarmAlertActivity 所在的 Task 的栈只有他一个元素， 因此退出之后这个 Task 的栈空了。如果是以 SingleTask 打开 AlarmAlertActivity，那么当闹铃响了的时候，按返回键应该进入闹铃设置界面。<span class="hljs-number">10.</span>touch 事件传递流程（小米）http:<span class="hljs-comment">//hanhailong.com/2015/09/24/Android-%E4%B8%89%E5%BC%A0%E5%9B%BE%E6%90%9E%E5%AE%9ATouch%E4%BA%8B%E4%BB%B6%E4%BC%A0%E9%80%92%E6%9C%BA%E5%88%B6/</span><span class="hljs-number">11.</span>view绘制流程（百度）http:<span class="hljs-comment">//www.codekk.com/blogs/detail/54cfab086c4761e5001b253f</span><span class="hljs-number">12.</span>多线程（<span class="hljs-number">360</span>）Activity.runOnUiThread(Runnable)View.post(Runnable),View.postDelay(Runnable,<span class="hljs-keyword">long</span>)HandlerAsyncTask<span class="hljs-number">13.</span>线程同步（百度）http:<span class="hljs-comment">//www.itzhai.com/java-based-notebook-thread-synchronization-problem-solving-synchronization-problems-synchronized-block-synchronized-methods.html#read-more</span>http:<span class="hljs-comment">//www.juwends.com/tech/android/android-inter-thread-comm.html</span>单例<span class="hljs-keyword">public</span> class Singleton&#123;<span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">static</span> Singleton mSingleton;<span class="hljs-keyword">private</span> Singleton()&#123;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton getInstance()&#123;  <span class="hljs-keyword">if</span>(mSingleton == <span class="hljs-keyword">null</span>)&#123;\\A    <span class="hljs-keyword">synchronized</span>(Singleton.class)&#123;\\C     <span class="hljs-keyword">if</span>(mSingleton == <span class="hljs-keyword">null</span>)      mSingleton = <span class="hljs-keyword">new</span> Singleton();\\B      &#125;    &#125;    <span class="hljs-keyword">return</span> mSingleton;  &#125;&#125;<span class="hljs-number">14.</span>什么情况导致内存泄漏（美团）<span class="hljs-number">1.</span>资源对象没关闭造成的内存泄漏描述： 资源性对象比如(Cursor，File文件等)往往都用了一些缓冲，我们在不使用的时候，应该及时关闭它们，以便它们的缓冲及时回收内存。它们的缓冲不仅存在于 java虚拟机内，还存在于java虚拟机外。如果我们仅仅是把它的引用设置为<span class="hljs-keyword">null</span>,而不关闭它们，往往会造成内存泄漏。因为有些资源性对象，比如 SQLiteCursor(在析构函数finalize(),如果我们没有关闭它，它自己会调close()关闭)，如果我们没有关闭它，系统在回收它时也会关闭它，但是这样的效率太低了。因此对于资源性对象在不使用的时候，应该调用它的close()函数，将其关闭掉，然后才置为<span class="hljs-keyword">null</span>.在我们的程序退出时一定要确保我们的资源性对象已经关闭。 程序中经常会进行查询数据库的操作，但是经常会有使用完毕Cursor后没有关闭的情况。如果我们的查询结果集比较小，对内存的消耗不容易被发现，只有在常时间大量操作的情况下才会复现内存问题，这样就会给以后的测试和问题排查带来困难和风险。<span class="hljs-number">2.</span>构造Adapter时，没有使用缓存的convertView描述： 以构造ListView的BaseAdapter为例，在BaseAdapter中提供了方法： <span class="hljs-keyword">public</span> View getView(<span class="hljs-built_in">int</span> position, ViewconvertView, ViewGroup parent) 来向ListView提供每一个item所需要的view对象。初始时ListView会从BaseAdapter中根据当前的屏幕布局实例化一定数量的 view对象，同时ListView会将这些view对象缓存起来。当向上滚动ListView时，原先位于最上面的list item的view对象会被回收，然后被用来构造新出现的最下面的list item。这个构造过程就是由getView()方法完成的，getView()的第二个形参View convertView就是被缓存起来的list item的view对象(初始化时缓存中没有view对象则convertView是<span class="hljs-keyword">null</span>)。由此可以看出，如果我们不去使用 convertView，而是每次都在getView()中重新实例化一个View对象的话，即浪费资源也浪费时间，也会使得内存占用越来越大。 ListView回收list item的view对象的过程可以查看: android.widget.AbsListView.java --&gt; voidaddScrapView(View scrap) 方法。 示例代码：<span class="hljs-keyword">public</span> View getView(<span class="hljs-built_in">int</span> position, ViewconvertView, ViewGroup parent) &#123;View view = <span class="hljs-keyword">new</span> Xxx(...); ... ... <span class="hljs-keyword">return</span> view; &#125; 修正示例代码：<span class="hljs-keyword">public</span> View getView(<span class="hljs-built_in">int</span> position, ViewconvertView, ViewGroup parent) &#123;View view = <span class="hljs-keyword">null</span>; <span class="hljs-keyword">if</span> (convertView != <span class="hljs-keyword">null</span>) &#123; view = convertView; populate(view, getItem(position)); ... &#125; <span class="hljs-keyword">else</span> &#123; view = <span class="hljs-keyword">new</span> Xxx(...); ... &#125; <span class="hljs-keyword">return</span> view; &#125; <span class="hljs-number">3.</span>Bitmap对象不在使用时调用recycle()释放内存描述： 有时我们会手工的操作Bitmap对象，如果一个Bitmap对象比较占内存，当它不在被使用的时候，可以调用Bitmap.recycle()方法回收此对象的像素所占用的内存，但这不是必须的，视情况而定。可以看一下代码中的注释：<span class="hljs-comment">/**  •Free up the memory associated with thisbitmap's pixels, and mark the  •bitmap as "dead", meaning itwill throw an exception if getPixels() or  •setPixels() is called, and will drawnothing. This operation cannot be  •reversed, so it should only be called ifyou are sure there are no  •further uses for the bitmap. This is anadvanced call, and normally need  •not be called, since the normal GCprocess will free up this memory when  •there are no more references to thisbitmap.  */</span> <span class="hljs-number">4.</span>试着使用关于application的context来替代和activity相关的context这是一个很隐晦的内存泄漏的情况。有一种简单的方法来避免context相关的内存泄漏。最显著地一个是避免context逃出他自己的范围之外。使用Application context。这个context的生存周期和你的应用的生存周期一样长，而不是取决于activity的生存周期。如果你想保持一个长期生存的对象，并且这个对象需要一个context,记得使用application对象。你可以通过调用 Context.getApplicationContext() or Activity.getApplication()来获得。更多的请看这篇文章如何避免 Android内存泄漏。<span class="hljs-number">5.</span>注册没取消造成的内存泄漏一些Android程序可能引用我们的Anroid程序的对象(比如注册机制)。即使我们的Android程序已经结束了，但是别的引用程序仍然还有对我们的Android程序的某个对象的引用，泄漏的内存依然不能被垃圾回收。调用registerReceiver后未调用unregisterReceiver。 比如:假设我们希望在锁屏界面(LockScreen)中，监听系统中的电话服务以获取一些信息(如信号强度等)，则可以在LockScreen中定义一个 PhoneStateListener的对象，同时将它注册到TelephonyManager服务中。对于LockScreen对象，当需要显示锁屏界面的时候就会创建一个LockScreen对象，而当锁屏界面消失的时候LockScreen对象就会被释放掉。 但是如果在释放 LockScreen对象的时候忘记取消我们之前注册的PhoneStateListener对象，则会导致LockScreen无法被垃圾回收。如果不断的使锁屏界面显示和消失，则最终会由于大量的LockScreen对象没有办法被回收而引起OutOfMemory,使得system_process 进程挂掉。 虽然有些系统程序，它本身好像是可以自动取消注册的(当然不及时)，但是我们还是应该在我们的程序中明确的取消注册，程序结束时应该把所有的注册都取消掉。<span class="hljs-number">6.</span>集合中对象没清理造成的内存泄漏我们通常把一些对象的引用加入到了集合中，当我们不需要该对象时，并没有把它的引用从集合中清理掉，这样这个集合就会越来越大。如果这个集合是<span class="hljs-keyword">static</span>的话，那情况就更严重了。<span class="hljs-number">15.</span>ANR定位和修正如果开发机器上出现问题，我们可以通过查看/data/anr/traces.txt即可，最新的ANR信息在最开始部分。主线程被IO操作（从<span class="hljs-number">4.0</span>之后网络IO不允许在主线程中）阻塞。主线程中存在耗时的计算主线程中错误的操作，比如Thread.wait或者Thread.sleep等 Android系统会监控程序的响应状况，一旦出现下面两种情况，则弹出ANR对话框应用在<span class="hljs-number">5</span>秒内未响应用户的输入事件（如按键或者触摸）BroadcastReceiver未在<span class="hljs-number">10</span>秒内完成相关的处理Service在特定的时间内无法处理完成 <span class="hljs-number">20</span>秒使用AsyncTask处理耗时IO操作。使用Thread或者HandlerThread时，调用Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND)设置优先级，否则仍然会降低程序响应，因为默认Thread的优先级和主线程相同。使用Handler处理工作线程结果，而不是使用Thread.wait()或者Thread.sleep()来阻塞主线程。Activity的onCreate和onResume回调中尽量避免耗时的代码BroadcastReceiver中onReceive代码也要尽量减少耗时，建议使用IntentService处理。<span class="hljs-number">16.</span>什么情况导致oom（乐视、美团）http:<span class="hljs-comment">//www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2015/0920/3478.html</span><span class="hljs-number">1</span>）使用更加轻量的数据结构 <span class="hljs-number">2</span>）Android里面使用Enum <span class="hljs-number">3</span>）Bitmap对象的内存占用 <span class="hljs-number">4</span>）更大的图片 <span class="hljs-number">5</span>）onDraw方法里面执行对象的创建 <span class="hljs-number">6</span>）StringBuilder<span class="hljs-number">17.</span>Android Service与Activity之间通信的几种方式通过Binder对象通过broadcast(广播)的形式<span class="hljs-number">18.</span>Android各个版本API的区别http:<span class="hljs-comment">//blog.csdn.net/lijun952048910/article/details/7980562</span><span class="hljs-number">19.</span> Android代码中实现WAP方式联网（<span class="hljs-number">360</span>）http:<span class="hljs-comment">//blog.csdn.net/asce1885/article/details/7844159</span><span class="hljs-number">20.</span>如何保证service在后台不被kill一、onStartCommand方法，返回START_STICKYSTART_STICKY 在运行onStartCommand后service进程被kill后，那将保留在开始状态，但是不保留那些传入的intent。不久后service就会再次尝试重新创建，因为保留在开始状态，在创建     service后将保证调用onstartCommand。如果没有传递任何开始命令给service，那将获取到<span class="hljs-keyword">null</span>的intent。START_NOT_STICKY 在运行onStartCommand后service进程被kill后，并且没有新的intent传递给它。Service将移出开始状态，并且直到新的明显的方法（startService）调用才重新创建。因为如果没有传递任何未决定的intent那么service是不会启动，也就是期间onstartCommand不会接收到任何<span class="hljs-keyword">null</span>的intent。START_REDELIVER_INTENT 在运行onStartCommand后service进程被kill后，系统将会再次启动service，并传入最后一个intent给onstartCommand。直到调用stopSelf(<span class="hljs-built_in">int</span>)才停止传递intent。如果在被kill后还有未处理好的intent，那被kill后服务还是会自动启动。因此onstartCommand不会接收到任何<span class="hljs-keyword">null</span>的intent。二、提升service优先级在AndroidManifest.xml文件中对于intent-<span class="hljs-built_in">filter</span>可以通过android:priority = <span class="hljs-string">"1000"</span>这个属性设置最高优先级，<span class="hljs-number">1000</span>是最高值，如果数字越小则优先级越低，同时适用于广播。三、提升service进程优先级Android中的进程是托管的，当系统进程空间紧张的时候，会依照优先级自动进行进程的回收。Android将进程分为<span class="hljs-number">6</span>个等级,它们按优先级顺序由高到低依次是:前台进程( FOREGROUND_APP)可视进程(VISIBLE_APP )次要服务进程(SECONDARY_SERVER )后台进程 (HIDDEN_APP)内容供应节点(CONTENT_PROVIDER)空进程(EMPTY_APP)当service运行在低内存的环境时，将会kill掉一些存在的进程。因此进程的优先级将会很重要，可以使用startForeground 将service放到前台状态。这样在低内存时被kill的几率会低一些。四、onDestroy方法里重启serviceservice +broadcast  方式，就是当service走ondestory的时候，发送一个自定义的广播，当收到广播的时候，重新启动service；五、Application加上Persistent属性六、监听系统广播判断Service状态通过系统的一些广播，比如：手机重启、界面唤醒、应用状态改变等等监听并捕获到，然后判断我们的Service是否还存活，别忘记加权限啊。<span class="hljs-number">21.</span>Requestlayout，onlayout，onDraw，DrawChild区别与联系（猎豹）requestLayout()方法 ：会导致调用measure()过程 和 layout()过程 。 说明：只是对View树重新布局layout过程包括measure()和layout()过程，不会调用<span class="hljs-title">draw</span>()过程，但不会重新绘制 任何视图包括该调用者本身。onLayout()方法(如果该View是ViewGroup对象，需要实现该方法，对每个子视图进行布局)调用onDraw()方法绘制视图本身   (每个View都需要重载该方法，ViewGroup不需要实现该方法)drawChild()去重新回调每个子视图的<span class="hljs-title">draw</span>()方法<span class="hljs-number">22.</span>invalidate()和postInvalidate() 的区别及使用（百度）http:<span class="hljs-comment">//blog.csdn.net/mars2639/article/details/6650876</span><span class="hljs-number">23.</span>Android动画框架实现原理Animation框架定义了透明度，旋转，缩放和位移几种常见的动画，而且控制的是整个View，实现原理是每次绘制视图时View所在的ViewGroup中的drawChild函数获取该View的Animation的Transformation值，然后调用canvas.<span class="hljs-built_in">concat</span>(transformToApply.getMatrix())，通过矩阵运算完成动画帧，如果动画没有完成，继续调用invalidate()函数，启动下次绘制来驱动动画，动画过程中的帧之间间隙时间是绘制函数所消耗的时间，可能会导致动画消耗比较多的CPU资源，最重要的是，动画改变的只是显示，并不能相应事件。<span class="hljs-number">24.</span>Android为每个应用程序分配的内存大小是多少？（美团）android程序内存一般限制在<span class="hljs-number">16</span>M，也有的是<span class="hljs-number">24</span>M<span class="hljs-number">25.</span>Android View刷新机制（百度、美团）由ViewRoot对象的performTraversals()方法调用<span class="hljs-title">draw</span>()方法发起绘制该View树，值得注意的是每次发起绘图时，并不会重新绘制每个View树的视图，而只会重新绘制那些“需要重绘”的视图，View类内部变量包含了一个标志位DRAWN，当该视图需要重绘时，就会为该View添加该标志位。调用流程 ：mView.<span class="hljs-title">draw</span>()开始绘制，<span class="hljs-title">draw</span>()方法实现的功能如下：绘制该View的背景为显示渐变框做一些准备操作(见<span class="hljs-number">5</span>，大多数情况下，不需要改渐变框)          调用onDraw()方法绘制视图本身   (每个View都需要重载该方法，ViewGroup不需要实现该方法)调用dispatchDraw ()方法绘制子视图(如果该View类型不为ViewGroup，即不包含子视图，不需要重载该方法)值得说明的是，ViewGroup类已经为我们重写了dispatchDraw ()的功能实现，应用程序一般不需要重写该方法，但可以重载父类函数实现具体的功能。<span class="hljs-number">26.</span>LinearLayout对比RelativeLayout（百度）RelativeLayout会让子View调用<span class="hljs-number">2</span>次onMeasure，LinearLayout 在有weight时，也会调用子View2次onMeasureRelativeLayout的子View如果高度和RelativeLayout不同，则会引发效率问题，当子View很复杂时，这个问题会更加严重。如果可以，尽量使用padding代替margin。在不影响层级深度的情况下,使用LinearLayout和FrameLayout而不是RelativeLayout。最后再思考一下文章开头那个矛盾的问题，为什么Google给开发者默认新建了个RelativeLayout，而自己却在DecorView中用了个LinearLayout。因为DecorView的层级深度是已知而且固定的，上面一个标题栏，下面一个内容栏。采用RelativeLayout并不会降低层级深度，所以此时在根节点上用LinearLayout是效率最高的。而之所以给开发者默认新建了个RelativeLayout是希望开发者能采用尽量少的View层级来表达布局以实现性能最优，因为复杂的View嵌套对性能的影响会更大一些。<span class="hljs-number">27.</span>优化自定义view（百度、乐视、小米）为了加速你的view，对于频繁调用的方法，需要尽量减少不必要的代码。先从onDraw开始，需要特别注意不应该在这里做内存分配的事情，因为它会导致GC，从而导致卡顿。在初始化或者动画间隙期间做分配内存的动作。不要在动画正在执行的时候做内存分配的事情。你还需要尽可能的减少onDraw被调用的次数，大多数时候导致onDraw都是因为调用了invalidate().因此请尽量减少调用invaildate()的次数。如果可能的话，尽量调用含有<span class="hljs-number">4</span>个参数的invalidate()方法而不是没有参数的invalidate()。没有参数的invalidate会强制重绘整个view。另外一个非常耗时的操作是请求layout。任何时候执行requestLayout()，会使得Android UI系统去遍历整个View的层级来计算出每一个view的大小。如果找到有冲突的值，它会需要重新计算好几次。另外需要尽量保持View的层级是扁平化的，这样对提高效率很有帮助。如果你有一个复杂的UI，你应该考虑写一个自定义的ViewGroup来执行他的layout操作。与内置的view不同，自定义的view可以使得程序仅仅测量这一部分，这避免了遍历整个view的层级结构来计算大小。这个PieChart 例子展示了如何继承ViewGroup作为自定义view的一部分。PieChart 有子views，但是它从来不测量它们。而是根据他自身的layout法则，直接设置它们的大小。<span class="hljs-number">28.</span>ContentProvider（乐视）http:<span class="hljs-comment">//blog.csdn.net/coder_pig/article/details/47858489</span><span class="hljs-number">29.</span>fragment生命周期<span class="hljs-number">30.</span>volley解析（美团、乐视）http:<span class="hljs-comment">//a.codekk.com/detail/Android/grumoon/Volley%20%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90</span><span class="hljs-number">31.</span>Android Glide源码解析http:<span class="hljs-comment">//www.lightskystreet.com/2015/10/12/glide_source_analysis/ http://frodoking.github.io/2015/10/10/android-glide/</span><span class="hljs-number">32.</span>Android 设计模式http:<span class="hljs-comment">//blog.csdn.net/bboyfeiyu/article/details/44563871</span><span class="hljs-number">33.</span>架构设计（搜狐）http:<span class="hljs-comment">//www.tianmaying.com/tutorial/AndroidMVC</span><span class="hljs-number">34.</span>Android属性动画特性（乐视、小米）如果你的需求中只需要对View进行移动、缩放、旋转和淡入淡出操作，那么补间动画确实已经足够健全了。但是很显然，这些功能是不足以覆盖所有的场景的，一旦我们的需求超出了移动、缩放、旋转和淡入淡出这四种对View的操作，那么补间动画就不能再帮我们忙了，也就是说它在功能和可扩展方面都有相当大的局限性，那么下面我们就来看看补间动画所不能胜任的场景。注意上面我在介绍补间动画的时候都有使用“对View进行操作”这样的描述，没错，补间动画是只能够作用在View上的。也就是说，我们可以对一个Button、TextView、甚至是LinearLayout、或者其它任何继承自View的组件进行动画操作，但是如果我们想要对一个非View的对象进行动画操作，抱歉，补间动画就帮不上忙了。可能有的朋友会感到不能理解，我怎么会需要对一个非View的对象进行动画操作呢？这里我举一个简单的例子，比如说我们有一个自定义的View，在这个View当中有一个Point对象用于管理坐标，然后在onDraw()方法当中就是根据这个Point对象的坐标值来进行绘制的。也就是说，如果我们可以对Point对象进行动画操作，那么整个自定义View的动画效果就有了。显然，补间动画是不具备这个功能的，这是它的第一个缺陷。然后补间动画还有一个缺陷，就是它只能够实现移动、缩放、旋转和淡入淡出这四种动画操作，那如果我们希望可以对View的背景色进行动态地改变呢？很遗憾，我们只能靠自己去实现了。说白了，之前的补间动画机制就是使用硬编码的方式来完成的，功能限定死就是这些，基本上没有任何扩展性可言。最后，补间动画还有一个致命的缺陷，就是它只是改变了View的显示效果而已，而不会真正去改变View的属性。什么意思呢？比如说，现在屏幕的左上角有一个按钮，然后我们通过补间动画将它移动到了屏幕的右下角，现在你可以去尝试点击一下这个按钮，点击事件是绝对不会触发的，因为实际上这个按钮还是停留在屏幕的左上角，只不过补间动画将这个按钮绘制到了屏幕的右下角而已。# 笔试题android中常用的四个布局是_____，_____，_____和_____。答案：framlayout，linenarlayout，relativelayout和tablelayout------下列哪些语句关于内存回收的说明是正确的? ()```  A、程序员必须创建一个线程来释放内存B、内存回收程序负责释放无用内存C、内存回收程序允许程序员直接释放内存D、内存回收程序可以在指定的时间释放内存对象</code></pre></div></p><p>答案：B</p><hr><p>请谈一下Android系统的架构。</p><p>答：Android系统采用了分层架构，从高层到低层分别是应用程序层、应用程序框架层、系统运行库层和linux核心层。</p><hr><p>在android中使用Menu时可能需要重写的方法有（）。(多选)</p><div class="hljs"><pre><code class="hljs isbl"><span class="hljs-variable">A</span>、<span class="hljs-function"><span class="hljs-title">onCreateOptionsMenu</span>()</span><span class="hljs-variable">B</span>、<span class="hljs-function"><span class="hljs-title">onCreateMenu</span>()</span><span class="hljs-variable">C</span>、<span class="hljs-function"><span class="hljs-title">onOptionsItemSelected</span>()</span><span class="hljs-variable">D</span>、<span class="hljs-function"><span class="hljs-title">onItemSelected</span>()</span></code></pre></div><p>答案：AC</p><hr><p>sim卡的EF文件有何作用？</p><p>答：sim卡的文件系统有自己规范，主要是为了和手机通讯，sim本身可以有自己的操作系统，EF就是作存储并和手机通讯用的。</p><hr><p>在SQL Server Management Studio 中运行下列T-SQL语句，其输出值（）。</p><div class="hljs"><pre><code class="hljs angelscript">SELECT @@IDENTITY  A、可能为<span class="hljs-number">0.1</span>B、可能为<span class="hljs-number">3</span>C、不可能为<span class="hljs-number">-100</span>D、肯定为<span class="hljs-number">0</span></code></pre></div><p>答案：C</p><hr><p>嵌入式操作系统内存管理有哪几种，各有何特性？</p><p>答：页式，段式，段页，用到了MMU,虚拟空间等技术。</p><hr><p>在SQL Server 2005中运行如下T-SQL语句，假定SALES表中有多行数据，执行查询之后的结果是（）。</p><div class="hljs"><pre><code class="hljs pgsql"><span class="hljs-keyword">BEGIN</span> <span class="hljs-keyword">TRANSACTION</span> A<span class="hljs-keyword">Update</span> SALES <span class="hljs-keyword">Set</span> qty=<span class="hljs-number">30</span> <span class="hljs-keyword">WHERE</span> qty&lt;<span class="hljs-number">30</span><span class="hljs-keyword">BEGIN</span> <span class="hljs-keyword">TRANSACTION</span> B<span class="hljs-keyword">Update</span> SALES <span class="hljs-keyword">Set</span> qty=<span class="hljs-number">40</span> <span class="hljs-keyword">WHERE</span> qty&lt;<span class="hljs-number">40</span><span class="hljs-keyword">Update</span> SALES <span class="hljs-keyword">Set</span> qty=<span class="hljs-number">50</span> <span class="hljs-keyword">WHERE</span> qty&lt;<span class="hljs-number">50</span><span class="hljs-keyword">Update</span> SALES <span class="hljs-keyword">Set</span> qty=<span class="hljs-number">60</span> <span class="hljs-keyword">WHERE</span> qty&lt;<span class="hljs-number">60</span><span class="hljs-keyword">COMMIT</span>　<span class="hljs-keyword">TRANSACTION</span> B<span class="hljs-keyword">COMMIT</span> <span class="hljs-keyword">TRANSACTION</span> AA、SALES表中qty列最小值大于等于<span class="hljs-number">30</span>B、SALES表中qty列最小值大于等于<span class="hljs-number">40</span>C、SALES表中qty列的数据全部为<span class="hljs-number">50</span>D、SALES表中qty列最小值大于等于<span class="hljs-number">60</span></code></pre></div><p>答案：D</p><hr><p>什么是嵌入式实时操作系统, Android 操作系统属于实时操作系统吗?</p><p>答：嵌入式实时操作系统是指当外界事件或数据产生时，能够接受并以足够快的速度予以处理，其处理的结果又能在规定的时间之内来控制生产过程或对处理系统作出快速响应，并控制所有实时任务协调一致运行的嵌入式操作系统。主要用于工业控制、军事设备、航空航天等领域对系统的响应时间有苛刻的要求，这就需要使用实时系统。又可分为软实时和硬实时两种，而android是基于linux内核的，因此属于软实时。</p><hr><p>在android中使用SQLiteOpenHelper这个辅助类时，可以生成一个数据库，并可以对数据库版本进行管理的方法可以是()</p><div class="hljs"><pre><code class="hljs isbl"><span class="hljs-variable">A</span>、<span class="hljs-function"><span class="hljs-title">getWriteableDatabase</span>()</span><span class="hljs-variable">B</span>、<span class="hljs-function"><span class="hljs-title">getReadableDatabase</span>()</span><span class="hljs-variable">C</span>、<span class="hljs-function"><span class="hljs-title">getDatabase</span>()</span><span class="hljs-variable">D</span>、<span class="hljs-function"><span class="hljs-title">getAbleDatabase</span>()</span></code></pre></div><p>答案：AB</p><hr><p>一条最长的短信息约占多少byte?</p><p>答：中文70(包括标点)，英文160，160个字节。</p><hr><p>android 关于service生命周期的onCreate()和onStart()说法正确的是()(多选题)</p><div class="hljs"><pre><code class="hljs isbl"><span class="hljs-variable">A</span>、当第一次启动的时候先后调用<span class="hljs-function"><span class="hljs-title">onCreate</span>()和<span class="hljs-title">onStart</span>()方法</span><span class="hljs-function"><span class="hljs-variable">B</span>、当第一次启动的时候只会调用<span class="hljs-title">onCreate</span>()方法</span><span class="hljs-function"><span class="hljs-variable">C</span>、如果<span class="hljs-variable">service</span>已经启动，将先后调用<span class="hljs-title">onCreate</span>()和<span class="hljs-title">onStart</span>()方法</span><span class="hljs-function"><span class="hljs-variable">D</span>、如果<span class="hljs-variable">service</span>已经启动，只会执行<span class="hljs-title">onStart</span>()方法，不在执行<span class="hljs-title">onCreate</span>()方法</span></code></pre></div><p>答案：AD</p><hr><p>android中的动画有哪几类，它们的特点和区别是什么?</p><p>答：两种，一种是Tween动画、还有一种是Frame动画。Tween动画，这种实现方式可以使视图组件移动、放大、缩小以及产生透明度的变化;另一种Frame动画，传统的动画方法，通过顺序的播放排列好的图片来实现，类似电影。</p><hr><p>下面是属于GLSurFaceView特性的是()(多选)</p><div class="hljs"><pre><code class="hljs maxima">A、管理一个<span class="hljs-built_in">surface</span>，这个<span class="hljs-built_in">surface</span>就是一块特殊的内存，能直接排版到android的视图<span class="hljs-built_in">view</span>上。B、管理一个EGL <span class="hljs-built_in">display</span>，它能让opengl把内容渲染到上述的<span class="hljs-built_in">surface</span>上。C、让渲染器在独立的线程里运作，和UI线程分离。D、可以直接从内存或者DMA等硬件接口取得图像数据</code></pre></div><p>答案：ABC</p><hr><p>handler机制的原理。</p><p>答：andriod提供了Handler和Looper来满足线程间的通信。Handler先进先出原则。Looper类用来管理特定线程内对象之间的消息交换(Message Exchange)。<br>1)Looper: 一个线程可以产生一个Looper对象，由它来管理此线程里的Message Queue(消息队列)。<br>2)Handler: 你可以构造Handler对象来与Looper沟通，以便push新消息到Message Queue里;或者接收Looper从Message Queue取出)所送来的消息。<br>3)Message Queue(消息队列):用来存放线程放入的消息。<br>4)线程：UI thread 通常就是main thread，而Android启动程序时会替它建立一个Message Queue。</p><hr><p>下面在AndroidManifest.xml文件中注册BroadcastReceiver方式正确的()</p><div class="hljs"><pre><code class="hljs xml">A、<span class="hljs-tag">&lt;<span class="hljs-name">receiver</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">"NewBroad"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">intent-filter</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">action</span></span><span class="hljs-tag">   <span class="hljs-attr">android:name</span>=<span class="hljs-string">"android.provider.action.NewBroad"</span>/&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">action</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">intent-filter</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">receiver</span>&gt;</span>B、<span class="hljs-tag">&lt;<span class="hljs-name">receiver</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">"NewBroad"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">intent-filter</span>&gt;</span>   android:name="android.provider.action.NewBroad"/&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">intent-filter</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">receiver</span>&gt;</span>C、<span class="hljs-tag">&lt;<span class="hljs-name">receiver</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">"NewBroad"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">action</span></span><span class="hljs-tag">  <span class="hljs-attr">android:name</span>=<span class="hljs-string">"android.provider.action.NewBroad"</span>/&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">action</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">receiver</span>&gt;</span>D、<span class="hljs-tag">&lt;<span class="hljs-name">intent-filter</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">receiver</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">"NewBroad"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">action</span>&gt;</span>   android:name="android.provider.action.NewBroad"/&gt;<span class="hljs-tag">&lt;<span class="hljs-name">action</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">receiver</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">intent-filter</span>&gt;</span></code></pre></div><p>答案：A</p><hr><p>说说mvc模式的原理，它在android中的运用,android的官方建议应用程序的开发采用mvc模式。何谓mvc？</p><p>答：mvc是model,view,controller的缩写，mvc包含三个部分：<br>1、模型（model）对象：是应用程序的主体部分，所有的业务逻辑都应该写在该层。<br>2、视图（view）对象：是应用程序中负责生成用户界面的部分。也是在整个mvc架构中用户唯一可以看到的一层，接收用户的输入，显示处理结果。<br>3、控制器（control）对象：是根据用户的输入，控制用户界面数据显示及更新model对象状态的部分，控制器更重要的一种导航功能，响应用户出发的相关事件，交给m层处理。<br>android鼓励弱耦合和组件的重用，在android中mvc的具体体现如下：<br>1)视图层（view）：一般采用xml文件进行界面的描述，使用的时候可以非常方便的引入，当然，如果你对android了解的比较的多了话，就一定可以想到在android中也可以使用javascript+html等的方式作为view层，当然这里需要进行java和javascript之间的通信，幸运的是，android提供了它们之间非常方便的通信实现。<br>2)控制层（controller）：android的控制层的重任通常落在了众多的acitvity的肩上，这句话也就暗含了不要在acitivity中写代码，要通过activity交割model业务逻辑层处理，这样做的另外一个原因是android中的acitivity的响应时间是5s，如果耗时的操作放在这里，程序就很容易被回收掉。<br>3)模型层（model）：对数据库的操作、对网络等的操作都应该在model里面处理，当然对业务计算等操作也是必须放在的该层的。</p><hr><p>关于ContenValues类说法正确的是()</p><div class="hljs"><pre><code class="hljs arduino">A、他和Hashtable比较类似，也是负责存储一些名值对，但是他存储的名值对当中的名是<span class="hljs-keyword">String</span>类型，而值都是基本类型B、他和Hashtable比较类似，也是负责存储一些名值对，但是他存储的名值对当中的名是任意类型，而值都是基本类型C、他和Hashtable比较类似，也是负责存储一些名值对，但是他存储的名值对当中的名，可以为空，而值都是<span class="hljs-keyword">String</span>类型      D、他和Hashtable比较类似，也是负责存储一些名值对，但是他存储的名值对当中的名是<span class="hljs-keyword">String</span>类型，而值也是<span class="hljs-keyword">String</span>类型</code></pre></div><p>答案：A</p><hr><p>Activity的生命周期？</p><p>答：和其他手机平台的应用程序一样，Android的应用程序的生命周期是被统一掌控的，也就是说我们写的应用程序命运掌握在别人(系统)的手里，我们不能改变它，只能学习并适应它。<br>简单地说一下为什么是这样：我们手机在运行一个应用程序的时候，有可能打进来电话发进来短信，或者没有电了，这时候程序都会被中断，优先去服务电话的基本功能 ，另 外系统也不允许你占用太多资源 ，至少要保证电话功能吧,所以资源不足的时候也就有可 能被干掉。<br>言归正传，Activity的基本生命周期如下代码 所示：<br>Java代码</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Activity</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(Bundle savedInstanceState)</span></span>;<span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onStart</span><span class="hljs-params">()</span></span>;<span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onResume</span><span class="hljs-params">()</span></span>;<span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onPause</span><span class="hljs-params">()</span></span>;<span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onStop</span><span class="hljs-params">()</span></span>;<span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onDestroy</span><span class="hljs-params">()</span></span>;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Activity</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(Bundle savedInstanceState)</span></span>;<span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onStart</span><span class="hljs-params">()</span></span>;<span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onResume</span><span class="hljs-params">()</span></span>;<span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onPause</span><span class="hljs-params">()</span></span>;<span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onStop</span><span class="hljs-params">()</span></span>;<span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onDestroy</span><span class="hljs-params">()</span></span>;&#125;</code></pre></div><p>你自己写的Activity会按需要 重载这些方法，onCreate是免不了的，在一个Activity正常启动的过程中，他们被调用的顺序是 onCreate -&gt; onStart -&gt; onResume, 在Activity被干掉的时候顺序是onPause -&gt; onStop -&gt; onDestroy ，这样就是一个完整的生命周期，但是有人问了 ，程序正运行着呢来电话了，这个程序咋办?中止了呗，如果中止的时候新出的一个Activity是全屏的那么：onPause-&gt;onStop ，恢复的时候onStart-&gt;onResume ，如果打断 这个应用程序的是一个Theme为Translucent 或者Dialog 的Activity那么只是onPause ,恢复 的时候onResume 。<br>详细介绍一下这几个方法中系统在做什么以及我们应该做什么：</p><div class="hljs"><pre><code class="hljs pf"><span class="hljs-keyword">on</span>Create: 在这里创建界面 ，做一些数据 的初始化工作<span class="hljs-keyword">on</span>Start: 到这一步变成用户可见不可交互 的<span class="hljs-keyword">on</span>Resume: 变成和用户可交互 的，(在activity 栈系统通过栈的方式管理这些个 Activity的最上面，运行完弹出栈，则回到上一个Activity)<span class="hljs-keyword">on</span>Pause:到这一步是可见但不可交互的，系统会停止动画等消耗CPU的事情从上文的描述已经知道，应该在这里保存你的一些数据,因为这个时候你的程序的优先级降低，有可能被系统收回。在这里保存的数据，应该在<span class="hljs-keyword">on</span>Resume里读出来，注意：这个方法里做的事情时间要短，因为下一个activity不会等到这个方法完成才启动onstop: 变得不可见 ，被下一个activity覆盖了<span class="hljs-keyword">on</span>Destroy:这是activity被干掉前最后一个被调用方法了，可能是外面类调用finish方法或者是系统为了节省空间将它暂时性的干掉，可以用isFinishing()来判断它，如果你有一个ProgressDialog在线程中转动，请在<span class="hljs-keyword">on</span>Destroy里把他cancel掉，不然等线程结束的时候，调用Dialog的cancel方法会抛 异常的。</code></pre></div><p>onPause，onstop，onDestroy三种状态下activity都有可能被系统干掉<br>为了保证程序的正确性，你要在onPause()里写上持久层操作的代码，将用户编辑的内容都保存到存储介质上(一般都是数据库)。实际工作中因为生命周期的变化而带来的问题也很多，比如你的应用程序起了新的线程在跑，这时候中断了，你还要去维护那个线程，是暂停还是杀掉还是数据回滚，是吧?因为Activity可能被杀掉，所以线程中使用的变量和一些界面元素就千万要注意了，一般我都是采用Android的消息机制[Handler,Message]来处理多线程和界面交互的问题。这个我后面会讲一些，最近因为这些东西头已经很大了，等我理清思绪再跟大家分享。  </p><hr><p>我们都知道Hanlder是线程与Activity通信的桥梁，如果线程处理不当，你的机器就会变得越慢，那么线程销毁的方法是()</p><div class="hljs"><pre><code class="hljs isbl"><span class="hljs-variable">A</span>、<span class="hljs-function"><span class="hljs-title">onDestroy</span>()</span><span class="hljs-variable">B</span>、<span class="hljs-function"><span class="hljs-title">onClear</span>()</span><span class="hljs-variable">C</span>、<span class="hljs-function"><span class="hljs-title">onFinish</span>()</span><span class="hljs-variable">D</span>、<span class="hljs-function"><span class="hljs-title">onStop</span>()</span></code></pre></div><p>答案：A</p><hr><p>你后台的Activity被系统回收怎么办：onSaveInstanceState</p><p>答：当你的程序中某一个Activity A 在运行时中，主动或被动地运行另一个新的Activity B这个时候A会执行</p><div class="hljs"><pre><code class="hljs pf">public void <span class="hljs-keyword">on</span>SaveInstanceState(Bundle <span class="hljs-keyword">out</span>State) &#123;super.<span class="hljs-keyword">on</span>SaveInstanceState(<span class="hljs-keyword">out</span>State);<span class="hljs-keyword">out</span>State.putLong(<span class="hljs-string">"id"</span>, <span class="hljs-number">1234567890</span>);&#125;public void <span class="hljs-keyword">on</span>SaveInstanceState(Bundle <span class="hljs-keyword">out</span>State) &#123;super.<span class="hljs-keyword">on</span>SaveInstanceState(<span class="hljs-keyword">out</span>State);<span class="hljs-keyword">out</span>State.putLong(<span class="hljs-string">"id"</span>, <span class="hljs-number">1234567890</span>);&#125;</code></pre></div><p>B完成以后又会来找A,这个时候就有两种情况，一种是A被回收，一种是没有被回收，被回收的A就要重新调用onCreate()方法，不同于直接启动的是这回onCreate()里是带上参数 savedInstanceState，没被收回的就还是onResume就好了。<br>savedInstanceState是一个Bundle对象，你基本上可以把他理解为系统帮你维护的一个Map对象。在onCreate()里你可能会用到它，如果正常启动onCreate就不会有它，所以用的时候要判断一下是否为空。</p><div class="hljs"><pre><code class="hljs aspectj"><span class="hljs-keyword">if</span> (savedInstanceState != <span class="hljs-keyword">null</span>) &#123;<span class="hljs-keyword">long</span> id = savedInstanceState.getLong(<span class="hljs-string">"id"</span>);&#125;<span class="hljs-keyword">if</span> (savedInstanceState != <span class="hljs-keyword">null</span>) &#123;<span class="hljs-keyword">long</span> id = savedInstanceState.getLong(<span class="hljs-string">"id"</span>);&#125;</code></pre></div><p>就像官方的Notepad教程里的情况，你正在编辑某一个note，突然被中断，那么就把这个note的id记住，再起来的时候就可以根据这个id去把那个note取出来，程序就完整一些。这也是看你的应用需不需要保存什么，比如你的界面就是读取一个列表，那就不需要特殊记住什么，哦，没准你需要记住滚动条的位置…</p><hr><p>下面退出Activity错误的方法是（）</p><div class="hljs"><pre><code class="hljs awk">A、finish()B、抛异常强制退出C、System.<span class="hljs-keyword">exit</span>()D、onStop()</code></pre></div><p>答案：C</p><hr><p>调用与被调用：我们的通信使者Intent</p><p>答：要说Intent了，Intent就是这个这个意图 ，应用程序间Intent进行交流，打个电话啦，来个 电话啦都会发Intent, 这个是Android架构的松耦合的精髓部分，大大提高了组件的复用性，比如你要在你的应用程序中点击按钮，给某人打电话，很简单啊，看下代码先：</p><div class="hljs"><pre><code class="hljs reasonml">Intent intent = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Intent()</span>;intent.set<span class="hljs-constructor">Action(Intent.ACTION_CALL)</span>;intent.set<span class="hljs-constructor">Data(Uri.<span class="hljs-params">parse</span>(<span class="hljs-string">"tel:"</span> + <span class="hljs-params">number</span>)</span>);start<span class="hljs-constructor">Activity(<span class="hljs-params">intent</span>)</span>;Intent intent = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Intent()</span>;intent.set<span class="hljs-constructor">Action(Intent.ACTION_CALL)</span>;intent.set<span class="hljs-constructor">Data(Uri.<span class="hljs-params">parse</span>(<span class="hljs-string">"tel:"</span> + <span class="hljs-params">number</span>)</span>);start<span class="hljs-constructor">Activity(<span class="hljs-params">intent</span>)</span>;</code></pre></div><p>扔出这样一个意图，系统看到了你的意图就唤醒了电话拨号程序，打出来电话。什么读联系人，发短信啊，邮件啊，统统只需要扔出intent就好了，这个部分设计 地确实很好啊。<br>那Intent通过什么来告诉系统需要谁来接受他呢?<br>通常使用Intent有两种方法，第一种是直接说明需要哪一个类来接收代码如下:</p><div class="hljs"><pre><code class="hljs reasonml">Intent intent = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Intent(<span class="hljs-params">this</span>, MyActivity.<span class="hljs-params">class</span>)</span>;intent.get<span class="hljs-constructor">Extras()</span>.put<span class="hljs-constructor">String(<span class="hljs-string">"id"</span>, <span class="hljs-string">"1"</span>)</span>;<span class="hljs-constructor">StartActivity(<span class="hljs-params">intent</span>)</span>;Intent intent = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Intent(<span class="hljs-params">this</span>, MyActivity.<span class="hljs-params">class</span>)</span>;intent.get<span class="hljs-constructor">Extras()</span>.put<span class="hljs-constructor">String(<span class="hljs-string">"id"</span>, <span class="hljs-string">"1"</span>)</span>;<span class="hljs-constructor">StartActivity(<span class="hljs-params">intent</span>)</span>;</code></pre></div><p>第一种方式很明显，直接指定了MyActivity为接受者,并且传了一些数据给MyActivity，在MyActivity里可以用getIntent()来的到这个intent和数据。<br>第二种就需要先看一下AndroidMenifest中的intentfilter的配置了<br>Xml代码</p><div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">intent-filter</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">action</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">"android.intent.action.VIEW"</span> /&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">action</span> <span class="hljs-attr">android:value</span>=<span class="hljs-string">"android.intent.action.EDIT"</span> /&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">action</span> <span class="hljs-attr">android:value</span>=<span class="hljs-string">"android.intent.action.PICK"</span> /&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">category</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">"android.intent.category.DEFAULT"</span> /&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">data</span> <span class="hljs-attr">android:mimeType</span>=<span class="hljs-string">"vnd.android.cursor.dir/vnd.google.note"</span> /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">intent-filter</span>&gt;</span></code></pre></div><p>这里面配置用到了action, data, category这些东西，那么聪明的你一定想到intent里也会有这些东西，然后一匹配不就找到接收者了吗?<br>action其实就是一个意图的字符串名称。<br>上面这段intent-filter的配置文件说明了这个Activity可以接受不同的Action，当然相应的程序逻辑也不一样咯,提一下那个mimeType,他是在ContentProvider里定义的，你要是自己实现一个ContentProvider就知道了，必须指定 mimeType才能让数据被别人使用。<br>不知道原理说明白没，总结一句，就是你调用别的界面不是直接new那个界面，而是通过扔出一个intent，让系统帮你去调用那个界面，这样就多么松藕合啊，而且符合了生命周期被系统管理的原则。<br>想知道category都有啥，Android为你预先定制好的action都有啥等等，请亲自访问官方链接Intent<br>ps:想知道怎么调用系统应用程序的同学，可以仔细看一下你的logcat，每次运行一个程序的时候是不是有一些信息比如:</p><div class="hljs"><pre><code class="hljs stylus">Starting activity: Intent &#123; action=android<span class="hljs-selector-class">.intent</span><span class="hljs-selector-class">.action</span>.MAINcategories=&#123;android<span class="hljs-selector-class">.intent</span><span class="hljs-selector-class">.category</span>.LAUNCHER&#125; flags=<span class="hljs-number">0</span>x10200000comp=&#123;com<span class="hljs-selector-class">.android</span>.camera/com<span class="hljs-selector-class">.android</span><span class="hljs-selector-class">.camera</span>.GalleryPicker&#125; &#125;</code></pre></div><hr><p>android 的四大组件是<strong><strong><em>，</em></strong></strong>，<strong><strong><em>和</em></strong></strong>。</p><p>答案：activiey，service，broadcast和contentprovide</p><hr><p>下面异常是属于Runtime Exception 的是（）(多选)</p><div class="hljs"><pre><code class="hljs armasm">A、ArithmeticException<span class="hljs-keyword">B、IllegalArgumentException</span><span class="hljs-keyword">C、NullPointerException</span><span class="hljs-keyword">D、BufferUnderflowException</span></code></pre></div><p>答案：ABCD</p><hr><p>谈谈android大众常用的五种布局。</p><p>答：在Android中，共有五种布局方式，分别是：FrameLayout(框架布局)，LinearLayout(线性布局)，AbsoluteLayout(绝对布局)，RelativeLayout(相对布局)，TableLayout(表格布局)。</p><h4 id="（1）FrameLayout"><a href="#（1）FrameLayout" class="headerlink" title="（1）FrameLayout"></a>（1）FrameLayout</h4><p>框架布局,放入其中的所有元素都被放置在最左上的区域，而且无法为这些元素指定一个确切的位置,下一个子元素会重叠覆盖上一个子元素，适合浏览单张图片。</p><h4 id="（2）LinearLayout"><a href="#（2）LinearLayout" class="headerlink" title="（2）LinearLayout"></a>（2）LinearLayout</h4><p>线性布局,是应用程序中最常用的布局方式，主要提供控件水平或者垂直排列的模型，每个子组件都是以垂直或水平的方式来定位.(默认是垂直)</p><h4 id="（3）AbsoluteLayout"><a href="#（3）AbsoluteLayout" class="headerlink" title="（3）AbsoluteLayout"></a>（3）AbsoluteLayout</h4><p>绝对定位布局,采用坐标轴的方式定位组件，左上角是（0，0）点，往右x轴递增，往下Y轴递增,组件定位属性为android:layout_x和android:layout_y来确定坐标。</p><h4 id="（4）RelativeLayout"><a href="#（4）RelativeLayout" class="headerlink" title="（4）RelativeLayout"></a>（4）RelativeLayout</h4><p>相对布局,根据另外一个组件或是顶层父组件来确定下一个组件的位置。和CSS里面的类似。</p><h4 id="（5）TableLayout"><a href="#（5）TableLayout" class="headerlink" title="（5）TableLayout"></a>（5）TableLayout</h4><p>表格布局,类似Html里的Table.使用TableRow来布局，其中TableRow代表一行，TableRow的每一个视图组件代表一个单元格。</p><hr><p>下面属于android的动画分类的有()(多项)</p><div class="hljs"><pre><code class="hljs armasm">A、Tween  <span class="hljs-keyword">B、Frame</span><span class="hljs-keyword">C、Draw</span><span class="hljs-keyword">D、Animation</span></code></pre></div><p>答案：AB</p><hr><p>什么是ANR如何避免它?</p><p>答：ANR：Application Not Responding，五秒在Android中，活动管理器和窗口管理器这两个系统服务负责监视应用程序的响应。当出现下列情况时，Android就会显示ANR对话框了：<br>对输入事件(如按键、触摸屏事件)的响应超过5秒<br>意向接受器(intentReceiver)超过10秒钟仍未执行完毕<br>Android应用程序完全运行在一个独立的线程中(例如main)。这就意味着，任何在主线程中运行的，需要消耗大量时间的操作都会引发ANR。因为此时，你的应用程序已经没有机会去响应输入事件和意向广播(Intent broadcast)。<br>因此，任何运行在主线程中的方法，都要尽可能的只做少量的工作。特别是活动生命周期中的重要方法如onCreate()和onResume()等更应如此。潜在的比较耗时的操作，如访问网络和数据库;或者是开销很大的计算，比如改变位图的大小，需要在一个单独的子线程中完成(或者是使用异步请求，如数据库操作)。但这并不意味着你的主线程需要进入阻塞状态已等待子线程结束–也不需要调用Therad.wait()或者Thread.sleep()方法。取而代之的是，主线程为子线程提供一个句柄(Handler)，让子线程在即将结束的时候调用它(xing:可以参看Snake的例子，这种方法与以前我们所接触的有所不同)。使用这种方法涉及你的应用程序，能够保证你的程序对输入保持良好的响应，从而避免因为输入事件超过5秒钟不被处理而产生的ANR。这种实践需要应用到所有显示用户界面的线程，因为他们都面临着同样的超时问题。</p><p>　　</p><hr><p>下面关于Android dvm的进程和Linux的进程,应用程序的进程说法正确的是()</p><div class="hljs"><pre><code class="hljs erlang">A、DVM指dalivk的虚拟机.每一个Android应用程序都在它自己的进程中运行,不一定拥有一个独立的Dalvik虚拟机实例.而每一个DVM都是在Linux中的一个进程,所以说可以认为是同一个概念.B、DVM指dalivk的虚拟机.每一个Android应用程序都在它自己的进程中运行,不一定拥有一个独立的Dalvik虚拟机实例.而每一个DVM不一定都是在Linux 中的一个进程,所以说不是一个概念.C、DVM指dalivk的虚拟机.每一个Android应用程序都在它自己的进程中运行,都拥有一个独立的Dalvik虚拟机实例.而每一个DVM不一定都是在Linux中的一个进程,所以说不是一个概念.D、DVM指dalivk的虚拟机.每一个Android应用程序都在它自己的进程中运行,都拥有一个独立的Dalvik虚拟机实例.而每一个DVM都是在Linux中的一个进程,所以说可以认为是同一个概念.</code></pre></div><p>答案：D</p><hr><p>什么情况会导致Force Close ?如何避免?能否捕获导致其的异常?</p><p>答：一般像空指针啊，可以看起logcat，然后对应到程序中来解决错误</p><p>　　</p><hr><p>Android项目工程下面的assets目录的作用是什么?</p><div class="hljs"><pre><code class="hljs armasm">A、放置应用到的图片资源。<span class="hljs-keyword">B、主要放置多媒体等数据文件</span><span class="hljs-keyword">C、放置字符串，颜色，数组等常量数据</span><span class="hljs-keyword">D、放置一些与UI相应的布局文件，都是xml文件</span></code></pre></div><p>答案：B</p><hr><p>简要解释一下activity、 intent 、intent filter、service、Broadcase、BroadcaseReceiver</p><p>答：一个activity呈现了一个用户可以操作的可视化用户界面<br>一个service不包含可见的用户界面，而是在后台无限地运行<br>可以连接到一个正在运行的服务中，连接后，可以通过服务中暴露出来的借口与其进行通信<br>一个broadcast receiver是一个接收广播消息并作出回应的component，broadcast receiver没有界面<br>intent:content provider在接收到ContentResolver的请求时被激活。<br>activity, service和broadcast receiver是被称为intents的异步消息激活的。<br>一个intent是一个Intent对象，它保存了消息的内容。对于activity和service来说，它指定了请求的操作名称和待操作数据的URI<br>Intent对象可以显式的指定一个目标component。如果这样的话，android会找到这个component(基于manifest文件中的声明)并激活它。但如果一个目标不是显式指定的，android必须找到响应intent的最佳component。<br>它是通过将Intent对象和目标的intent filter相比较来完成这一工作的。一个component的intent filter告诉android该component能处理的intent。intent filter也是在manifest文件中声明的。</p><p>　　</p><hr><p>关于res/raw目录说法正确的是()</p><div class="hljs"><pre><code class="hljs armasm">A、这里的文件是原封不动的存储到设备上不会转换为二进制的格式<span class="hljs-keyword">B、这里的文件是原封不动的存储到设备上会转换为二进制的格式</span><span class="hljs-keyword">C、这里的文件最终以二进制的格式存储到指定的包中</span><span class="hljs-keyword">D、这里的文件最终不会以二进制的格式存储到指定的包中</span></code></pre></div><p>答案：A</p><hr><p>IntentService有何优点?</p><p>答：IntentService 的好处</p><div class="hljs"><pre><code class="hljs asciidoc"><span class="hljs-bullet">* </span>Acitivity的进程，当处理Intent的时候，会产生一个对应的Service<span class="hljs-bullet">* </span>Android的进程处理器现在会尽可能的不kill掉你<span class="hljs-bullet">* </span>非常容易使用</code></pre></div><p>　　</p><hr><p>下列对android NDK的理解正确的是()</p><div class="hljs"><pre><code class="hljs mipsasm">A、NDK是一系列工具的集合<span class="hljs-keyword">B、NDK </span>提供了一份稳定、功能有限的 API 头文件声明。C、使 “<span class="hljs-keyword">Java+C” </span>的开发方式终于转正，成为官方支持的开发方式D、NDK 将是 <span class="hljs-keyword">Android </span>平台支持 C 开发的开端</code></pre></div><p>答案：ABCD</p><hr><p>横竖屏切换时候activity的生命周期?</p><p>1、不设置Activity的android:configChanges时，切屏会重新调用各个生命周期，切横屏时会执行一次，切竖屏时会执行两次<br>2、设置Activity的android:configChanges=”orientation”时，切屏还是会重新调用各个生命周期，切横、竖屏时只会执行一次<br>3、设置Activity的android:configChanges=”orientation|keyboardHidden”时，切屏不会重新调用各个生命周期，只会执行onConfigurationChanged方法</p><hr><p>java.io包中定义了多个流类型来实现输入和输出功能，可以从不同的角度对其进行分类,按功能分为：(),如果为读取的内容进行处理后再输出，需要使用下列哪种流？()</p><div class="hljs"><pre><code class="hljs armasm">A、输入流和输出流  <span class="hljs-keyword">B、字节流和字符流 </span> C、节点流和处理流  D、File <span class="hljs-keyword">stream </span> E、Pipe <span class="hljs-keyword">stream </span> F、Random <span class="hljs-keyword">stream </span> G、Filter <span class="hljs-keyword">stream</span></code></pre></div><p>答案：C,G</p><hr><p>如何将SQLite数据库(dictionary.db文件)与apk文件一起发布?</p><p>解答：可以将dictionary.db文件复制到Eclipse Android工程中的res raw目录中。所有在res raw目录中的文件不会被压缩，这样可以直接提取该目录中的文件。可以将dictionary.db文件复制到res raw目录中</p><p>　　</p><hr><p>下列代码的执行结果是：（）</p><div class="hljs"><pre><code class="hljs angelscript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-symbol">Test3</span> &#123;<span class="hljs-keyword">public</span> static <span class="hljs-built_in">void</span> main(String args[]) &#123;System.<span class="hljs-keyword">out</span>.print(<span class="hljs-number">100</span> % <span class="hljs-number">3</span>);System.<span class="hljs-keyword">out</span>.print(<span class="hljs-string">","</span>);System.<span class="hljs-keyword">out</span>.println(<span class="hljs-number">100</span> % <span class="hljs-number">3.0</span>);&#125;&#125;A、<span class="hljs-number">1</span>,<span class="hljs-number">1</span>B、<span class="hljs-number">1</span>,<span class="hljs-number">1.0</span>C、<span class="hljs-number">1.0</span>,<span class="hljs-number">1</span>D、<span class="hljs-number">1.0</span>,<span class="hljs-number">1.0</span></code></pre></div><p>答案：B</p><hr><p>如何将打开res raw目录中的数据库文件?</p><p>解答：在Android中不能直接打开res raw目录中的数据库文件，而需要在程序第一次启动时将该文件复制到手机内存或SD卡的某个目录中，然后再打开该数据库文件。复制的基本方法是使用getResources().openRawResource方法获得res raw目录中资源的InputStream对象，然后将该InputStream对象中的数据写入其他的目录中相应文件中。在Android SDK中可以使用SQLiteDatabase.openOrCreateDatabase方法来打开任意目录中的SQLite数据库文件。</p><hr><p>在继承中，关于构造方法的说明，下列说法错误的是（）</p><div class="hljs"><pre><code class="hljs actionscript">A、子类无条件的继承父类的无参构造方法，B、子类可以引用父类中的有参构造方法，使用<span class="hljs-keyword">super</span>关键字，C、如果子类没有构造方法，则父类无参构造方法作为自已的构造方法，D、如果子类有无参构造方法，而父类的无参构造方法则被覆盖。</code></pre></div><p>答案：D </p><hr><p>Android引入广播机制的用意?</p><p>答：a:从MVC的角度考虑(应用程序内)<br>其实回答这个问题的时候还可以这样问，android为什么要有那4大组件，现在的移动开发模型基本上也是照搬的web那一套MVC架构，只不过是改了点嫁妆而已。android的四大组件本质上就是为了实现移动或者说嵌入式设备上的MVC架构，它们之间有时候是一种相互依存的关系，有时候又是一种补充关系，引入广播机制可以方便几大组件的信息和数据交互。<br>b：程序间互通消息(例如在自己的应用程序内监听系统来电)<br>c：效率上(参考UDP的广播协议在局域网的方便性)<br>d：设计模式上(反转控制的一种应用，类似监听者模式)</p><hr><p>以下程序的运行结果为（）</p><div class="hljs"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IfTest</span> &#123;</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span> args[])</span> </span>&#123;<span class="hljs-keyword">int</span> x = <span class="hljs-number">3</span>;<span class="hljs-keyword">int</span> y = <span class="hljs-number">1</span>;<span class="hljs-keyword">if</span> (x == y)System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">"Not equal"</span>);<span class="hljs-keyword">else</span>System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">"Equal"</span>);&#125;&#125;A、Not equal     B、Equal    C、无输出    D、编译出错</code></pre></div><p>答案：B    </p><hr><p>Android的四大组件是哪些，它们的作用？</p><p>答：Activity：Activity是Android程序与用户交互的窗口，是Android构造块中最基本的一种，它需要为保持各界面的状态，做很多持久化的事情，妥善管理生命周期以及一些跳转逻辑<br>service：后台服务于Activity，封装有一个完整的功能逻辑实现，接受上层指令，完成相关的食物，定义好需要接受的Intent提供同步和异步的接口<br>Content Provider：是Android提供的第三方应用数据的访问方案，可以派生Content Provider类，对外提供数据，可以像数据库一样进行选择排序，屏蔽内部数据的存储细节，向外提供统一的借口模型，大大简化上层应用，对数据的整合提供了更方便的途径<br>BroadCast Receiver：接受一种或者多种Intent作触发事件，接受相关消息，做一些简单处理，转换成一条Notification，统一了Android的事件广播模型</p><hr><p>Java语言中字符串“学Java”所占的内存空间是()</p><div class="hljs"><pre><code class="hljs angelscript">A. <span class="hljs-number">6</span>个字节B. <span class="hljs-number">7</span>个字节C. <span class="hljs-number">10</span>个字节D. <span class="hljs-number">11</span>个字节</code></pre></div><p>答案：A </p><hr><p>android 中有哪几种解析xml的类？官方推荐哪种？以及它们的原理和区别。</p><p>答：XML解析主要有三种方式，SAX、DOM、PULL。常规在PC上开发我们使用Dom相对轻松些，但一些性能敏感的数据库或手机上还是主要采用SAX方式，SAX读取是单向的，优点:不占内存空间、解析属性方便，但缺点就是对于套嵌多个分支来说处理不是很方便。而DOM方式会把整个XML文件加载到内存中去，这里Android开发网提醒大家该方法在查找方面可以和XPath很好的结合如果数据量不是很大推荐使用，而PULL常常用在J2ME对于节点处理比较好，类似SAX方式，同样很节省内存，在J2ME中我们经常使用的KXML库来解析。</p><hr><p>java.io包中的<strong><strong><em>和</em></strong></strong>类主要用于对对象(Object)的读写。</p><p>答案：objectinputstream和objectoutputstream</p><hr><p>Math.round(11.5)等于多少(). Math.round(-11.5)等于多少().</p><div class="hljs"><pre><code class="hljs angelscript">A、<span class="hljs-number">11</span> ,<span class="hljs-number">-11</span>   B、<span class="hljs-number">11</span> ,<span class="hljs-number">-12</span>   C、<span class="hljs-number">12</span> ,<span class="hljs-number">-11</span>   D、<span class="hljs-number">12</span> ,<span class="hljs-number">-12</span></code></pre></div><p>答案：C</p><hr><p>谈谈android数据存储方式。</p><p>答：Android提供了5种方式存储数据：<br>（1）使用SharedPreferences存储数据；它是Android提供的用来存储一些简单配置信息的一种机制，采用了XML格式将数据存储到设备中。只能在同一个包内使用，不能在不同的包之间使用。<br>（2）文件存储数据；文件存储方式是一种较常用的方法，在Android中读取/写入文件的方法，与Java中实现I/O的程序是完全一样的，提供了openFileInput()和openFileOutput()方法来读取设备上的文件。<br>（3）SQLite数据库存储数据；SQLite是Android所带的一个标准的数据库，它支持SQL语句，它是一个轻量级的嵌入式数据库。<br>（4）使用ContentProvider存储数据；主要用于应用程序之间进行数据交换，从而能够让其他的应用保存或读取此Content Provider的各种数据类型。<br>（5）网络存储数据；通过网络上提供给我们的存储空间来上传(存储)和下载(获取)我们存储在网络空间中的数据信息。</p><hr><p>关于下列程序段的输出结果，说法正确的是：（）</p><div class="hljs"><pre><code class="hljs angelscript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-symbol">MyClass</span> &#123;static <span class="hljs-built_in">int</span> i;<span class="hljs-keyword">public</span> static <span class="hljs-built_in">void</span> main(String argv[]) &#123;System.<span class="hljs-keyword">out</span>.println(i);&#125;&#125;A、有错误，变量i没有初始化。B、<span class="hljs-literal">null</span>C、<span class="hljs-number">1</span>D、<span class="hljs-number">0</span></code></pre></div><p>答案：D</p><hr><p>ListView的优化方案</p><p>答：1、如果自定义适配器，那么在getView方法中要考虑方法传进来的参数contentView是否为null，如果为null就创建contentView并返回，如果不为null则直接使用。在这个方法中尽可能少创建view。<br>2、给contentView设置tag（setTag（）），传入一个viewHolder对象，用于缓存要显示的数据，可以达到图像数据异步加载的效果。<br>3、如果listview需要显示的item很多，就要考虑分页加载。比如一共要显示100条或者更多的时候，我们可以考虑先加载20条，等用户拉到列表底部的时候再去加载接下来的20条。</p><hr><p>请介绍下Android的数据存储方式。</p><p>答：使用SharedPreferences存储数据；文件存储数据；SQLite数据库存储数据；使用ContentProvider存储数据；网络存储数据；<br>Preference，File， DataBase这三种方式分别对应的目录是/data/data/Package Name/Shared_Pref, /data/data/Package Name/files, /data/data/Package Name/database 。</p><h4 id="一：使用SharedPreferences存储数据"><a href="#一：使用SharedPreferences存储数据" class="headerlink" title="一：使用SharedPreferences存储数据"></a>一：使用SharedPreferences存储数据</h4><p>首先说明SharedPreferences存储方式，它是Android提供的用来存储一些简单配置信息的一种机制，例如：登录用户的用户名与密码。其采用了Map数据结构来存储数据，以键值的方式存储，可以简单的读取与写入，具体实例如下：</p><div class="hljs"><pre><code class="hljs routeros">void ReadSharedPreferences() &#123;String strName, strPassword;SharedPreferences<span class="hljs-built_in"> user </span>= getSharedPreferences(<span class="hljs-string">"user_info"</span>, 0);strName = user.getString(<span class="hljs-string">"NAME"</span>, <span class="hljs-string">""</span>);strPassword = user.getString(<span class="hljs-string">"PASSWORD"</span>, <span class="hljs-string">""</span>);&#125;void WriteSharedPreferences(String strName, String strPassword) &#123;SharedPreferences<span class="hljs-built_in"> user </span>= getSharedPreferences(<span class="hljs-string">"user_info"</span>, 0);uer.<span class="hljs-builtin-name">edit</span>();user.putString(<span class="hljs-string">"NAME"</span>, strName);user.putString(<span class="hljs-string">"PASSWORD"</span>, strPassword);user.commit();&#125;</code></pre></div><p>数据读取与写入的方法都非常简单，只是在写入的时候有些区别：先调用edit()使其处于编辑状态，然后才能修改数据，最后使用commit()提交修改的数据。实际上SharedPreferences是采用了XML格式将数据存储到设备中，在DDMS中的File Explorer中的/data/data/<package name>/shares_prefs下。使用SharedPreferences是有些限制的：只能在同一个包内使用，不能在不同的包之间使用。</p><h4 id="二：文件存储数据"><a href="#二：文件存储数据" class="headerlink" title="二：文件存储数据"></a>二：文件存储数据</h4><p>文件存储方式是一种较常用的方法，在Android中读取/写入文件的方法，与Java中实现I/O的程序是完全一样的，提供了openFileInput()和openFileOutput()方法来读取设备上的文件。具体实例如下:</p><div class="hljs"><pre><code class="hljs reasonml">String fn = <span class="hljs-string">"moandroid.log"</span>;FileInputStream fis = <span class="hljs-keyword">open</span><span class="hljs-constructor">FileInput(<span class="hljs-params">fn</span>)</span>;FileOutputStream fos = <span class="hljs-keyword">open</span><span class="hljs-constructor">FileOutput(<span class="hljs-params">fn</span>,Context.MODE_PRIVATE)</span>;</code></pre></div><h4 id="三：网络存储数据"><a href="#三：网络存储数据" class="headerlink" title="三：网络存储数据"></a>三：网络存储数据</h4><p>网络存储方式，需要与Android 网络数据包打交道，关于Android 网络数据包的详细说明，请阅读Android SDK引用了Java SDK的哪些package？。</p><h4 id="四：ContentProvider"><a href="#四：ContentProvider" class="headerlink" title="四：ContentProvider"></a>四：ContentProvider</h4><h4 id="1、ContentProvider简介"><a href="#1、ContentProvider简介" class="headerlink" title="1、ContentProvider简介"></a>1、ContentProvider简介</h4><p>当应用继承ContentProvider类，并重写该类用于提供数据和存储数据的方法，就可以向其他应用共享其数据。虽然使用其他方法也可以对外共享数据，但数据访问方式会因数据存储的方式而不同，如：采用文件方式对外共享数据，需要进行文件操作读写数据；采用sharedpreferences共享数据，需要使用sharedpreferences API读写数据。而使用ContentProvider共享数据的好处是统一了数据访问方式。</p><h4 id="2、Uri类简介"><a href="#2、Uri类简介" class="headerlink" title="2、Uri类简介"></a>2、Uri类简介</h4><p>Uri代表了要操作的数据，Uri主要包含了两部分信息：1.需要操作的ContentProvider，2.对ContentProvider中的什么数据进行操作，一个Uri由以下几部分组成：<br>1.scheme：ContentProvider（内容提供者）的scheme已经由Android所规定为：content://…<br>2.主机名（或Authority）：用于唯一标识这个ContentProvider，外部调用者可以根据这个标识来找到它。<br>3.路径（path）：可以用来表示我们要操作的数据，路径的构建应根据业务而定，如下：<br>要操作contact表中id为10的记录，可以构建这样的路径:/contact/10<br>要操作contact表中id为10的记录的name字段， contact/10/name<br>要操作contact表中的所有记录，可以构建这样的路径:/contact?<br>要操作的数据不一定来自数据库，也可以是文件等他存储方式，如下:<br>要操作xml文件中contact节点下的name节点，可以构建这样的路径：/contact/name<br>如果要把一个字符串转换成Uri，可以使用Uri类中的parse()方法，如下：<br>Uri uri = Uri.parse(“content://com.changcheng.provider.contactprovider/contact”)</p><h4 id="3、UriMatcher、ContentUrist和ContentResolver简介"><a href="#3、UriMatcher、ContentUrist和ContentResolver简介" class="headerlink" title="3、UriMatcher、ContentUrist和ContentResolver简介"></a>3、UriMatcher、ContentUrist和ContentResolver简介</h4><p>因为Uri代表了要操作的数据，所以我们很经常需要解析Uri，并从 Uri中获取数据。Android系统提供了两个用于操作Uri的工具类，分别为UriMatcher 和ContentUris 。掌握它们的使用，会便于我们的开发工作。<br>UriMatcher：用于匹配Uri，它的用法如下：<br>1.首先把你需要匹配Uri路径全部给注册上，如下：</p><div class="hljs"><pre><code class="hljs reasonml"><span class="hljs-comment">//常量UriMatcher.NO_MATCH表示不匹配任何路径的返回码(-1)。</span>UriMatcher uriMatcher = <span class="hljs-keyword">new</span> <span class="hljs-constructor">UriMatcher(UriMatcher.NO_MATCH)</span>;<span class="hljs-comment">//如果match()方法匹配content://com.changcheng.sqlite.provider.contactprovider /contact路径，返回匹配码为1</span>uriMatcher.add<span class="hljs-constructor">URI(<span class="hljs-string">"com.changcheng.sqlite.provider.contactprovider"</span>, <span class="hljs-string">"contact"</span>, 1)</span>;<span class="hljs-comment">//添加需要匹配uri，如果匹配就会返回匹配码</span><span class="hljs-comment">//如果match()方法匹配 content://com.changcheng.sqlite.provider.contactprovider/contact/230路径，返回匹配码为2</span>uriMatcher.add<span class="hljs-constructor">URI(<span class="hljs-string">"com.changcheng.sqlite.provider.contactprovider"</span>, <span class="hljs-string">"contact/"</span>, 2)</span>;<span class="hljs-comment">//号为通配符</span></code></pre></div><p>2.注册完需要匹配的Uri后，就可以使用uriMatcher.match(uri)方法对输入的Uri进行匹配，如果匹配就返回匹配码，匹配码是调用 addURI()方法传入的第三个参数，假设匹配 content://com.changcheng.sqlite.provider.contactprovider/contact路径，返回的匹配码为1。<br>ContentUris：用于获取Uri路径后面的ID部分，它有两个比较实用的方法：</p><div class="hljs"><pre><code class="hljs reasonml"><span class="hljs-keyword">with</span><span class="hljs-constructor">AppendedId(<span class="hljs-params">uri</span>, <span class="hljs-params">id</span>)</span>用于为路径加上ID部分parse<span class="hljs-constructor">Id(<span class="hljs-params">uri</span>)</span>方法用于从路径中获取ID部分</code></pre></div><p>ContentResolver：当外部应用需要对ContentProvider中的数据进行添加、删除、修改和查询操作时，可以使用ContentResolver类来完成，要获取ContentResolver 对象，可以使用Activity提供的getContentResolver()方法。 ContentResolver使用insert、delete、update、query方法，来操作数据。</p><hr><p>activity的启动模式有哪些？是什么含义？</p><p>答：在android里，有4种activity的启动模式，分别为：</p><div class="hljs"><pre><code class="hljs less">“<span class="hljs-selector-tag">standard</span>” (默认)“<span class="hljs-selector-tag">singleTop</span>”“<span class="hljs-selector-tag">singleTask</span>”“<span class="hljs-selector-tag">singleInstance</span>”</code></pre></div><p>它们主要有如下不同：</p><h4 id="1-如何决定所属task"><a href="#1-如何决定所属task" class="headerlink" title="1. 如何决定所属task"></a>1. 如何决定所属task</h4><p>“standard”和”singleTop”的activity的目标task，和收到的Intent的发送者在同一个task内，除非intent包括参数FLAG_ACTIVITY_NEW_TASK。<br>如果提供了FLAG_ACTIVITY_NEW_TASK参数，会启动到别的task里。<br>“singleTask”和”singleInstance”总是把activity作为一个task的根元素，他们不会被启动到一个其他task里。</p><h4 id="2-是否允许多个实例"><a href="#2-是否允许多个实例" class="headerlink" title="2. 是否允许多个实例"></a>2. 是否允许多个实例</h4><p>“standard”和”singleTop”可以被实例化多次，并且存在于不同的task中，且一个task可以包括一个activity的多个实例；<br>“singleTask”和”singleInstance”则限制只生成一个实例，并且是task的根元素。 singleTop要求如果创建intent的时候栈顶已经有要创建 的Activity的实例，则将intent发送给该实例，而不发送给新的实例。</p><h4 id="3-是否允许其它activity存在于本task内"><a href="#3-是否允许其它activity存在于本task内" class="headerlink" title="3. 是否允许其它activity存在于本task内"></a>3. 是否允许其它activity存在于本task内</h4><p>“singleInstance”独占一个task，其它activity不能存在那个task里；如果它启动了一个新的activity，不管新的activity的launch mode 如何，新的activity都将会到别的task里运行（如同加了FLAG_ACTIVITY_NEW_TASK参数）。<br>而另外三种模式，则可以和其它activity共存。</p><h4 id="4-是否每次都生成新实例"><a href="#4-是否每次都生成新实例" class="headerlink" title="4. 是否每次都生成新实例"></a>4. 是否每次都生成新实例</h4><p>“standard”对于没一个启动Intent都会生成一个activity的新实例；<br>“singleTop”的activity如果在task的栈顶的话，则不生成新的该activity的实例，直接使用栈顶的实例，否则，生成该activity的实例。<br>比如现在task栈元素为A-B-C-D（D在栈顶），这时候给D发一个启动intent，如果D是“standard”的，则生成D的一个新实例，栈变为A－B－C－D－D。<br>如果D是singleTop的话，则不会生产D的新实例，栈状态仍为A-B-C-D<br>如果这时候给B发Intent的话，不管B的launchmode是”standard” 还是 “singleTop” ，都会生成B的新实例，栈状态变为A-B-C-D-B。<br>“singleInstance”是其所在栈的唯一activity，它会每次都被重用。<br>“singleTask”如果在栈顶，则接受intent，否则，该intent会被丢弃，但是该task仍会回到前台。<br>当已经存在的activity实例处理新的intent时候，会调用onNewIntent()方法<br>如果收到intent生成一个activity实例，那么用户可以通过back键回到上一个状态；如果是已经存在的一个activity来处理这个intent的话，用户不能通过按back键返回到这之前的状态。</p><hr><p>跟activity和Task 有关的 Intent启动方式有哪些？其含义？</p><p>核心的Intent Flag有：</p><div class="hljs"><pre><code class="hljs ebnf"><span class="hljs-attribute">FLAG_ACTIVITY_NEW_TASK</span><span class="hljs-attribute">FLAG_ACTIVITY_CLEAR_TOP</span><span class="hljs-attribute">FLAG_ACTIVITY_RESET_TASK_IF_NEEDED</span><span class="hljs-attribute">FLAG_ACTIVITY_SINGLE_TOP</span><span class="hljs-attribute">FLAG_ACTIVITY_NEW_TASK</span></code></pre></div><p>如果设置，这个Activity会成为历史stack中一个新Task的开始。一个Task（从启动它的Activity到下一个Task中的Activity）定义了用户可以迁移的Activity原子组。Task可以移动到前台和后台；在某个特定Task中的所有Activity总是保持相同的次序。<br>这个标志一般用于呈现“启动”类型的行为：它们提供用户一系列可以单独完成的事情，与启动它们的Activity完全无关。<br>使用这个标志，如果正在启动的Activity的Task已经在运行的话，那么，新的Activity将不会启动；代替的，当前Task会简单的移入前台。参考FLAG_ACTIVITY_MULTIPLE_TASK标志，可以禁用这一行为。<br>这个标志不能用于调用方对已经启动的Activity请求结果。</p><h4 id="FLAG-ACTIVITY-CLEAR-TOP"><a href="#FLAG-ACTIVITY-CLEAR-TOP" class="headerlink" title="FLAG_ACTIVITY_CLEAR_TOP"></a>FLAG_ACTIVITY_CLEAR_TOP</h4><p>如果设置，并且这个Activity已经在当前的Task中运行，因此，不再是重新启动一个这个Activity的实例，而是在这个Activity上方的所有Activity都将关闭，然后这个Intent会作为一个新的Intent投递到老的Activity（现在位于顶端）中。<br>例如，假设一个Task中包含这些Activity：A，B，C，D。如果D调用了startActivity()，并且包含一个指向Activity B的Intent，那么，C和D都将结束，然后B接收到这个Intent，因此，目前stack的状况是：A，B。<br>上例中正在运行的Activity B既可以在onNewIntent()中接收到这个新的Intent，也可以把自己关闭然后重新启动来接收这个Intent。如果它的启动模式声明为“multiple”(默认值)，并且你没有在这个Intent中设置FLAG_ACTIVITY_SINGLE_TOP标志，那么它将关闭然后重新创建；对于其它的启动模式，或者在这个Intent中设置FLAG_ACTIVITY_SINGLE_TOP标志，都将把这个Intent投递到当前这个实例的onNewIntent()中。<br>这个启动模式还可以与FLAG_ACTIVITY_NEW_TASK结合起来使用：用于启动一个Task中的根Activity，它会把那个Task中任何运行的实例带入前台，然后清除它直到根Activity。这非常有用，例如，当从Notification Manager处启动一个Activity。</p><h4 id="FLAG-ACTIVITY-RESET-TASK-IF-NEEDED"><a href="#FLAG-ACTIVITY-RESET-TASK-IF-NEEDED" class="headerlink" title="FLAG_ACTIVITY_RESET_TASK_IF_NEEDED"></a>FLAG_ACTIVITY_RESET_TASK_IF_NEEDED</h4><p>如果设置这个标志，这个activity不管是从一个新的栈启动还是从已有栈推到栈顶，它都将以the front door of the task的方式启动。这就讲导致任何与应用相关的栈都讲重置到正常状态（不管是正在讲activity移入还是移除），如果需要，或者直接重置该栈为初始状态。</p><h4 id="FLAG-ACTIVITY-SINGLE-TOP"><a href="#FLAG-ACTIVITY-SINGLE-TOP" class="headerlink" title="FLAG_ACTIVITY_SINGLE_TOP"></a>FLAG_ACTIVITY_SINGLE_TOP</h4><p>如果设置，当这个Activity位于历史stack的顶端运行时，不再启动一个新的</p><h4 id="FLAG-ACTIVITY-BROUGHT-TO-FRONT"><a href="#FLAG-ACTIVITY-BROUGHT-TO-FRONT" class="headerlink" title="FLAG_ACTIVITY_BROUGHT_TO_FRONT"></a>FLAG_ACTIVITY_BROUGHT_TO_FRONT</h4><p>这个标志一般不是由程序代码设置的，如在launchMode中设置singleTask模式时系统帮你设定。</p><h4 id="FLAG-ACTIVITY-CLEAR-WHEN-TASK-RESET"><a href="#FLAG-ACTIVITY-CLEAR-WHEN-TASK-RESET" class="headerlink" title="FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET"></a>FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET</h4><p>如果设置，这将在Task的Activity stack中设置一个还原点，当Task恢复时，需要清理Activity。也就是说，下一次Task带着FLAG_ACTIVITY_RESET_TASK_IF_NEEDED标记进入前台时（典型的操作是用户在主画面重启它），这个Activity和它之上的都将关闭，以至于用户不能再返回到它们，但是可以回到之前的Activity。<br>这在你的程序有分割点的时候很有用。例如，一个e-mail应用程序可能有一个操作是查看一个附件，需要启动图片浏览Activity来显示。这个Activity应该作为e-mail应用程序Task的一部分，因为这是用户在这个Task中触发的操作。然而，当用户离开这个Task，然后从主画面选择e-mail app，我们可能希望回到查看的会话中，但不是查看图片附件，因为这让人困惑。通过在启动图片浏览时设定这个标志，浏览及其它启动的Activity在下次用户返回到mail程序时都将全部清除。</p><h4 id="FLAG-ACTIVITY-EXCLUDE-FROM-RECENTS"><a href="#FLAG-ACTIVITY-EXCLUDE-FROM-RECENTS" class="headerlink" title="FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS"></a>FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS</h4><p>如果设置，新的Activity不会在最近启动的Activity的列表中保存。</p><h4 id="FLAG-ACTIVITY-FORWARD-RESULT"><a href="#FLAG-ACTIVITY-FORWARD-RESULT" class="headerlink" title="FLAG_ACTIVITY_FORWARD_RESULT"></a>FLAG_ACTIVITY_FORWARD_RESULT</h4><p>如果设置，并且这个Intent用于从一个存在的Activity启动一个新的Activity，那么，这个作为答复目标的Activity将会传到这个新的Activity中。这种方式下，新的Activity可以调用setResult(int)，并且这个结果值将发送给那个作为答复目标的 Activity。</p><h4 id="FLAG-ACTIVITY-LAUNCHED-FROM-HISTORY"><a href="#FLAG-ACTIVITY-LAUNCHED-FROM-HISTORY" class="headerlink" title="FLAG_ACTIVITY_LAUNCHED_FROM_HISTORY"></a>FLAG_ACTIVITY_LAUNCHED_FROM_HISTORY</h4><p>这个标志一般不由应用程序代码设置，如果这个Activity是从历史记录里启动的（常按HOME键），那么，系统会帮你设定。</p><h4 id="FLAG-ACTIVITY-MULTIPLE-TASK"><a href="#FLAG-ACTIVITY-MULTIPLE-TASK" class="headerlink" title="FLAG_ACTIVITY_MULTIPLE_TASK"></a>FLAG_ACTIVITY_MULTIPLE_TASK</h4><p>不要使用这个标志，除非你自己实现了应用程序启动器。与FLAG_ACTIVITY_NEW_TASK结合起来使用，可以禁用把已存的Task送入前台的行为。当设置时，新的Task总是会启动来处理Intent，而不管这是是否已经有一个Task可以处理相同的事情。<br>由于默认的系统不包含图形Task管理功能，因此，你不应该使用这个标志，除非你提供给用户一种方式可以返回到已经启动的Task。<br>如果FLAG_ACTIVITY_NEW_TASK标志没有设置，这个标志被忽略。</p><h4 id="FLAG-ACTIVITY-NO-ANIMATION"><a href="#FLAG-ACTIVITY-NO-ANIMATION" class="headerlink" title="FLAG_ACTIVITY_NO_ANIMATION"></a>FLAG_ACTIVITY_NO_ANIMATION</h4><p>如果在Intent中设置，并传递给Context.startActivity()的话，这个标志将阻止系统进入下一个Activity时应用Acitivity迁移动画。这并不意味着动画将永不运行——如果另一个Activity在启动显示之前，没有指定这个标志，那么，动画将被应用。这个标志可以很好的用于执行一连串的操作，而动画被看作是更高一级的事件的驱动。</p><h4 id="FLAG-ACTIVITY-NO-HISTORY"><a href="#FLAG-ACTIVITY-NO-HISTORY" class="headerlink" title="FLAG_ACTIVITY_NO_HISTORY"></a>FLAG_ACTIVITY_NO_HISTORY</h4><p>如果设置，新的Activity将不再历史stack中保留。用户一离开它，这个Activity就关闭了。这也可以通过设置noHistory特性。</p><h4 id="FLAG-ACTIVITY-NO-USER-ACTION"><a href="#FLAG-ACTIVITY-NO-USER-ACTION" class="headerlink" title="FLAG_ACTIVITY_NO_USER_ACTION"></a>FLAG_ACTIVITY_NO_USER_ACTION</h4><p>如果设置，作为新启动的Activity进入前台时，这个标志将在Activity暂停之前阻止从最前方的Activity回调的onUserLeaveHint()。<br>典型的，一个Activity可以依赖这个回调指明显式的用户动作引起的Activity移出后台。这个回调在Activity的生命周期中标记一个合适的点，并关闭一些Notification。<br>如果一个Activity通过非用户驱动的事件，如来电或闹钟，启动的，这个标志也应该传递给Context.startActivity，保证暂停的Activity不认为用户已经知晓其Notification。</p><h4 id="FLAG-ACTIVITY-PREVIOUS-IS-TOP"><a href="#FLAG-ACTIVITY-PREVIOUS-IS-TOP" class="headerlink" title="FLAG_ACTIVITY_PREVIOUS_IS_TOP"></a>FLAG_ACTIVITY_PREVIOUS_IS_TOP</h4><p>If set and this intent is being used to launch a new activity from an existing one, the current activity will not be counted as the top activity for deciding whether the new intent should be delivered to the top instead of starting a new one. The previous activity will be used as the top, with the assumption being that the current activity will finish itself immediately.</p><h4 id="FLAG-ACTIVITY-REORDER-TO-FRONT"><a href="#FLAG-ACTIVITY-REORDER-TO-FRONT" class="headerlink" title="FLAG_ACTIVITY_REORDER_TO_FRONT"></a>FLAG_ACTIVITY_REORDER_TO_FRONT</h4><p>如果在Intent中设置，并传递给Context.startActivity()，这个标志将引发已经运行的Activity移动到历史stack的顶端。<br>例如，假设一个Task由四个Activity组成：A,B,C,D。如果D调用startActivity()来启动Activity B，那么，B会移动到历史stack的顶端，现在的次序变成A,C,D,B。如果FLAG_ACTIVITY_CLEAR_TOP标志也设置的话，那么这个标志将被忽略。</p><hr><p>请描述下Activity的生命周期。</p><p>答：activity的生命周期方法有：onCreate()、onStart()、onReStart()、onResume()、onPause()、onStop()、onDestory()；<br>可见生命周期：从onStart()直到系统调用onStop()<br>前台生命周期：从onResume()直到系统调用onPause()</p><hr><p>activity在屏幕旋转时的生命周期</p><p>答：不设置Activity的android:configChanges时，切屏会重新调用各个生命周期，切横屏时会执行一次，切竖屏时会执行两次；设置Activity的android:configChanges=”orientation”时，切屏还是会重新调用各个生命周期，切横、竖屏时只会执行一次；设置Activity的android:configChanges=”orientation|keyboardHidden”时，切屏不会重新调用各个生命周期，只会执行onConfigurationChanged方法</p><hr><p>如何启用Service，如何停用Service。</p><p>服务的开发比较简单，如下：<br>第一步：继承Service类<br>public class SMSService extends Service {}<br>第二步：在AndroidManifest.xml文件中的<application>节点里对服务进行配置:<service android:name=".SMSService" /><br>服务不能自己运行，需要通过调用Context.startService()或Context.bindService()方法启动服务。这两个方法都可以启动Service，但是它们的使用场合有所不同。使用startService()方法启用服务，调用者与服务之间没有关连，即使调用者退出了，服务仍然运行。使用bindService()方法启用服务，调用者与服务绑定在了一起，调用者一旦退出，服务也就终止，大有“不求同时生，必须同时死”的特点。<br>如果打算采用Context.startService()方法启动服务，在服务未被创建时，系统会先调用服务的onCreate()方法，接着调用onStart()方法。如果调用startService()方法前服务已经被创建，多次调用startService()方法并不会导致多次创建服务，但会导致多次调用onStart()方法。采用startService()方法启动的服务，只能调用Context.stopService()方法结束服务，服务结束时会调用onDestroy()方法。<br>如果打算采用Context.bindService()方法启动服务，在服务未被创建时，系统会先调用服务的onCreate()方法，接着调用onBind()方法。这个时候调用者和服务绑定在一起，调用者退出了，系统就会先调用服务的onUnbind()方法，接着调用onDestroy()方法。如果调用bindService()方法前服务已经被绑定，多次调用bindService()方法并不会导致多次创建服务及绑定(也就是说onCreate()和onBind()方法并不会被多次调用)。如果调用者希望与正在绑定的服务解除绑定，可以调用unbindService()方法，调用该方法也会导致系统调用服务的onUnbind()–&gt;onDestroy()方法。</p><h4 id="服务常用生命周期回调方法如下："><a href="#服务常用生命周期回调方法如下：" class="headerlink" title="服务常用生命周期回调方法如下："></a>服务常用生命周期回调方法如下：</h4><p>1、onCreate()该方法在服务被创建时调用，该方法只会被调用一次，无论调用多少次startService()或bindService()方法，服务也只被创建一次。<br>2、onDestroy()该方法在服务被终止时调用。<br>与采用Context.startService()方法启动服务有关的生命周期方法<br>3、onStart()只有采用Context.startService()方法启动服务时才会回调该方法。该方法在服务开始运行时被调用。多次调用startService()方法尽管不会多次创建服务，但onStart() 方法会被多次调用。<br>与采用Context.bindService()方法启动服务有关的生命周期方法<br>4、onBind()只有采用Context.bindService()方法启动服务时才会回调该方法。该方法在调用者与服务绑定时被调用，当调用者与服务已经绑定，多次调用Context.bindService()方法并不会导致该方法被多次调用。<br>5、onUnbind()只有采用Context.bindService()方法启动服务时才会回调该方法。该方法在调用者与服务解除绑定时被调用。</p><hr><p>注册广播有几种方式，这些方式有何优缺点？请谈谈Android引入广播机制的用意。</p><p>答：首先写一个类要继承BroadcastReceiver<br>第一种:在清单文件中声明,添加</p><div class="hljs"><pre><code class="hljs django"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">receive</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">".IncomingSMSReceiver "</span> &gt;</span></span><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">intent-filter</span>&gt;</span></span><span class="xml">   <span class="hljs-tag">&lt;<span class="hljs-name">action</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">"android.provider.Telephony.SMS_RECEIVED"</span>)</span></span><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">intent-filter</span>&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">receiver</span>&gt;</span></span></code></pre></div><p>第二种使用代码进行注册如:</p><div class="hljs"><pre><code class="hljs routeros">IntentFilter<span class="hljs-built_in"> filter </span>=  new IntentFilter(<span class="hljs-string">"android.provider.Telephony.SMS_RECEIVED"</span>);IncomingSMSReceiver receiver = new IncomgSMSReceiver();registerReceiver(receiver.filter);</code></pre></div><p>两种注册类型的区别是：<br>1)第一种不是常驻型广播，也就是说广播跟随程序的生命周期。<br>2)第二种是常驻型，也就是说当应用程序关闭后，如果有信息广播来，程序也会被系统调用自动运行。</p><hr><p>请解释下在单线程模型中Message、Handler、Message Queue、Looper之间的关系。</p><p>答：简单的说，Handler获取当前线程中的looper对象，looper用来从存放Message的MessageQueue中取出Message，再有Handler进行Message的分发和处理.<br>Message Queue(消息队列)：用来存放通过Handler发布的消息，通常附属于某一个创建它的线程，可以通过Looper.myQueue()得到当前线程的消息队列<br>Handler：可以发布或者处理一个消息或者操作一个Runnable，通过Handler发布消息，消息将只会发送到与它关联的消息队列，然也只能处理该消息队列中的消息<br>Looper：是Handler和消息队列之间通讯桥梁，程序组件首先通过Handler把消息传递给Looper，Looper把消息放入队列。Looper也把消息队列里的消息广播给所有的<br>Handler：Handler接受到消息后调用handleMessage进行处理<br>Message：消息的类型，在Handler类中的handleMessage方法中得到单个的消息进行处理<br>在单线程模型下，为了线程通信问题，Android设计了一个Message Queue(消息队列)， 线程间可以通过该Message Queue并结合Handler和Looper组件进行信息交换。下面将对它们进行分别介绍：</p><h4 id="1-Message"><a href="#1-Message" class="headerlink" title="1. Message"></a>1. Message</h4><p>Message消息，理解为线程间交流的信息，处理数据后台线程需要更新UI，则发送Message内含一些数据给UI线程。</p><h4 id="2-Handler"><a href="#2-Handler" class="headerlink" title="2. Handler"></a>2. Handler</h4><p>Handler处理者，是Message的主要处理者，负责Message的发送，Message内容的执行处理。后台线程就是通过传进来的Handler对象引用来sendMessage(Message)。而使用Handler，需要implement 该类的 handleMessage(Message)方法，它是处理这些Message的操作内容，例如Update UI。通常需要子类化Handler来实现handleMessage方法。</p><h4 id="3-Message-Queue"><a href="#3-Message-Queue" class="headerlink" title="3. Message Queue"></a>3. Message Queue</h4><p>Message Queue消息队列，用来存放通过Handler发布的消息，按照先进先出执行。<br>每个message queue都会有一个对应的Handler。Handler会向message queue通过两种方法发送消息：sendMessage或post。这两种消息都会插在message queue队尾并按先进先出执行。但通过这两种方法发送的消息执行的方式略有不同：通过sendMessage发送的是一个message对象,会被Handler的handleMessage()函数处理；而通过post方法发送的是一个runnable对象，则会自己执行。</p><h4 id="4-Looper"><a href="#4-Looper" class="headerlink" title="4. Looper"></a>4. Looper</h4><p>Looper是每条线程里的Message Queue的管家。Android没有Global的Message Queue，而Android会自动替主线程(UI线程)建立Message Queue，但在子线程里并没有建立Message Queue。所以调用Looper.getMainLooper()得到的主线程的Looper不为NULL，但调用Looper.myLooper()得到当前线程的Looper就有可能为NULL。对于子线程使用Looper，API Doc提供了正确的使用方法：这个Message机制的大概流程：</p><ol><li>在Looper.loop()方法运行开始后，循环地按照接收顺序取出Message Queue里面的非NULL的Message。</li><li>一开始Message Queue里面的Message都是NULL的。当Handler.sendMessage(Message)到Message Queue，该函数里面设置了那个Message对象的target属性是当前的Handler对象。随后Looper取出了那个Message，则调用该Message的target指向的Hander的dispatchMessage函数对Message进行处理。在dispatchMessage方法里，如何处理Message则由用户指定，三个判断，优先级从高到低：<br>1) Message里面的Callback，一个实现了Runnable接口的对象，其中run函数做处理工作；<br>2) Handler里面的mCallback指向的一个实现了Callback接口的对象，由其handleMessage进行处理；<br>3) 处理消息Handler对象对应的类继承并实现了其中handleMessage函数，通过这个实现的handleMessage函数处理消息。<br>由此可见，我们实现的handleMessage方法是优先级最低的！</li><li>Handler处理完该Message (update UI) 后，Looper则设置该Message为NULL，以便回收！<br>在网上有很多文章讲述主线程和其他子线程如何交互，传送信息，最终谁来执行处理信息之类的，个人理解是最简单的方法——判断Handler对象里面的Looper对象是属于哪条线程的，则由该线程来执行！</li><li>当Handler对象的构造函数的参数为空，则为当前所在线程的Looper；</li><li>Looper.getMainLooper()得到的是主线程的Looper对象，Looper.myLooper()得到的是当前线程的Looper对象。</li></ol><hr><p>说说mvc模式的原理，它在android中的运用,android的官方建议应用程序的开发采用mvc模式。何谓mvc？</p><p>mvc是model,view,controller的缩写，mvc包含三个部分：<br>模型（model）对象：是应用程序的主体部分，所有的业务逻辑都应该写在该层。<br>视图（view）对象：是应用程序中负责生成用户界面的部分。也是在整个mvc架构中用户唯一可以看到的一层，接收用户的输入，显示处理结果。<br>控制器（control）对象：是根据用户的输入，控制用户界面数据显示及更新model对象状态的部分，控制器更重要的一种导航功能，响应用户出发的相关事件，交给m层处理。<br>android鼓励弱耦合和组件的重用，在android中mvc的具体体现如下：<br>1)视图层（view）：一般采用xml文件进行界面的描述，使用的时候可以非常方便的引入，当然，如果你对android了解的比较的多了话，就一定可以想到在android中也可以使用javascript+html等的方式作为view层，当然这里需要进行java和javascript之间的通信，幸运的是，android提供了它们之间非常方便的通信实现。<br>2)控制层（controller）：android的控制层的重任通常落在了众多的acitvity的肩上，这句话也就暗含了不要在acitivity中写代码，要通过activity交割model业务逻辑层处理，这样做的另外一个原因是android中的acitivity的响应时间是5s，如果耗时的操作放在这里，程序就很容易被回收掉。<br>3)模型层（model）：对数据库的操作、对网络等的操作都应该在model里面处理，当然对业务计算等操作也是必须放在的该层的。</p><hr><p>android 中service的实现方法是：<strong><strong><em>和</em></strong></strong>。</p><p>答案：startservice和bindservice。</p><hr><p>下列程序段的输出结果是：（）</p><div class="hljs"><pre><code class="hljs angelscript"><span class="hljs-built_in">void</span> complicatedexpression_r() &#123;<span class="hljs-built_in">int</span> x = <span class="hljs-number">20</span>, y = <span class="hljs-number">30</span>;<span class="hljs-built_in">bool</span>ean b;b = x &gt; <span class="hljs-number">50</span> &amp;&amp; y &gt; <span class="hljs-number">60</span> || x &gt; <span class="hljs-number">50</span> &amp;&amp; y &lt; <span class="hljs-number">-60</span> || x &lt; <span class="hljs-number">-50</span> &amp;&amp; y &gt; <span class="hljs-number">60</span>|| x &lt; <span class="hljs-number">-50</span> &amp;&amp; y &lt; <span class="hljs-number">-60</span>;System.<span class="hljs-keyword">out</span>.println(b);&#125;A、<span class="hljs-literal">true</span>  B、<span class="hljs-literal">false</span>  C、<span class="hljs-number">1</span>  D、<span class="hljs-number">011.</span>activity</code></pre></div><p>答案：B</p><hr><p>Android中Activity, Intent, Content Provider, Service各有什么区别。</p><p>答：<br>Activity：活动，是最基本的android应用程序组件。一个活动就是一个单独的屏幕，每一个活动都被实现为一个独立的类，并且从活动基类继承而来。<br>Intent：意图，描述应用想干什么。最重要的部分是动作和动作对应的数据。<br>Content Provider：内容提供器，android应用程序能够将它们的数据保存到文件、SQLite数据库中，甚至是任何有效的设备中。当你想将你的应用数据和其他应用共享时，内容提供器就可以发挥作用了。<br>Service：服务，具有一段较长生命周期且没有用户界面的程序。</p><hr><p>什么情况会导致Force Close？如何避免？能否捕获导致其的异常？</p><p>答：程序出现异常，比如nullpointer。<br>避免：编写程序时逻辑连贯，思维缜密。能捕获异常，在logcat中能看到异常信息</p><hr><p>描述一下android的系统架构</p><p>android系统架构分从下往上为linux 内核层、运行库、应用程序框架层、和应用程序层。</p><p>linuxkernel：负责硬件的驱动程序、网络、电源、系统安全以及内存管理等功能。</p><p>libraries和 android runtime：libraries：即c/c++函数库部分，大多数都是开放源代码的函数库，例如webkit（引擎），该函数库负责 android网页浏览器的运行，例如标准的c函数库libc、openssl、sqlite等，当然也包括支持游戏开发2dsgl和 3dopengles，在多媒体方面有mediaframework框架来支持各种影音和图形文件的播放与显示，例如mpeg4、h.264、mp3、 aac、amr、jpg和png等众多的多媒体文件格式。android的runtime负责解释和执行生成的dalvik格式的字节码。</p><p>applicationframework（应用软件架构），java应用程序开发人员主要是使用该层封装好的api进行快速开发。</p><p>applications:该层是java的应用程序层，android内置的googlemaps、e-mail、即时通信工具、浏览器、mp3播放器等处于该层，java开发人员开发的程序也处于该层，而且和内置的应用程序具有平等的位置，可以调用内置的应用程序，也可以替换内置的应用程序。</p><p>上面的四个层次，下层为上层服务，上层需要下层的支持，调用下层的服务，这种严格分层的方式带来的极大的稳定性、灵活性和可扩展性，使得不同层的开发人员可以按照规范专心特定层的开发。</p><p>android应用程序使用框架的api并在框架下运行，这就带来了程序开发的高度一致性，另一方面也告诉我们，要想写出优质高效的程序就必须对整个applicationframework进行非常深入的理解。精通applicationframework，你就可以真正的理解android的设计和运行机制，也就更能够驾驭整个应用层的开发。</p><hr><p>请介绍下ContentProvider是如何实现数据共享的。</p><p>一个程序可以通过实现一个Content provider的抽象接口将自己的数据完全暴露出去，而且Content providers是以类似数据库中表的方式将数据暴露。Content providers存储和检索数据，通过它可以让所有的应用程序访问到，这也是应用程序之间唯一共享数据的方法。<br>要想使应用程序的数据公开化，可通过2种方法：创建一个属于你自己的Content provider或者将你的数据添加到一个已经存在的Content provider中，前提是有相同数据类型并且有写入Content provider的权限。<br>如何通过一套标准及统一的接口获取其他应用程序暴露的数据？<br>Android提供了ContentResolver，外界的程序可以通过ContentResolver接口访问ContentProvider提供的数据。</p><hr><p>Service和Thread的区别？</p><p>答：servie是系统的组件，它由系统进程托管（servicemanager）；它们之间的通信类似于client和server，是一种轻量级的ipc通信，这种通信的载体是binder，它是在linux层交换信息的一种ipc。而thread是由本应用程序托管。<br>1). Thread：Thread是程序执行的最小单元，它是分配CPU的基本单位。可以用 Thread 来执行一些异步的操作。<br>2). Service：Service是android的一种机制，当它运行的时候如果是Local Service，那么对应的Service是运行在主进程的main线程上的。如：onCreate，onStart 这些函数在被系统调用的时候都是在主进程的 main 线程上运行的。如果是Remote Service，那么对应的 Service 则是运行在独立进程的 main 线程上。<br>既然这样，那么我们为什么要用Service呢？其实这跟android的系统机制有关，我们先拿Thread来说。Thread的运行是独立于Activity的，也就是说当一个Activity被finish之后，如果你没有主动停止Thread或者Thread里的run方法没有执行完毕的话，Thread也会一直执行。因此这里会出现一个问题：当 Activity 被 finish 之后，你不再持有该 Thread 的引用。另一方面，你没有办法在不同的 Activity 中对同一Thread进行控制。<br>举个例子：如果你的Thread需要不停地隔一段时间就要连接服务器做某种同步的话，该Thread需要在Activity没有start的时候也在运行。这个时候当你start一个Activity就没有办法在该Activity里面控制之前创建的Thread。因此你便需要创建并启动一个Service，在Service里面创建、运行并控制该 Thread，这样便解决了该问题（因为任何 Activity 都可以控制同一Service，而系统也只会创建一个对应Service的实例）。<br>因此你可以把Service想象成一种消息服务，而你可以在任何有Context的地方调用Context.startService、Context.stopService、Context.bindService，Context.unbindService，来控制它，你也可以在Service里注册BroadcastReceiver，在其他地方通过发送broadcast来控制它，当然这些都是 Thread 做不到的。</p><hr><p>Android本身的api并未声明会抛出异常，则其在运行时有无可能抛出runtime异常，你遇到过吗？诺有的话会导致什么问题？如何解决？</p><p>答：会，比如nullpointerException。我遇到过，比如textview.setText()时，textview没有初始化。会导致程序无法正常运行出现forceclose。打开控制台查看logcat信息找出异常信息并修改程序。</p><hr><p>如果后台的Activity由于某原因被系统回收了，如何在被系统回收之前保存当前状态？</p><p>答：重写onSaveInstanceState()方法，在此方法中保存需要保存的数据，该方法将会在activity被回收之前调用。通过重写onRestoreInstanceState()方法可以从中提取保存好的数据</p><hr><p>如何将一个Activity设置成窗口的样式。</p><p>答：<activity>中配置：android :theme=”@android:style/Theme.Dialog”<br>另外android:theme=”@android:style/Theme.Translucent” 是设置透明</p><hr><p>如何退出Activity？如何安全退出已调用多个Activity的Application？</p><p>答：对于单一Activity的应用来说，退出很简单，直接finish()即可。当然，也可以用killProcess()和System.exit()这样的方法。<br>对于多个activity，1、记录打开的Activity：每打开一个Activity，就记录下来。在需要退出时，关闭每一个Activity即可。2、发送特定广播：在需要结束应用时，发送一个特定的广播，每个Activity收到广播后，关闭即可。3、递归退出：在打开新的Activity时使用startActivityForResult，然后自己加标志，在onActivityResult中处理，递归关闭。为了编程方便，最好定义一个Activity基类，处理这些共通问题。<br>在2.1之前，可以使用ActivityManager的restartPackage方法。<br>它可以直接结束整个应用。在使用时需要权限android.permission.RESTART_PACKAGES。<br>注意不要被它的名字迷惑。<br>可是，在2.2，这个方法失效了。在2.2添加了一个新的方法，killBackground Processes()，需要权限android.permission.KILL_BACKGROUND_PROCESSES。可惜的是，它和2.2的restartPackage一样，根本起不到应有的效果。<br>另外还有一个方法，就是系统自带的应用程序管理里，强制结束程序的方法，forceStopPackage()。它需要权限android.permission.FORCE_STOP_PACKAGES。并且需要添加android:sharedUserId=”android.uid.system”属性。同样可惜的是，该方法是非公开的，他只能运行在系统进程，第三方程序无法调用。<br>因为需要在Android.mk中添加LOCAL_CERTIFICATE := platform。<br>而Android.mk是用于在Android源码下编译程序用的。<br>从以上可以看出，在2.2，没有办法直接结束一个应用，而只能用自己的办法间接办到。<br>现提供几个方法，供参考：</p><h4 id="1、抛异常强制退出："><a href="#1、抛异常强制退出：" class="headerlink" title="1、抛异常强制退出："></a>1、抛异常强制退出：</h4><p>该方法通过抛异常，使程序Force Close。<br>验证可以，但是，需要解决的问题是，如何使程序结束掉，而不弹出Force Close的窗口。</p><h4 id="2、记录打开的Activity："><a href="#2、记录打开的Activity：" class="headerlink" title="2、记录打开的Activity："></a>2、记录打开的Activity：</h4><p>每打开一个Activity，就记录下来。在需要退出时，关闭每一个Activity即可。</p><h4 id="3、发送特定广播："><a href="#3、发送特定广播：" class="headerlink" title="3、发送特定广播："></a>3、发送特定广播：</h4><p>在需要结束应用时，发送一个特定的广播，每个Activity收到广播后，关闭即可。</p><h4 id="4、递归退出"><a href="#4、递归退出" class="headerlink" title="4、递归退出"></a>4、递归退出</h4><p>在打开新的Activity时使用startActivityForResult，然后自己加标志，在onActivityResult中处理，递归关闭。<br>除了第一个，都是想办法把每一个Activity都结束掉，间接达到目的。但是这样做同样不完美。你会发现，如果自己的应用程序对每一个Activity都设置了nosensor，在两个Activity结束的间隙，sensor可能有效了。但至少，我们的目的达到了，而且没有影响用户使用。为了编程方便，最好定义一个Activity基类，处理这些共通问题。</p><hr><p>AIDL的全称是什么？如何工作？能处理哪些类型的数据？</p><p>答：全称是：Android Interface Define Language<br>在Android中,每个应用程序都可以有自己的进程.在写UI应用的时候,经常要用到Service.在不同的进程中,怎样传递对象呢?显然,Java中不允许跨进程内存共享.因此传递对象,只能把对象拆分成操作系统能理解的简单形式,以达到跨界对象访问的目的.在J2EE中,采用RMI的方式,可以通过序列化传递对象. 在Android中, 则采用AIDL的方式. 理论上AIDL可以传递Bundle,实际上做起来却比较麻烦。<br>AIDL(AndRoid接口描述语言)是一种借口描述语言; 编译器可以通过aidl文件生成一段代码，通过预先定义的接口达到两个进程内部通信进程的目的. 如果需要在一个Activity中,访问另一个Service中的某个对象,需要先将对象转化成AIDL可识别的参数(可能是多个参数),然后使用AIDL来传递这些参数, 在消息的接收端, 使用这些参数组装成自己需要的对象.<br>AIDL的IPC的机制和COM或CORBA类似,是基于接口的，但它是轻量级的。它使用代理类在客户端和实现层间传递值.如果要使用AIDL,需要完成2件事情: 1. 引入AIDL的相关类.; 2. 调用aidl产生的class.</p><h4 id="AIDL的创建方法"><a href="#AIDL的创建方法" class="headerlink" title="AIDL的创建方法:"></a>AIDL的创建方法:</h4><p>AIDL语法很简单,可以用来声明一个带一个或多个方法的接口，也可以传递参数和返回值。由于远程调用的需要,这些参数和返回值并不是任何类型.下面是些AIDL支持的数据类型:</p><ol><li>不需要import声明的简单Java编程语言类型(int,boolean等)</li><li>String, CharSequence不需要特殊声明</li><li>List, Map和Parcelables类型, 这些类型内所包含的数据成员也只能是简单数据类型, String等其他比支持的类型.<br>(另外: 我没尝试Parcelables, 在Eclipse+ADT下编译不过, 或许以后会有所支持)</li></ol><hr><p>请解释下Android程序运行时权限与文件系统权限的区别。</p><p>答：运行时权限Dalvik( android授权)<br>文件系统 linux 内核授权</p><hr><p>activity一般会重载7个方法用来维护其生命周期，除了onCreate(),onStart(),onDestory()外还有<strong><strong><em>,</em></strong></strong>,<strong><strong><em>,</em></strong></strong>。</p><p>答案：onrestart,onresume,onpause,onstop</p><hr><p>对一些资源以及状态的操作保存，最好是保存在生命周期的哪个函数中进行()</p><div class="hljs"><pre><code class="hljs isbl"><span class="hljs-variable">A</span>、<span class="hljs-function"><span class="hljs-title">onPause</span>()  </span><span class="hljs-function"><span class="hljs-variable">B</span>、<span class="hljs-title">onCreate</span>()   </span><span class="hljs-function"><span class="hljs-variable">C</span>、<span class="hljs-title">onResume</span>()   </span><span class="hljs-function"><span class="hljs-variable">D</span>、<span class="hljs-title">onStart</span>()</span></code></pre></div><p>答案：D</p><hr><p>View, surfaceView, GLSurfaceView有什么区别。</p><p>答：view是最基础的，必须在UI主线程内更新画面，速度较慢。<br>SurfaceView 是view的子类，类似使用双缓机制，在新的线程中更新画面所以刷新界面速度比view快。<br>GLSurfaceView 是SurfaceView的子类，opengl 专用的。</p><hr><p>系统上安装了多种浏览器，能否指定某浏览器访问指定页面？请说明原由。</p><p>通过直接发送Uri把参数带过去，或者通过manifest里的intentfilter里的data属性</p><hr><p>android系统的优势和不足</p><p>答：Android平台手机 5大优势：</p><h4 id="一、开放性"><a href="#一、开放性" class="headerlink" title="一、开放性"></a>一、开放性</h4><p>在优势方面，Android平台首先就是其开发性，开发的平台允许任何移动终端厂商加入到Android联盟中来。显著的开放性可以使其拥有更多的开发者，随着用户和应用的日益丰富，一个崭新的平台也将很快走向成熟。开放性对于Android的发展而言，有利于积累人气，这里的人气包括消费者和厂商，而对于消费者来讲，随大的受益正是丰富的软件资源。开放的平台也会带来更大竞争，如此一来，消费者将可以用更低的价位购得心仪的手机。</p><h4 id="二、挣脱运营商的束缚"><a href="#二、挣脱运营商的束缚" class="headerlink" title="二、挣脱运营商的束缚"></a>二、挣脱运营商的束缚</h4><p>在过去很长的一段时间，特别是在欧美地区，手机应用往往受到运营商制约，使用什么功能接入什么网络，几乎都受到运营商的控制。从去年iPhone上市，用户可以更加方便地连接网络，运营商的制约减少。随着EDGE、HSDPA这些2G至3G移动网络的逐步过渡和提升，手机随意接入网络已不是运营商口中的笑谈，当你可以通过手机IM软件方便地进行即时聊天时，再回想不久前天价的彩信和图铃下载业务，是不是像噩梦一样？互联网巨头Google推动的Android终端天生就有网络特色，将让用户离互联网更近。</p><h4 id="三、丰富的硬件选择"><a href="#三、丰富的硬件选择" class="headerlink" title="三、丰富的硬件选择"></a>三、丰富的硬件选择</h4><p>这一点还是与Android平台的开放性相关，由于Android的开放性，众多的厂商会推出千奇百怪，功能特色各具的多种产品。功能上的差异和特色，却不会影响到数据同步、甚至软件的兼容，好比你从诺基亚 Symbian风格手机 一下改用苹果 iPhone ，同时还可将Symbian中优秀的软件带到iPhone上使用、联系人等资料更是可以方便地转移，是不是非常方便呢？</p><h4 id="四、不受任何限制的开发商"><a href="#四、不受任何限制的开发商" class="headerlink" title="四、不受任何限制的开发商"></a>四、不受任何限制的开发商</h4><p>Android平台提供给第三方开发商一个十分宽泛、自由的环境，不会受到各种条条框框的阻扰，可想而知，会有多少新颖别致的软件会诞生。但也有其两面性，血腥、暴力、情色方面的程序和游戏如可控制正是留给Android难题之一。<br>五、无缝结合的Google应用<br>如今叱诧互联网的Google已经走过10年度历史，从搜索巨人到全面的互联网渗透，Google服务如地图、邮件、搜索等已经成为连接用户和互联网的重要纽带，而Android平台手机将无缝结合这些优秀的Google服务。<br>再说Android的5大不足：</p><h4 id="一、安全和隐私"><a href="#一、安全和隐私" class="headerlink" title="一、安全和隐私"></a>一、安全和隐私</h4><p>由于手机与互联网的紧密联系，个人隐私很难得到保守。除了上网过程中经意或不经意留下的个人足迹，Google这个巨人也时时站在你的身后，洞穿一切，因此，互联网的深入将会带来新一轮的隐私危机。</p><h4 id="二、首先开卖Android手机的不是最大运营商"><a href="#二、首先开卖Android手机的不是最大运营商" class="headerlink" title="二、首先开卖Android手机的不是最大运营商"></a>二、首先开卖Android手机的不是最大运营商</h4><p>众所周知，T-Mobile在23日，于美国纽约发布了Android首款手机G1。但是在北美市场，最大的两家运营商乃AT&amp;T和Verizon，而目前所知取得Android手机销售权的仅有T-Mobile和Sprint，其中T-Mobile的3G网络相对于其他三家也要逊色不少，因此，用户可以买账购买G1，能否体验到最佳的3G网络服务则要另当别论了！</p><h4 id="三、运营商仍然能够影响到Android手机"><a href="#三、运营商仍然能够影响到Android手机" class="headerlink" title="三、运营商仍然能够影响到Android手机"></a>三、运营商仍然能够影响到Android手机</h4><p>在国内市场，不少用户对购得移动定制机不满，感觉所购的手机被人涂画了广告一般。这样的情况在国外市场同样出现。Android手机的另一发售运营商Sprint就将在其机型中内置其手机商店程序。</p><h4 id="四、同类机型用户减少"><a href="#四、同类机型用户减少" class="headerlink" title="四、同类机型用户减少"></a>四、同类机型用户减少</h4><p>在不少手机论坛都会有针对某一型号的子论坛，对一款手机的使用心得交流，并分享软件资源。而对于Android平台手机，由于厂商丰富，产品类型多样，这样使用同一款机型的用户越来越少，缺少统一机型的程序强化。举个稍显不当的例子，现在山寨机泛滥，品种各异，就很少有专门针对某个型号山寨机的讨论和群组，除了哪些功能异常抢眼、颇受追捧的机型以外。</p><h4 id="五、过分依赖开发商缺少标准配置"><a href="#五、过分依赖开发商缺少标准配置" class="headerlink" title="五、过分依赖开发商缺少标准配置"></a>五、过分依赖开发商缺少标准配置</h4><p>在使用PC端的Windows Xp系统的时候，都会内置微软Windows Media Player这样一个浏览器程序，用户可以选择更多样的播放器，如Realplay或暴风影音等。但入手开始使用默认的程序同样可以应付多样的需要。在Android平台中，由于其开放性，软件更多依赖第三方厂商，比如Android系统的SDK中就没有内置音乐播放器，全部依赖第三方开发，缺少了产品的统一性。</p><hr><p>DDMS和TraceView的区别?</p><p>DDMS是一个程序执行查看器，在里面可以看见线程和堆栈等信息，TraceView是程序性能分析器 。</p><hr><p>java中如何引用本地语言</p><p>可以用JNI（java native interface java本地接口）接口 。</p><hr><p>谈谈Android的IPC（进程间通信）机制</p><p>IPC是内部进程通信的简称，是共享”命名管道”的资源。Android中的IPC机制是为了让Activity和Service之间可以随时的进行交互，故在Android中该机制，只适用于Activity和Service之间的通信，类似于远程方法调用，类似于C/S模式的访问。通过定义AIDL接口文件来定义IPC接口。Servier端实现IPC接口，Client端调用IPC接口本地代理。</p><hr><p>NDK是什么</p><p>NDK是一些列工具的集合，NDK提供了一系列的工具，帮助开发者迅速的开发C/C++的动态库，并能自动将so和java 应用打成apk包。<br>NDK集成了交叉编译器，并提供了相应的mk文件和隔离cpu、平台等的差异，开发人员只需简单的修改mk文件就可以创建出so</p><hr><p>android的数据存储的方式<strong><strong><em>,</em></strong></strong>,<strong><strong><em>,</em></strong></strong>,_____。</p><p>答案：sharedpreference,文件,SQlite,contentprovider,网络</p><hr><p>Intent传递数据时，下列的数据类型哪些可以被传递（）(多选)</p><div class="hljs"><pre><code class="hljs armasm">A、Serializable  <span class="hljs-keyword">B、charsequence </span> C、Parcelable  D、<span class="hljs-keyword">Bundle</span></code></pre></div><p>答案：ABCD</p><hr><p>Adapter有什么作用？常见的Adapter有哪些？</p><p>答：Adapter是连接后端数据和前端显示的适配器接口。常见的Adapter有ArrayAdapter, BaseAdapter, CursorAdapter, HeaderViewListAdapter, ListAdapter, ResourceCursorAdapter, SimpleAdapter, SimpleCursorAdapter, SpinnerAdapter, WrapperListAdapter等</p><hr><p>当启动一个Activity并且新的Activity执行完后需要返回到启动它的Activity来执行 的回调函数是_____。</p><p>答案：startActivityResult()</p><hr><p>android 中下列属于Intent的作用的是()</p><div class="hljs"><pre><code class="hljs armasm">A、实现应用程序间的数据共享<span class="hljs-keyword">B、是一段长的生命周期，没有用户界面的程序，可以保持应用在后台运行，而不会因为切换页面而消失</span><span class="hljs-keyword">C、可以实现界面间的切换，可以包含动作和动作数据，连接四大组件的纽带</span><span class="hljs-keyword">D、处理一个应用程序整体性的工作</span></code></pre></div><p>答案：C</p><hr><p>Manifest.xml文件中主要包括哪些信息？</p><p>答：manifest：根节点，描述了package中所有的内容。<br>uses-permission：请求你的package正常运作所需赋予的安全许可。<br>permission：声明了安全许可来限制哪些程序能你package中的组件和功能。<br>instrumentation：声明了用来测试此package或其他package指令组件的代码。<br>application：包含package中application级别组件声明的根节点。<br>activity：Activity是用来与用户交互的主要工具。<br>receiver：IntentReceiver能使的application获得数据的改变或者发生的操作，即使它当前不在运行。<br>service：Service是能在后台运行任意时间的组件。<br>provider：ContentProvider是用来管理持久化数据并发布给其他应用程序使用的组件。</p><hr><p>请使用命令行的方式创建一个名字为myAvd,sdk版本为2.2,sd卡是在d盘的根目录下,名字为scard.img，并指定屏幕大小HVGA.<strong><strong><strong><strong><strong><strong><strong><strong>____</strong></strong></strong></strong></strong></strong></strong></strong>。</p><p>答案：adnroid create acd -n myAvd -t 8 -s HVDA - C d:\card.img</p><hr><p>下列属于SAX解析xml文件的优点的是()</p><div class="hljs"><pre><code class="hljs armasm">A、将整个文档树在内存中，便于操作，支持删除，修改，重新排列等多种功能<span class="hljs-keyword">B、不用事先调入整个文档，占用资源少</span><span class="hljs-keyword">C、整个文档调入内存，浪费时间和空间</span><span class="hljs-keyword">D、不是长久驻留在内存，数据不是持久的，事件过后，若没有保存数据，数据就会消失</span></code></pre></div><p>答案：B</p><hr><p>根据自己的理解描述下Android数字签名。</p><p>答：(1)所有的应用程序都必须有数字证书，Android系统不会安装一个没有数字证书的应用程序。<br>(2)Android程序包使用的数字证书可以是自签名的，不需要一个权威的数字证书机构签名认证。<br>(3)如果要正式发布一个Android，必须使用一个合适的私钥生成的数字证书来给程序签名，而不能使用adt插件或者ant工具生成的调试证书来发布。<br>(4)数字证书都是有有效期的，Android只是在应用程序安装的时候才会检查证书的有效期。如果程序已经安装在系统中，即使证书过期也不会影响程序的正常功能。</p><hr><p>程序运行的结果是：<strong><strong>__</strong></strong>。</p><div class="hljs"><pre><code class="hljs processing"><span class="hljs-keyword">public</span> class Example &#123;<span class="hljs-keyword">String</span> <span class="hljs-built_in">str</span> = <span class="hljs-keyword">new</span> <span class="hljs-keyword">String</span>(<span class="hljs-string">"good"</span>);<span class="hljs-built_in">char</span>[] ch = &#123; <span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span> &#125;;<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> main(<span class="hljs-keyword">String</span> args[]) &#123;Example ex = <span class="hljs-keyword">new</span> Example();ex.change(ex.<span class="hljs-built_in">str</span>, ex.ch);System.out.<span class="hljs-built_in">print</span>(ex.<span class="hljs-built_in">str</span> + <span class="hljs-string">" and "</span>);Sytem.out.<span class="hljs-built_in">print</span>(ex.ch);&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> change(<span class="hljs-keyword">String</span> <span class="hljs-built_in">str</span>, <span class="hljs-built_in">char</span> ch[]) &#123;<span class="hljs-built_in">str</span> = <span class="hljs-string">"test ok"</span>;ch[<span class="hljs-number">0</span>] = <span class="hljs-string">'g'</span>;&#125;&#125;</code></pre></div><p>答案：good and gbc</p><hr><p>下面的对自定style的方式正确的是（）</p><div class="hljs"><pre><code class="hljs xml">A、<span class="hljs-tag">&lt;<span class="hljs-name">resources</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"myStyle"</span>&gt;</span><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"android:layout_width"</span>&gt;</span>fill_parent<span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">resources</span>&gt;</span>B、<span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"myStyle"</span>&gt;</span><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"android:layout_width"</span>&gt;</span>fill_parent<span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>C、<span class="hljs-tag">&lt;<span class="hljs-name">resources</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"android:layout_width"</span>&gt;</span>fill_parent<span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">resources</span>&gt;</span>D、<span class="hljs-tag">&lt;<span class="hljs-name">resources</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"android:layout_width"</span>&gt;</span>fill_parent<span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">resources</span>&gt;</span></code></pre></div><p>答案：A</p><hr><p>Android dvm的进程和Linux的进程，应用程序的进程是否为同一个概念？</p><p>答：DVM指dalivk的虚拟机。每一个Android应用程序都在它自己的进程中运行，都拥有一个独立的Dalvik虚拟机实例。而每一个DVM都是在Linux中的一个进程，所以说可以认为是同一个概念。</p><hr>]]></content>
    
    
    
    <tags>
      
      <tag>Android</tag>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>蒲公英</title>
    <link href="/2017/07/23/%E8%92%B2%E5%85%AC%E8%8B%B1/"/>
    <url>/2017/07/23/%E8%92%B2%E5%85%AC%E8%8B%B1/</url>
    
    <content type="html"><![CDATA[<blockquote><p>作者：往昔</p></blockquote><p>(请你注意一下你家门前的那颗蒲公英，它可能是你前世  前世……的爱人，它想你默默地倾诉着对你的爱）                     </p><a id="more"></a><p>我愿化作一颗蒲公英<br>每天开出鲜艳的花朵<br>向你倾诉我对你的爱<br>你每天从门前静静地走过<br>连看也不看我一眼<br>随着时光的流逝<br>花朵渐渐的残败<br>但，我仍然充满希望<br>每天苦苦地哀求  哀求  哀求……<br>终于有一天<br>我对你的爱化作一粒粒种子<br>飘到了你的身旁   你的身上<br>你轻轻地把他拍下<br>爱的种子慢慢地  慢慢地   慢慢地  落地<br>“砰”那是我心碎的声音<br>血不停地流淌  流淌  流淌……<br>我渐渐地死去  死去  死去…… </p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>文件中的字符查找算法比较</title>
    <link href="/2017/07/17/%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%E5%AD%97%E7%AC%A6%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95%E6%AF%94%E8%BE%83/"/>
    <url>/2017/07/17/%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%E5%AD%97%E7%AC%A6%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95%E6%AF%94%E8%BE%83/</url>
    
    <content type="html"><![CDATA[<p>最近发现项目中的NanoHttpD对于文件上传的处理相当慢，于是我在排查一些耗时的操作。当然，对于文件的读写操作带来的耗时是无法避免的。</p><a id="more"></a><p>首先，文件上传的处理需要使用IHTTPSession#parseBody()进行request的解码，主要的耗时操作也是发生在这个操作里边。<br>通过阅读代码，我发现parseBody()会先把整个request缓存到文件中，然后查找boundary，然后进行request的分割，最好存储到文件里去。<br>这样就会产生大量的io操作，这个也是速度慢的主要原因。<br>经过我的排查，我发现查找boundary的代码有过更新，当我使用新的getBoundaryPositions()，发现速度竟然提升了10倍左右，不禁吓的我贴出源码，以待日后学习、比较。</p><blockquote><p>旧版代码</p></blockquote><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Find the byte positions where multipart boundaries start.</span><span class="hljs-comment"> */</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] getBoundaryPositions(ByteBuffer b, <span class="hljs-keyword">byte</span>[] boundary) &#123;    <span class="hljs-keyword">int</span> matchcount = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> matchbyte = -<span class="hljs-number">1</span>;    List&lt;Integer&gt; matchbytes = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; b.limit(); i++) &#123;        <span class="hljs-keyword">if</span> (b.get(i) == boundary[matchcount]) &#123;            <span class="hljs-keyword">if</span> (matchcount == <span class="hljs-number">0</span>)                matchbyte = i;            matchcount++;            <span class="hljs-keyword">if</span> (matchcount == boundary.length) &#123;                matchbytes.add(matchbyte);                matchcount = <span class="hljs-number">0</span>;                matchbyte = -<span class="hljs-number">1</span>;            &#125;        &#125; <span class="hljs-keyword">else</span> &#123;            i -= matchcount;            matchcount = <span class="hljs-number">0</span>;            matchbyte = -<span class="hljs-number">1</span>;        &#125;    &#125;    <span class="hljs-keyword">int</span>[] ret = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[matchbytes.size()];    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; ret.length; i++) &#123;        ret[i] = matchbytes.get(i);    &#125;    <span class="hljs-keyword">return</span> ret;&#125;</code></pre></div><blockquote><p>新版代码</p></blockquote><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Find the byte positions where multipart boundaries start.</span><span class="hljs-comment"> */</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] getBoundaryPositions(ByteBuffer b, <span class="hljs-keyword">byte</span>[] boundary) &#123;    <span class="hljs-keyword">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">0</span>];    <span class="hljs-keyword">if</span> (b.remaining() &lt; boundary.length) &#123;        <span class="hljs-keyword">return</span> res;    &#125;    <span class="hljs-keyword">int</span> search_window_pos = <span class="hljs-number">0</span>;    <span class="hljs-keyword">byte</span>[] search_window = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">4</span> * <span class="hljs-number">1024</span> + boundary.length];    <span class="hljs-keyword">int</span> first_fill = (b.remaining() &lt; search_window.length) ? b.remaining() : search_window.length;    b.get(search_window, <span class="hljs-number">0</span>, first_fill);    <span class="hljs-keyword">int</span> new_bytes = first_fill - boundary.length;    <span class="hljs-keyword">do</span> &#123;        <span class="hljs-comment">// Search the search_window</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; new_bytes; j++) &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; boundary.length; i++) &#123;                <span class="hljs-keyword">if</span> (search_window[j + i] != boundary[i])                    <span class="hljs-keyword">break</span>;                <span class="hljs-keyword">if</span> (i == boundary.length - <span class="hljs-number">1</span>) &#123;                    <span class="hljs-comment">// Match found, add it to results</span>                    <span class="hljs-keyword">int</span>[] new_res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[res.length + <span class="hljs-number">1</span>];                    System.arraycopy(res, <span class="hljs-number">0</span>, new_res, <span class="hljs-number">0</span>, res.length);                    new_res[res.length] = search_window_pos + j;                    res = new_res;                &#125;            &#125;        &#125;        search_window_pos += new_bytes;        <span class="hljs-comment">// Copy the end of the buffer to the start</span>        System.arraycopy(search_window, search_window.length - boundary.length, search_window, <span class="hljs-number">0</span>, boundary.length);        <span class="hljs-comment">// Refill search_window</span>        new_bytes = search_window.length - boundary.length;        new_bytes = (b.remaining() &lt; new_bytes) ? b.remaining() : new_bytes;        b.get(search_window, boundary.length, new_bytes);    &#125; <span class="hljs-keyword">while</span> (new_bytes &gt; <span class="hljs-number">0</span>);    <span class="hljs-keyword">return</span> res;&#125;</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一个牛B的网站:toptal.com</title>
    <link href="/2017/07/08/%E4%B8%80%E4%B8%AA%E7%89%9BB%E7%9A%84%E7%BD%91%E7%AB%99-toptal-com/"/>
    <url>/2017/07/08/%E4%B8%80%E4%B8%AA%E7%89%9BB%E7%9A%84%E7%BD%91%E7%AB%99-toptal-com/</url>
    
    <content type="html"><![CDATA[<p>主页:<a href="https://www.toptal.com/" target="_blank" rel="noopener">www.toptal.com</a><br>排序算法动画:<a href="https://www.toptal.com/developers/sorting-algorithms/" target="_blank" rel="noopener">Sorting Algorithms Animations</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>网站搜罗</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android Studio设置备份</title>
    <link href="/2017/06/30/Android-Studio%E8%AE%BE%E7%BD%AE%E5%A4%87%E4%BB%BD/"/>
    <url>/2017/06/30/Android-Studio%E8%AE%BE%E7%BD%AE%E5%A4%87%E4%BB%BD/</url>
    
    <content type="html"><![CDATA[<p><a href="files/android_studio_settings.jar">android_studio_settings.jar</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>分享几则Android面试题</title>
    <link href="/2017/06/03/%E5%88%86%E4%BA%AB%E5%87%A0%E5%88%99Android%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <url>/2017/06/03/%E5%88%86%E4%BA%AB%E5%87%A0%E5%88%99Android%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>我表示第一个就答不上来</p><a id="more"></a><h2 id="同事分享的面试题"><a href="#同事分享的面试题" class="headerlink" title="同事分享的面试题"></a>同事分享的面试题</h2><blockquote><ol><li>Activity建立在哪些窗口组件之上？顺带涉及View的事件传递问题。</li><li>什么情况下，Activity的onNewInstent()方法会执行？Activity的启动模式相关。</li><li>Activity A使用startForResult启动Activity B，B什么都不做并返回A，A中的onActivityResult回调是否会执行？</li><li>Fragment能否不依赖于Activity存在？简析一下Fragment的栈管理。</li><li>能否将一个Activity放到系统的最近任务列表里，独立于宿主app任务卡之外？</li><li>对于同一个Service，在被start启动之后还能不能被bind？</li><li>Service有哪些派生类？这些派生类的使用场景是什么？</li><li>Service与其它组件之间的通信实现方式有哪些？</li><li>View的post(Runnable r)方法里，r会带来一个新的线程吗？多线程相关。</li><li>在非UI线程中使用Handler需要注意哪些问题？</li><li>自定义View时有哪些重要的方法，它们的作用及执行顺序是怎样的？</li><li>如何单独对ListView上的一个item进行更新？</li><li>简析一下大图片的加载处理。</li><li>设计师只给了一套1280*800的UI图标注，如何进行其它分辨率尺寸屏幕的适配？</li><li>6.0系统新权限机制的解决方案。 你们精通的开源框架，问题来了</li><li>EventBus的机制是什么？和Handler的区别怎样？</li><li>RxJava的机制是什么？</li><li>Butterknife的机制是什么？</li><li>Okhttp是基于HTTP连接还是Socket连接？</li></ol></blockquote><h2 id="小米的面试题"><a href="#小米的面试题" class="headerlink" title="小米的面试题"></a>小米的面试题</h2><blockquote><ol><li>设计模式</li><li>线程池</li><li>同步方法和同步代码块区别</li><li>handler源码</li><li>handler looper thread三者对应关系，（一对一还是其他答案）</li><li>动画有几种</li><li>属性动画的具体实现</li><li>对用自定义控件的自定义属性的属性动画</li><li>view事件传播机制</li><li>自定义view</li><li>IPC</li><li>堆排序</li><li>RxJava</li><li>okhttp</li><li>mediaPlayer和mediaService关系</li><li>OOM</li><li>内存泄漏</li><li>如何判断WiFi的性能</li><li>如何解决工厂环境下测试GPS的问题，工厂环境下GPS可能无法使用，如何判断GPS模块的好坏</li></ol></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>Android</tag>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>解决了一个困扰了我一年的bug</title>
    <link href="/2017/06/01/%E8%A7%A3%E5%86%B3%E4%BA%86%E4%B8%80%E4%B8%AA%E5%9B%B0%E6%89%B0%E4%BA%86%E6%88%91%E4%B8%80%E5%B9%B4%E7%9A%84bug/"/>
    <url>/2017/06/01/%E8%A7%A3%E5%86%B3%E4%BA%86%E4%B8%80%E4%B8%AA%E5%9B%B0%E6%89%B0%E4%BA%86%E6%88%91%E4%B8%80%E5%B9%B4%E7%9A%84bug/</url>
    
    <content type="html"><![CDATA[<p>这件事情就说来话长了。</p><a id="more"></a><p>记得那是一年前，我被安排去做一个OpenGL相关的任务，就是做一个动画，但是这个动画比较重要，是主要交互界面的背景，我们一般称这个动画为”粒子系统“。</p><p>动画被搞出来了，也优化了好久。但是一直有一个问题，就是用一段时间后就会卡死，整个界面都不能动了。包括我在内，大家都认为是粒子系统的问题。但是又苦于没有找到可以优化的点，这件事就一直被搁置。</p><p>那时候就有一个奇怪的现象，就是我的这套”粒子系统“，用在另一个项目上就没有什么问题，我当时也很费解，感觉可能不是粒子系统导致的界面卡死，而是其他原因。但是有说不清楚这个”其他原因“是什么，所以还是我的问题。</p><p>终于！哈哈，请允许我笑下。我发现”粒子系统崩溃“时有个奇怪的现象，就是整个app都无法进行数据库的操作，通过进一步的观察好像是整个app都无法进行文件读取操作，而且读文件时有个异常：EMFILE (Too many open files)。当时我就想:会不会是这个异常导致我的粒子系统崩溃，而不是我的粒子系统导致的这个异常。接着，我逐渐证实了我的想法。<br>接着我开始接触一系列的概念，”文件描述符“、”ulimit“、”lsof“，紧接着我看到了一篇博客<a href="http://blog.csdn.net/tencent_bugly/article/details/46276485" target="_blank">论File Descriptor泄漏如何导致Crash？</a>看完这个，我更加确信自己的想法。没错，这个困扰了我一年的bug，我终于逮到你了！！！</p><div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 查看进程ID</span>ps | grep 包名<span class="hljs-meta">#</span><span class="bash"> lsof（list open files）是一个列出当前系统打开文件的工具</span><span class="hljs-meta">#</span><span class="bash"> 这个命令可以查看App打开的文件</span>lsof | grep 包名 | grep 进程ID<span class="hljs-meta">#</span><span class="bash"> 这个命令可以查看App打开的文件数，默认的最大文件数为1024， busybox是一个工具集</span>lsof | grep 包名 | grep 进程ID | busybox wc -l</code></pre></div><p>一般造成此类的原因是文件open后没有close，或者使用了FileDescriptor没有close。</p><p>通过以上排查发现是我们用的Spotify player的问题，我们用的那个版本为1.0.0-beta12，通过lsof观察，只要spotify播放，打开的文件数就一直在增加。今天我通过升级sdk解决了这个问题。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Android</tag>
      
      <tag>shell</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2017的下半年</title>
    <link href="/2017/05/29/2017%E7%9A%84%E4%B8%8B%E5%8D%8A%E5%B9%B4/"/>
    <url>/2017/05/29/2017%E7%9A%84%E4%B8%8B%E5%8D%8A%E5%B9%B4/</url>
    
    <content type="html"><![CDATA[<p>下半年要做的事。</p><a id="more"></a><ol><li>健身增重</li><li>看书</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>计划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>分享一个正则表达式</title>
    <link href="/2017/05/22/%E5%88%86%E4%BA%AB%E4%B8%80%E4%B8%AA%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <url>/2017/05/22/%E5%88%86%E4%BA%AB%E4%B8%80%E4%B8%AA%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p>这几天搞国际版的App，怕自己对于strings的抽取完不完全，于是想搜索一下项目中(除了en/strings.xml外)有没有一些中文字符。</p><p>主要有以下几点：</p><ol><li>Logger中的中文不用考虑</li><li>匹配双引号中的中文</li><li>中文可能在开头、中间、结尾，即包含中文的都要匹配</li></ol><p>以下是正则表达式</p><div class="hljs"><pre><code class="hljs scheme">(<span class="hljs-name">^</span>(<span class="hljs-name">?!.*Logger</span>).*)(\<span class="hljs-string">".*([\u4e00-\u9fa5]).*\")</span></code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>Android</tag>
      
      <tag>正则</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android应用内切换语言</title>
    <link href="/2017/05/21/Android%E5%BA%94%E7%94%A8%E5%86%85%E5%88%87%E6%8D%A2%E8%AF%AD%E8%A8%80/"/>
    <url>/2017/05/21/Android%E5%BA%94%E7%94%A8%E5%86%85%E5%88%87%E6%8D%A2%E8%AF%AD%E8%A8%80/</url>
    
    <content type="html"><![CDATA[<p>现在我们开发了一个英文版的App，为了测试英文版，经常需要把手机系统语言设置为英文。为了避免这个麻烦，我想在应用内添加一个切换语言的功能，核心代码如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">changeLanguage</span><span class="hljs-params">(Locale locale)</span> </span>&#123;Locale.setDefault(locale);Resources resources = getResources();android.content.res.Configuration config = resources.getConfiguration();DisplayMetrics dm = resources.getDisplayMetrics();config.locale = locale;resources.updateConfiguration(config, dm);&#125;</code></pre></div><p>以下代码是重新启动App</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">restartApp</span><span class="hljs-params">()</span> </span>&#123;    changeLanguage();    Intent i = getBaseContext().getPackageManager()            .getLaunchIntentForPackage(getBaseContext().getPackageName());    i.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);    startActivity(i);&#125;</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java关键字transient和volatile</title>
    <link href="/2017/04/26/Java%E5%85%B3%E9%94%AE%E5%AD%97transient%E5%92%8Cvolatile/"/>
    <url>/2017/04/26/Java%E5%85%B3%E9%94%AE%E5%AD%97transient%E5%92%8Cvolatile/</url>
    
    <content type="html"><![CDATA[<p>transient和volatile两个关键字一个用于对象序列化，一个用于线程同步，都是Java中比较高阶的话题，简单总结一下。</p><a id="more"></a><h2 id="transient"><a href="#transient" class="headerlink" title="transient"></a>transient</h2><p>transient是类型修饰符，只能用来修饰字段。在对象序列化的过程中，标记为transient的变量不会被序列化。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<span class="hljs-keyword">transient</span> <span class="hljs-keyword">int</span> a; <span class="hljs-comment">// 不会被持久化</span><span class="hljs-keyword">int</span> b; <span class="hljs-comment">// 持久化</span>&#125;</code></pre></div><p>当类Test的实例对象被序列化（比如将Test类的实例对象 t 写入硬盘的文本文件t.txt中），变量 a 的内容不会被保存，变量 b 的内容则会被保存。</p><blockquote><p>参考：把一个对象的表示转化为字节流的过程称为串行化（也称为序列化，serialization），从字节流中把对象重建出来称为反串行化（也称为为反序列化，deserialization）。transient 为不应被串行化的数据提供了一个语言级的标记数据方法。</p></blockquote><h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><p>volatile也是变量修饰符，只能用来修饰变量。volatile修饰的成员变量在每次被线程访问时，都强迫从共享内存中重读该成员变量的值。而且，当成员变量发生变化时，强迫线程将变化值回写到共享内存。这样在任何时刻，两个不同的线程总是看到某个成员变量的同一个值。</p><p>在此解释一下Java的内存机制：</p><blockquote><p>Java使用一个主内存来保存变量当前值，而每个线程则有其独立的工作内存。线程访问变量的时候会将变量的值拷贝到自己的工作内存中，这样，当线程对自己工作内存中的变量进行操作之后，就造成了工作内存中的变量拷贝的值与主内存中的变量值不同。</p></blockquote><blockquote><p>Java语言规范中指出：为了获得最佳速度，允许线程保存共享成员变量的私有拷贝，而且只当线程进入或者离开同步代码块时才与共享成员变量的原始值对比。</p></blockquote><p>这样当多个线程同时与某个对象交互时，就必须要注意到要让线程及时的得到共享成员变量的变化。</p><p>而volatile关键字就是提示VM：对于这个成员变量不能保存它的私有拷贝，而应直接与共享成员变量交互。</p><blockquote><p>使用建议：在两个或者更多的线程访问的成员变量上使用volatile。当要访问的变量已在synchronized代码块中，或者为常量时，不必使用。</p></blockquote><p>由于使用volatile屏蔽掉了VM中必要的代码优化，所以在效率上比较低，因此一定在必要时才使用此关键字。</p>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式</title>
    <link href="/2017/04/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <url>/2017/04/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p>转载自：<a href="http://blog.csdn.net/zhangerqing" target="_blank" rel="noopener">http://blog.csdn.net/zhangerqing</a></p><blockquote><p>可复用面向对象软件的基础</p></blockquote><a id="more"></a><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>设计模式（Design pattern）是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性。 毫无疑问，设计模式于己于他人于系统都是多赢的，设计模式使代码编制真正工程化，设计模式是软件工程的基石，如同大厦的一块块砖石一样。项目中合理的运用设计模式可以完美的解决很多问题，每种模式在现在中都有相应的原理来与之对应，每一个模式描述了一个在我们周围不断重复发生的问题，以及该问题的核心解决方案，这也是它能被广泛应用的原因。本章系Java之美[从菜鸟到高手演变]系列之设计模式，我们会以理论与实践相结合的方式来进行本章的学习，希望广大程序爱好者，学好设计模式，做一个优秀的软件工程师！</p><h2 id="设计模式的分类"><a href="#设计模式的分类" class="headerlink" title="设计模式的分类"></a>设计模式的分类</h2><p>总体来说设计模式分为三大类：</p><ul><li>创建型模式，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。</li><li>结构型模式，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。</li><li>行为型模式，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。</li><li>其实还有两类：并发型模式和线程池模式。用一个图片来整体描述一下：<img src="http://img.my.csdn.net/uploads/201211/29/1354152786_2930.jpg" srcset="/img/loading.gif" alt="..."></li></ul><h2 id="设计模式的六大原则"><a href="#设计模式的六大原则" class="headerlink" title="设计模式的六大原则"></a>设计模式的六大原则</h2><ul><li><p>1、开闭原则（Open Close Principle）<br>开闭原则就是说对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。所以一句话概括就是：为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类，后面的具体设计中我们会提到这点。</p></li><li><p>2、里氏代换原则（Liskov Substitution Principle）<br>里氏代换原则(Liskov Substitution Principle LSP)面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。 LSP是继承复用的基石，只有当衍生类可以替换掉基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。里氏代换原则是对“开-闭”原则的补充。实现“开-闭”原则的关键步骤就是抽象化。而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。—— From Baidu 百科</p></li><li><p>3、依赖倒转原则（Dependence Inversion Principle）<br>这个是开闭原则的基础，具体内容：真对接口编程，依赖于抽象而不依赖于具体。</p></li><li><p>4、接口隔离原则（Interface Segregation Principle）<br>这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。还是一个降低类之间的耦合度的意思，从这儿我们看出，其实设计模式就是一个软件的设计思想，从大型软件架构出发，为了升级和维护方便。所以上文中多次出现：降低依赖，降低耦合。</p></li><li><p>5、迪米特法则（最少知道原则）（Demeter Principle）<br>为什么叫最少知道原则，就是说：一个实体应当尽量少的与其他实体之间发生相互作用，使得系统功能模块相对独立。</p></li><li><p>6、合成复用原则（Composite Reuse Principle）<br>原则是尽量使用合成/聚合的方式，而不是使用继承。</p></li></ul><h2 id="Java的23中设计模式"><a href="#Java的23中设计模式" class="headerlink" title="Java的23中设计模式"></a>Java的23中设计模式</h2><p>从这一块开始，我们详细介绍Java中23种设计模式的概念，应用场景等情况，并结合他们的特点及设计模式的原则进行分析。</p><h3 id="工厂方法模式（Factory-Method）"><a href="#工厂方法模式（Factory-Method）" class="headerlink" title="工厂方法模式（Factory Method）"></a>工厂方法模式（Factory Method）</h3><p>工厂方法模式分为三种：</p><h4 id="普通工厂模式"><a href="#普通工厂模式" class="headerlink" title="普通工厂模式"></a>普通工厂模式</h4><p>普通工厂模式，就是建立一个工厂类，对实现了同一接口的一些类进行实例的创建。首先看下关系图：<br><img src="http://img.my.csdn.net/uploads/201211/29/1354156868_1191.PNG" srcset="/img/loading.gif"></p><p>举例如下：（我们举一个发送邮件和短信的例子）<br>首先，创建二者的共同接口：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Sender</span> </span>&#123;      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Send</span><span class="hljs-params">()</span></span>;  &#125;</code></pre></div><p>其次，创建实现类：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MailSender</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Sender</span> </span>&#123;      <span class="hljs-meta">@Override</span>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Send</span><span class="hljs-params">()</span> </span>&#123;          System.out.println(<span class="hljs-string">"this is mailsender!"</span>);      &#125;  &#125;</code></pre></div><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SmsSender</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Sender</span> </span>&#123;        <span class="hljs-meta">@Override</span>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Send</span><span class="hljs-params">()</span> </span>&#123;          System.out.println(<span class="hljs-string">"this is sms sender!"</span>);      &#125;  &#125;</code></pre></div><p>最后，建工厂类：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SendFactory</span> </span>&#123;        <span class="hljs-function"><span class="hljs-keyword">public</span> Sender <span class="hljs-title">produce</span><span class="hljs-params">(String type)</span> </span>&#123;          <span class="hljs-keyword">if</span> (<span class="hljs-string">"mail"</span>.equals(type)) &#123;              <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> MailSender();          &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">"sms"</span>.equals(type)) &#123;              <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> SmsSender();          &#125; <span class="hljs-keyword">else</span> &#123;              System.out.println(<span class="hljs-string">"请输入正确的类型!"</span>);              <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;          &#125;      &#125;  &#125;</code></pre></div><p>我们来测试下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FactoryTest</span> </span>&#123;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;          SendFactory factory = <span class="hljs-keyword">new</span> SendFactory();          Sender sender = factory.produce(<span class="hljs-string">"sms"</span>);          sender.Send();      &#125;  &#125;</code></pre></div><p>输出：this is sms sender!</p><h4 id="多个工厂方法模式"><a href="#多个工厂方法模式" class="headerlink" title="多个工厂方法模式"></a>多个工厂方法模式</h4><p>多个工厂方法模式，是对普通工厂方法模式的改进，在普通工厂方法模式中，如果传递的字符串出错，则不能正确创建对象，而多个工厂方法模式是提供多个工厂方法，分别创建对象。关系图：<br><img src="http://img.my.csdn.net/uploads/201211/29/1354158145_2392.PNG" srcset="/img/loading.gif"></p><p>将上面的代码做下修改，改动下SendFactory类就行，如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SendFactory</span> </span>&#123;            <span class="hljs-function"><span class="hljs-keyword">public</span> Sender <span class="hljs-title">produceMail</span><span class="hljs-params">()</span></span>&#123;          <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> MailSender();      &#125;            <span class="hljs-function"><span class="hljs-keyword">public</span> Sender <span class="hljs-title">produceSms</span><span class="hljs-params">()</span></span>&#123;          <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> SmsSender();      &#125;  &#125;</code></pre></div><p>测试类如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FactoryTest</span> </span>&#123;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;          SendFactory factory = <span class="hljs-keyword">new</span> SendFactory();          Sender sender = factory.produceMail();          sender.Send();      &#125;  &#125;</code></pre></div><p>输出：this is mailsender!</p><h4 id="静态工厂方法模式"><a href="#静态工厂方法模式" class="headerlink" title="静态工厂方法模式"></a>静态工厂方法模式</h4><p>静态工厂方法模式，将上面的多个工厂方法模式里的方法置为静态的，不需要创建实例，直接调用即可。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SendFactory</span> </span>&#123;            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Sender <span class="hljs-title">produceMail</span><span class="hljs-params">()</span></span>&#123;          <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> MailSender();      &#125;            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Sender <span class="hljs-title">produceSms</span><span class="hljs-params">()</span></span>&#123;          <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> SmsSender();      &#125;  &#125;</code></pre></div><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FactoryTest</span> </span>&#123;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;              Sender sender = SendFactory.produceMail();          sender.Send();      &#125;  &#125;</code></pre></div><p>输出：this is mailsender!</p><p>总体来说，工厂模式适合：凡是出现了大量的产品需要创建，并且具有共同的接口时，可以通过工厂方法模式进行创建。在以上的三种模式中，第一种如果传入的字符串有误，不能正确创建对象，第三种相对于第二种，不需要实例化工厂类，所以，大多数情况下，我们会选用第三种——静态工厂方法模式。</p><h3 id="抽象工厂模式（Abstract-Factory）"><a href="#抽象工厂模式（Abstract-Factory）" class="headerlink" title="抽象工厂模式（Abstract Factory）"></a>抽象工厂模式（Abstract Factory）</h3><p>工厂方法模式有一个问题就是，类的创建依赖工厂类，也就是说，如果想要拓展程序，必须对工厂类进行修改，这违背了闭包原则，所以，从设计角度考虑，有一定的问题，如何解决？就用到抽象工厂模式，创建多个工厂类，这样一旦需要增加新的功能，直接增加新的工厂类就可以了，不需要修改之前的代码。因为抽象工厂不太好理解，我们先看看图，然后就和代码，就比较容易理解。<br><img src="http://img.my.csdn.net/uploads/201211/29/1354159363_7245.PNG" srcset="/img/loading.gif"></p><p>请看例子：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Sender</span> </span>&#123;      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Send</span><span class="hljs-params">()</span></span>;  &#125;</code></pre></div><p>两个实现类：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MailSender</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Sender</span> </span>&#123;      <span class="hljs-meta">@Override</span>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Send</span><span class="hljs-params">()</span> </span>&#123;          System.out.println(<span class="hljs-string">"this is mailsender!"</span>);      &#125;  &#125;</code></pre></div><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SmsSender</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Sender</span> </span>&#123;        <span class="hljs-meta">@Override</span>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Send</span><span class="hljs-params">()</span> </span>&#123;          System.out.println(<span class="hljs-string">"this is sms sender!"</span>);      &#125;  &#125;</code></pre></div><p>两个工厂类：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SendMailFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Provider</span> </span>&#123;            <span class="hljs-meta">@Override</span>      <span class="hljs-function"><span class="hljs-keyword">public</span> Sender <span class="hljs-title">produce</span><span class="hljs-params">()</span></span>&#123;          <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> MailSender();      &#125;  &#125;</code></pre></div><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SendSmsFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Provider</span></span>&#123;        <span class="hljs-meta">@Override</span>      <span class="hljs-function"><span class="hljs-keyword">public</span> Sender <span class="hljs-title">produce</span><span class="hljs-params">()</span> </span>&#123;          <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> SmsSender();      &#125;  &#125;</code></pre></div><p>在提供一个接口：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Provider</span> </span>&#123;      <span class="hljs-function"><span class="hljs-keyword">public</span> Sender <span class="hljs-title">produce</span><span class="hljs-params">()</span></span>;  &#125;</code></pre></div><p>测试类：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;          Provider provider = <span class="hljs-keyword">new</span> SendMailFactory();          Sender sender = provider.produce();          sender.Send();      &#125;  &#125;</code></pre></div><p>其实这个模式的好处就是，如果你现在想增加一个功能：发及时信息，则只需做一个实现类，实现Sender接口，同时做一个工厂类，实现Provider接口，就OK了，无需去改动现成的代码。这样做，拓展性较好！</p><h3 id="单例模式（Singleton）"><a href="#单例模式（Singleton）" class="headerlink" title="单例模式（Singleton）"></a>单例模式（Singleton）</h3><p>单例对象（Singleton）是一种常用的设计模式。在Java应用中，单例对象能保证在一个JVM中，该对象只有一个实例存在。这样的模式有几个好处：</p><ul><li>1、某些类创建比较频繁，对于一些大型的对象，这是一笔很大的系统开销。</li><li>2、省去了new操作符，降低了系统内存的使用频率，减轻GC压力。</li><li>3、有些类如交易所的核心交易引擎，控制着交易流程，如果该类可以创建多个的话，系统完全乱了。（比如一个军队出现了多个司令员同时指挥，肯定会乱成一团），所以只有使用单例模式，才能保证核心交易服务器独立控制整个流程。</li></ul><p>首先我们写一个简单的单例类：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;        <span class="hljs-comment">/* 持有私有静态实例，防止被引用，此处赋值为null，目的是实现延迟加载 */</span>      <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton instance = <span class="hljs-keyword">null</span>;        <span class="hljs-comment">/* 私有构造方法，防止被实例化 */</span>      <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span> </span>&#123;      &#125;        <span class="hljs-comment">/* 静态工程方法，创建实例 */</span>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;          <span class="hljs-keyword">if</span> (instance == <span class="hljs-keyword">null</span>) &#123;              instance = <span class="hljs-keyword">new</span> Singleton();          &#125;          <span class="hljs-keyword">return</span> instance;      &#125;        <span class="hljs-comment">/* 如果该对象被用于序列化，可以保证对象在序列化前后保持一致 */</span>      <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">readResolve</span><span class="hljs-params">()</span> </span>&#123;          <span class="hljs-keyword">return</span> instance;      &#125;  &#125;</code></pre></div><p>这个类可以满足基本要求，但是，像这样毫无线程安全保护的类，如果我们把它放入多线程的环境下，肯定就会出现问题了，如何解决？我们首先会想到对getInstance方法加synchronized关键字，如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;         <span class="hljs-keyword">if</span> (instance == <span class="hljs-keyword">null</span>) &#123;             instance = <span class="hljs-keyword">new</span> Singleton();         &#125;         <span class="hljs-keyword">return</span> instance;     &#125;</code></pre></div><p>但是，synchronized关键字锁住的是这个对象，这样的用法，在性能上会有所下降，因为每次调用getInstance()，都要对对象上锁，事实上，只有在第一次创建对象的时候需要加锁，之后就不需要了，所以，这个地方需要改进。我们改成下面这个：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;          <span class="hljs-keyword">if</span> (instance == <span class="hljs-keyword">null</span>) &#123;              <span class="hljs-keyword">synchronized</span> (instance) &#123;                  <span class="hljs-keyword">if</span> (instance == <span class="hljs-keyword">null</span>) &#123;                      instance = <span class="hljs-keyword">new</span> Singleton();                  &#125;              &#125;          &#125;          <span class="hljs-keyword">return</span> instance;      &#125;</code></pre></div><p>似乎解决了之前提到的问题，将synchronized关键字加在了内部，也就是说当调用的时候是不需要加锁的，只有在instance为null，并创建对象的时候才需要加锁，性能有一定的提升。但是，这样的情况，还是有可能有问题的，看下面的情况：在Java指令中创建对象和赋值操作是分开进行的，也就是说instance = new Singleton();语句是分两步执行的。但是JVM并不保证这两个操作的先后顺序，也就是说有可能JVM会为新的Singleton实例分配空间，然后直接赋值给instance成员，然后再去初始化这个Singleton实例。这样就可能出错了，我们以A、B两个线程为例：<br>a&gt;A、B线程同时进入了第一个if判断<br>b&gt;A首先进入synchronized块，由于instance为null，所以它执行instance = new Singleton();<br>c&gt;由于JVM内部的优化机制，JVM先画出了一些分配给Singleton实例的空白内存，并赋值给instance成员（注意此时JVM没有开始初始化这个实例），然后A离开了synchronized块。<br>d&gt;B进入synchronized块，由于instance此时不是null，因此它马上离开了synchronized块并将结果返回给调用该方法的程序。<br>e&gt;此时B线程打算使用Singleton实例，却发现它没有被初始化，于是错误发生了。<br>所以程序还是有可能发生错误，其实程序在运行过程是很复杂的，从这点我们就可以看出，尤其是在写多线程环境下的程序更有难度，有挑战性。我们对该程序做进一步优化：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingletonFactory</span></span>&#123;                   <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton instance = <span class="hljs-keyword">new</span> Singleton();               &#125;               <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>&#123;                   <span class="hljs-keyword">return</span> SingletonFactory.instance;               &#125;</code></pre></div><p>实际情况是，单例模式使用内部类来维护单例的实现，JVM内部的机制能够保证当一个类被加载的时候，这个类的加载过程是线程互斥的。这样当我们第一次调用getInstance的时候，JVM能够帮我们保证instance只被创建一次，并且会保证把赋值给instance的内存初始化完毕，这样我们就不用担心上面的问题。同时该方法也只会在第一次调用的时候使用互斥机制，这样就解决了低性能问题。这样我们暂时总结一个完美的单例模式：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;        <span class="hljs-comment">/* 私有构造方法，防止被实例化 */</span>      <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span> </span>&#123;      &#125;        <span class="hljs-comment">/* 此处使用一个内部类来维护单例 */</span>      <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingletonFactory</span> </span>&#123;          <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton instance = <span class="hljs-keyword">new</span> Singleton();      &#125;        <span class="hljs-comment">/* 获取实例 */</span>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;          <span class="hljs-keyword">return</span> SingletonFactory.instance;      &#125;        <span class="hljs-comment">/* 如果该对象被用于序列化，可以保证对象在序列化前后保持一致 */</span>      <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">readResolve</span><span class="hljs-params">()</span> </span>&#123;          <span class="hljs-keyword">return</span> getInstance();      &#125;  &#125;</code></pre></div><p>其实说它完美，也不一定，如果在构造函数中抛出异常，实例将永远得不到创建，也会出错。所以说，十分完美的东西是没有的，我们只能根据实际情况，选择最适合自己应用场景的实现方法。也有人这样实现：因为我们只需要在创建类的时候进行同步，所以只要将创建和getInstance()分开，单独为创建加synchronized关键字，也是可以的：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingletonTest</span> </span>&#123;        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> SingletonTest instance = <span class="hljs-keyword">null</span>;        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">SingletonTest</span><span class="hljs-params">()</span> </span>&#123;      &#125;        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">syncInit</span><span class="hljs-params">()</span> </span>&#123;          <span class="hljs-keyword">if</span> (instance == <span class="hljs-keyword">null</span>) &#123;              instance = <span class="hljs-keyword">new</span> SingletonTest();          &#125;      &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SingletonTest <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;          <span class="hljs-keyword">if</span> (instance == <span class="hljs-keyword">null</span>) &#123;              syncInit();          &#125;          <span class="hljs-keyword">return</span> instance;      &#125;  &#125;</code></pre></div><p>考虑性能的话，整个程序只需创建一次实例，所以性能也不会有什么影响。<br>补充：采用”影子实例”的办法为单例对象的属性同步更新</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingletonTest</span> </span>&#123;        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> SingletonTest instance = <span class="hljs-keyword">null</span>;      <span class="hljs-keyword">private</span> Vector properties = <span class="hljs-keyword">null</span>;        <span class="hljs-function"><span class="hljs-keyword">public</span> Vector <span class="hljs-title">getProperties</span><span class="hljs-params">()</span> </span>&#123;          <span class="hljs-keyword">return</span> properties;      &#125;        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">SingletonTest</span><span class="hljs-params">()</span> </span>&#123;      &#125;        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">syncInit</span><span class="hljs-params">()</span> </span>&#123;          <span class="hljs-keyword">if</span> (instance == <span class="hljs-keyword">null</span>) &#123;              instance = <span class="hljs-keyword">new</span> SingletonTest();          &#125;      &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SingletonTest <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;          <span class="hljs-keyword">if</span> (instance == <span class="hljs-keyword">null</span>) &#123;              syncInit();          &#125;          <span class="hljs-keyword">return</span> instance;      &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">updateProperties</span><span class="hljs-params">()</span> </span>&#123;          SingletonTest shadow = <span class="hljs-keyword">new</span> SingletonTest();          properties = shadow.getProperties();      &#125;  &#125;</code></pre></div><p>通过单例模式的学习告诉我们：</p><p>1、单例模式理解起来简单，但是具体实现起来还是有一定的难度。<br>2、synchronized关键字锁定的是对象，在用的时候，一定要在恰当的地方使用（注意需要使用锁的对象和过程，可能有的时候并不是整个对象及整个过程都需要锁）。<br>到这儿，单例模式基本已经讲完了，结尾处，笔者突然想到另一个问题，就是采用类的静态方法，实现单例模式的效果，也是可行的，此处二者有什么不同？<br>首先，静态类不能实现接口。（从类的角度说是可以的，但是那样就破坏了静态了。因为接口中不允许有static修饰的方法，所以即使实现了也是非静态的）<br>其次，单例可以被延迟初始化，静态类一般在第一次加载是初始化。之所以延迟加载，是因为有些类比较庞大，所以延迟加载有助于提升性能。<br>再次，单例类可以被继承，他的方法可以被覆写。但是静态类内部方法都是static，无法被覆写。<br>最后一点，单例类比较灵活，毕竟从实现上只是一个普通的Java类，只要满足单例的基本需求，你可以在里面随心所欲的实现一些其它功能，但是静态类不行。从上面这些概括中，基本可以看出二者的区别，但是，从另一方面讲，我们上面最后实现的那个单例模式，内部就是用一个静态类来实现的，所以，二者有很大的关联，只是我们考虑问题的层面不同罢了。两种思想的结合，才能造就出完美的解决方案，就像HashMap采用数组+链表来实现一样，其实生活中很多事情都是这样，单用不同的方法来处理问题，总是有优点也有缺点，最完美的方法是，结合各个方法的优点，才能最好的解决问题！</p><h3 id="建造者模式（Builder）"><a href="#建造者模式（Builder）" class="headerlink" title="建造者模式（Builder）"></a>建造者模式（Builder）</h3><p>工厂类模式提供的是创建单个类的模式，而建造者模式则是将各种产品集中起来进行管理，用来创建复合对象，所谓复合对象就是指某个类具有不同的属性，其实建造者模式就是前面抽象工厂模式和最后的Test结合起来得到的。我们看一下代码：<br>还和前面一样，一个Sender接口，两个实现类MailSender和SmsSender。最后，建造者类如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Builder</span> </span>&#123;            <span class="hljs-keyword">private</span> List&lt;Sender&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;Sender&gt;();            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">produceMailSender</span><span class="hljs-params">(<span class="hljs-keyword">int</span> count)</span></span>&#123;          <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;count; i++)&#123;              list.add(<span class="hljs-keyword">new</span> MailSender());          &#125;      &#125;            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">produceSmsSender</span><span class="hljs-params">(<span class="hljs-keyword">int</span> count)</span></span>&#123;          <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;count; i++)&#123;              list.add(<span class="hljs-keyword">new</span> SmsSender());          &#125;      &#125;  &#125;</code></pre></div><p>测试类：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;          Builder builder = <span class="hljs-keyword">new</span> Builder();          builder.produceMailSender(<span class="hljs-number">10</span>);      &#125;  &#125;</code></pre></div><p>从这点看出，建造者模式将很多功能集成到一个类里，这个类可以创造出比较复杂的东西。所以与工程模式的区别就是：工厂模式关注的是创建单个产品，而建造者模式则关注创建符合对象，多个部分。因此，是选择工厂模式还是建造者模式，依实际情况而定。</p><h3 id="原型模式（Prototype）"><a href="#原型模式（Prototype）" class="headerlink" title="原型模式（Prototype）"></a>原型模式（Prototype）</h3><p>原型模式虽然是创建型的模式，但是与工程模式没有关系，从名字即可看出，该模式的思想就是将一个对象作为原型，对其进行复制、克隆，产生一个和原对象类似的新对象。本小结会通过对象的复制，进行讲解。在Java中，复制对象是通过clone()实现的，先创建一个原型类：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Prototype</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Cloneable</span> </span>&#123;        <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException </span>&#123;          Prototype proto = (Prototype) <span class="hljs-keyword">super</span>.clone();          <span class="hljs-keyword">return</span> proto;      &#125;  &#125;</code></pre></div><p>很简单，一个原型类，只需要实现Cloneable接口，覆写clone方法，此处clone方法可以改成任意的名称，因为Cloneable接口是个空接口，你可以任意定义实现类的方法名，如cloneA或者cloneB，因为此处的重点是super.clone()这句话，super.clone()调用的是Object的clone()方法，而在Object类中，clone()是native的，具体怎么实现，我会在另一篇文章中，关于解读Java中本地方法的调用，此处不再深究。在这儿，我将结合对象的浅复制和深复制来说一下，首先需要了解对象深、浅复制的概念：<br>浅复制：将一个对象复制后，基本数据类型的变量都会重新创建，而引用类型，指向的还是原对象所指向的。<br>深复制：将一个对象复制后，不论是基本数据类型还有引用类型，都是重新创建的。简单来说，就是深复制进行了完全彻底的复制，而浅复制不彻底。<br>此处，写一个深浅复制的例子：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Prototype</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Cloneable</span>, <span class="hljs-title">Serializable</span> </span>&#123;        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = <span class="hljs-number">1L</span>;      <span class="hljs-keyword">private</span> String string;        <span class="hljs-keyword">private</span> SerializableObject obj;        <span class="hljs-comment">/* 浅复制 */</span>      <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException </span>&#123;          Prototype proto = (Prototype) <span class="hljs-keyword">super</span>.clone();          <span class="hljs-keyword">return</span> proto;      &#125;        <span class="hljs-comment">/* 深复制 */</span>      <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">deepClone</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException, ClassNotFoundException </span>&#123;            <span class="hljs-comment">/* 写入当前对象的二进制流 */</span>          ByteArrayOutputStream bos = <span class="hljs-keyword">new</span> ByteArrayOutputStream();          ObjectOutputStream oos = <span class="hljs-keyword">new</span> ObjectOutputStream(bos);          oos.writeObject(<span class="hljs-keyword">this</span>);            <span class="hljs-comment">/* 读出二进制流产生的新对象 */</span>          ByteArrayInputStream bis = <span class="hljs-keyword">new</span> ByteArrayInputStream(bos.toByteArray());          ObjectInputStream ois = <span class="hljs-keyword">new</span> ObjectInputStream(bis);          <span class="hljs-keyword">return</span> ois.readObject();      &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getString</span><span class="hljs-params">()</span> </span>&#123;          <span class="hljs-keyword">return</span> string;      &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setString</span><span class="hljs-params">(String string)</span> </span>&#123;          <span class="hljs-keyword">this</span>.string = string;      &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> SerializableObject <span class="hljs-title">getObj</span><span class="hljs-params">()</span> </span>&#123;          <span class="hljs-keyword">return</span> obj;      &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setObj</span><span class="hljs-params">(SerializableObject obj)</span> </span>&#123;          <span class="hljs-keyword">this</span>.obj = obj;      &#125;    &#125;    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SerializableObject</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span> </span>&#123;      <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = <span class="hljs-number">1L</span>;  &#125;</code></pre></div><p>要实现深复制，需要采用流的形式读入当前对象的二进制输入，再写出二进制数据对应的对象。</p><blockquote><p>以上是5种创建型模式，这章开始，我将讲下7种结构型模式：适配器模式、装饰模式、代理模式、外观模式、桥接模式、组合模式、享元模式。其中对象的适配器模式是各种模式的起源，我们看下面的图：<br><img src="http://img.my.csdn.net/uploads/201211/29/1354192484_5322.PNG" srcset="/img/loading.gif"></p></blockquote><h3 id="适配器模式（Adapter）"><a href="#适配器模式（Adapter）" class="headerlink" title="适配器模式（Adapter）"></a>适配器模式（Adapter）</h3><p>适配器模式将某个类的接口转换成客户端期望的另一个接口表示，目的是消除由于接口不匹配所造成的类的兼容性问题。主要分为三类：类的适配器模式、对象的适配器模式、接口的适配器模式。首先，我们来看看类的适配器模式，先看类图：<br><img src="http://img.my.csdn.net/uploads/201211/29/1354187872_4972.PNG" srcset="/img/loading.gif"></p><p>核心思想就是：有一个Source类，拥有一个方法，待适配，目标接口时Targetable，通过Adapter类，将Source的功能扩展到Targetable里，看代码：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Source</span> </span>&#123;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method1</span><span class="hljs-params">()</span> </span>&#123;          System.out.println(<span class="hljs-string">"this is original method!"</span>);      &#125;  &#125;</code></pre></div><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Targetable</span> </span>&#123;        <span class="hljs-comment">/* 与原类中的方法相同 */</span>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method1</span><span class="hljs-params">()</span></span>;        <span class="hljs-comment">/* 新类的方法 */</span>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method2</span><span class="hljs-params">()</span></span>;  &#125;</code></pre></div><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Adapter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Source</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Targetable</span> </span>&#123;        <span class="hljs-meta">@Override</span>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method2</span><span class="hljs-params">()</span> </span>&#123;          System.out.println(<span class="hljs-string">"this is the targetable method!"</span>);      &#125;  &#125;</code></pre></div><p>Adapter类继承Source类，实现Targetable接口，下面是测试类：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AdapterTest</span> </span>&#123;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;          Targetable target = <span class="hljs-keyword">new</span> Adapter();          target.method1();          target.method2();      &#125;  &#125;</code></pre></div><p>输出：<br>this is original method!<br>this is the targetable method!<br>这样Targetable接口的实现类就具有了Source类的功能。</p><blockquote><p>对象的适配器模式</p></blockquote><p>基本思路和类的适配器模式相同，只是将Adapter类作修改，这次不继承Source类，而是持有Source类的实例，以达到解决兼容性的问题。看图：<br><img src="http://img.my.csdn.net/uploads/201211/29/1354188530_8387.PNG" srcset="/img/loading.gif"></p><p>只需要修改Adapter类的源码即可：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Wrapper</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Targetable</span> </span>&#123;        <span class="hljs-keyword">private</span> Source source;            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Wrapper</span><span class="hljs-params">(Source source)</span></span>&#123;          <span class="hljs-keyword">super</span>();          <span class="hljs-keyword">this</span>.source = source;      &#125;      <span class="hljs-meta">@Override</span>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method2</span><span class="hljs-params">()</span> </span>&#123;          System.out.println(<span class="hljs-string">"this is the targetable method!"</span>);      &#125;        <span class="hljs-meta">@Override</span>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method1</span><span class="hljs-params">()</span> </span>&#123;          source.method1();      &#125;  &#125;</code></pre></div><p>测试类：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AdapterTest</span> </span>&#123;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;          Source source = <span class="hljs-keyword">new</span> Source();          Targetable target = <span class="hljs-keyword">new</span> Wrapper(source);          target.method1();          target.method2();      &#125;  &#125;</code></pre></div><p>输出与第一种一样，只是适配的方法不同而已。<br>第三种适配器模式是接口的适配器模式，接口的适配器是这样的：有时我们写的一个接口中有多个抽象方法，当我们写该接口的实现类时，必须实现该接口的所有方法，这明显有时比较浪费，因为并不是所有的方法都是我们需要的，有时只需要某一些，此处为了解决这个问题，我们引入了接口的适配器模式，借助于一个抽象类，该抽象类实现了该接口，实现了所有的方法，而我们不和原始的接口打交道，只和该抽象类取得联系，所以我们写一个类，继承该抽象类，重写我们需要的方法就行。看一下类图：<br><img src="http://img.my.csdn.net/uploads/201211/29/1354191586_2062.PNG" srcset="/img/loading.gif"></p><p>这个很好理解，在实际开发中，我们也常会遇到这种接口中定义了太多的方法，以致于有时我们在一些实现类中并不是都需要。看代码：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Sourceable</span> </span>&#123;            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method1</span><span class="hljs-params">()</span></span>;      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method2</span><span class="hljs-params">()</span></span>;  &#125;</code></pre></div><p>抽象类Wrapper2：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Wrapper2</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Sourceable</span></span>&#123;            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method1</span><span class="hljs-params">()</span></span>&#123;&#125;      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method2</span><span class="hljs-params">()</span></span>&#123;&#125;  &#125;</code></pre></div><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SourceSub1</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Wrapper2</span> </span>&#123;      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method1</span><span class="hljs-params">()</span></span>&#123;          System.out.println(<span class="hljs-string">"the sourceable interface's first Sub1!"</span>);      &#125;  &#125;</code></pre></div><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SourceSub2</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Wrapper2</span> </span>&#123;      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method2</span><span class="hljs-params">()</span></span>&#123;          System.out.println(<span class="hljs-string">"the sourceable interface's second Sub2!"</span>);      &#125;  &#125;</code></pre></div><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WrapperTest</span> </span>&#123;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;          Sourceable source1 = <span class="hljs-keyword">new</span> SourceSub1();          Sourceable source2 = <span class="hljs-keyword">new</span> SourceSub2();                    source1.method1();          source1.method2();          source2.method1();          source2.method2();      &#125;  &#125;</code></pre></div><p>测试输出：<br>the sourceable interface’s first Sub1!<br>the sourceable interface’s second Sub2!<br>达到了我们的效果！<br> 讲了这么多，总结一下三种适配器模式的应用场景：<br>类的适配器模式：当希望将一个类转换成满足另一个新接口的类时，可以使用类的适配器模式，创建一个新类，继承原有的类，实现新的接口即可。<br>对象的适配器模式：当希望将一个对象转换成满足另一个新接口的对象时，可以创建一个Wrapper类，持有原类的一个实例，在Wrapper类的方法中，调用实例的方法就行。<br>接口的适配器模式：当不希望实现一个接口中所有的方法时，可以创建一个抽象类Wrapper，实现所有方法，我们写别的类的时候，继承抽象类即可。</p><h3 id="装饰模式（Decorator）"><a href="#装饰模式（Decorator）" class="headerlink" title="装饰模式（Decorator）"></a>装饰模式（Decorator）</h3><p>顾名思义，装饰模式就是给一个对象增加一些新的功能，而且是动态的，要求装饰对象和被装饰对象实现同一个接口，装饰对象持有被装饰对象的实例，关系图如下：<br><img src="http://img.my.csdn.net/uploads/201211/29/1354196367_3730.PNG" srcset="/img/loading.gif"></p><p>Source类是被装饰类，Decorator类是一个装饰类，可以为Source类动态的添加一些功能，代码如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Sourceable</span> </span>&#123;      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method</span><span class="hljs-params">()</span></span>;  &#125;</code></pre></div><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Source</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Sourceable</span> </span>&#123;        <span class="hljs-meta">@Override</span>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method</span><span class="hljs-params">()</span> </span>&#123;          System.out.println(<span class="hljs-string">"the original method!"</span>);      &#125;  &#125;</code></pre></div><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Decorator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Sourceable</span> </span>&#123;        <span class="hljs-keyword">private</span> Sourceable source;            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Decorator</span><span class="hljs-params">(Sourceable source)</span></span>&#123;          <span class="hljs-keyword">super</span>();          <span class="hljs-keyword">this</span>.source = source;      &#125;      <span class="hljs-meta">@Override</span>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method</span><span class="hljs-params">()</span> </span>&#123;          System.out.println(<span class="hljs-string">"before decorator!"</span>);          source.method();          System.out.println(<span class="hljs-string">"after decorator!"</span>);      &#125;  &#125;</code></pre></div><p>测试类：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DecoratorTest</span> </span>&#123;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;          Sourceable source = <span class="hljs-keyword">new</span> Source();          Sourceable obj = <span class="hljs-keyword">new</span> Decorator(source);          obj.method();      &#125;  &#125;</code></pre></div><p>输出：<br>before decorator!<br>the original method!<br>after decorator!<br>装饰器模式的应用场景：<br>1、需要扩展一个类的功能。<br>2、动态的为一个对象增加功能，而且还能动态撤销。（继承不能做到这一点，继承的功能是静态的，不能动态增删。）<br>缺点：产生过多相似的对象，不易排错！</p><h3 id="代理模式（Proxy）"><a href="#代理模式（Proxy）" class="headerlink" title="代理模式（Proxy）"></a>代理模式（Proxy）</h3><p>其实每个模式名称就表明了该模式的作用，代理模式就是多一个代理类出来，替原对象进行一些操作，比如我们在租房子的时候回去找中介，为什么呢？因为你对该地区房屋的信息掌握的不够全面，希望找一个更熟悉的人去帮你做，此处的代理就是这个意思。再如我们有的时候打官司，我们需要请律师，因为律师在法律方面有专长，可以替我们进行操作，表达我们的想法。先来看看关系图：<br><img src="http://img.my.csdn.net/uploads/201211/29/1354197582_1664.PNG" srcset="/img/loading.gif"></p><p>根据上文的阐述，代理模式就比较容易的理解了，我们看下代码：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Sourceable</span> </span>&#123;      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method</span><span class="hljs-params">()</span></span>;  &#125;</code></pre></div><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Source</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Sourceable</span> </span>&#123;        <span class="hljs-meta">@Override</span>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method</span><span class="hljs-params">()</span> </span>&#123;          System.out.println(<span class="hljs-string">"the original method!"</span>);      &#125;  &#125;</code></pre></div><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Proxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Sourceable</span> </span>&#123;        <span class="hljs-keyword">private</span> Source source;      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Proxy</span><span class="hljs-params">()</span></span>&#123;          <span class="hljs-keyword">super</span>();          <span class="hljs-keyword">this</span>.source = <span class="hljs-keyword">new</span> Source();      &#125;      <span class="hljs-meta">@Override</span>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method</span><span class="hljs-params">()</span> </span>&#123;          before();          source.method();          atfer();      &#125;      <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">atfer</span><span class="hljs-params">()</span> </span>&#123;          System.out.println(<span class="hljs-string">"after proxy!"</span>);      &#125;      <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">before</span><span class="hljs-params">()</span> </span>&#123;          System.out.println(<span class="hljs-string">"before proxy!"</span>);      &#125;  &#125;</code></pre></div><p>测试类：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProxyTest</span> </span>&#123;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;          Sourceable source = <span class="hljs-keyword">new</span> Proxy();          source.method();      &#125;    &#125;</code></pre></div><p>输出：<br>before proxy!<br>the original method!<br>after proxy!<br>代理模式的应用场景：<br>如果已有的方法在使用的时候需要对原有的方法进行改进，此时有两种办法：<br>1、修改原有的方法来适应。这样违反了“对扩展开放，对修改关闭”的原则。<br>2、就是采用一个代理类调用原有的方法，且对产生的结果进行控制。这种方法就是代理模式。<br>使用代理模式，可以将功能划分的更加清晰，有助于后期维护！</p><h3 id="外观模式（Facade）"><a href="#外观模式（Facade）" class="headerlink" title="外观模式（Facade）"></a>外观模式（Facade）</h3><p>外观模式是为了解决类与类之家的依赖关系的，像spring一样，可以将类和类之间的关系配置到配置文件中，而外观模式就是将他们的关系放在一个Facade类中，降低了类类之间的耦合度，该模式中没有涉及到接口，看下类图：（我们以一个计算机的启动过程为例）<br><img src="http://img.my.csdn.net/uploads/201211/29/1354200158_3667.PNG" srcset="/img/loading.gif"></p><p>我们先看下实现类：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CPU</span> </span>&#123;            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">startup</span><span class="hljs-params">()</span></span>&#123;          System.out.println(<span class="hljs-string">"cpu startup!"</span>);      &#125;            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">shutdown</span><span class="hljs-params">()</span></span>&#123;          System.out.println(<span class="hljs-string">"cpu shutdown!"</span>);      &#125;  &#125;</code></pre></div><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Memory</span> </span>&#123;            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">startup</span><span class="hljs-params">()</span></span>&#123;          System.out.println(<span class="hljs-string">"memory startup!"</span>);      &#125;            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">shutdown</span><span class="hljs-params">()</span></span>&#123;          System.out.println(<span class="hljs-string">"memory shutdown!"</span>);      &#125;  &#125;</code></pre></div><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Disk</span> </span>&#123;            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">startup</span><span class="hljs-params">()</span></span>&#123;          System.out.println(<span class="hljs-string">"disk startup!"</span>);      &#125;            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">shutdown</span><span class="hljs-params">()</span></span>&#123;          System.out.println(<span class="hljs-string">"disk shutdown!"</span>);      &#125;  &#125;</code></pre></div><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Computer</span> </span>&#123;      <span class="hljs-keyword">private</span> CPU cpu;      <span class="hljs-keyword">private</span> Memory memory;      <span class="hljs-keyword">private</span> Disk disk;            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Computer</span><span class="hljs-params">()</span></span>&#123;          cpu = <span class="hljs-keyword">new</span> CPU();          memory = <span class="hljs-keyword">new</span> Memory();          disk = <span class="hljs-keyword">new</span> Disk();      &#125;            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">startup</span><span class="hljs-params">()</span></span>&#123;          System.out.println(<span class="hljs-string">"start the computer!"</span>);          cpu.startup();          memory.startup();          disk.startup();          System.out.println(<span class="hljs-string">"start computer finished!"</span>);      &#125;            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">shutdown</span><span class="hljs-params">()</span></span>&#123;          System.out.println(<span class="hljs-string">"begin to close the computer!"</span>);          cpu.shutdown();          memory.shutdown();          disk.shutdown();          System.out.println(<span class="hljs-string">"computer closed!"</span>);      &#125;  &#125;</code></pre></div><p>User类如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;          Computer computer = <span class="hljs-keyword">new</span> Computer();          computer.startup();          computer.shutdown();      &#125;  &#125;</code></pre></div><p>输出：<br>start the computer!<br>cpu startup!<br>memory startup!<br>disk startup!<br>start computer finished!<br>begin to close the computer!<br>cpu shutdown!<br>memory shutdown!<br>disk shutdown!<br>computer closed!<br>如果我们没有Computer类，那么，CPU、Memory、Disk他们之间将会相互持有实例，产生关系，这样会造成严重的依赖，修改一个类，可能会带来其他类的修改，这不是我们想要看到的，有了Computer类，他们之间的关系被放在了Computer类里，这样就起到了解耦的作用，这，就是外观模式！</p><h3 id="桥接模式（Bridge）"><a href="#桥接模式（Bridge）" class="headerlink" title="桥接模式（Bridge）"></a>桥接模式（Bridge）</h3><p>桥接模式就是把事物和其具体实现分开，使他们可以各自独立的变化。桥接的用意是：将抽象化与实现化解耦，使得二者可以独立变化，像我们常用的JDBC桥DriverManager一样，JDBC进行连接数据库的时候，在各个数据库之间进行切换，基本不需要动太多的代码，甚至丝毫不用动，原因就是JDBC提供统一接口，每个数据库提供各自的实现，用一个叫做数据库驱动的程序来桥接就行了。我们来看看关系图：<br><img src="http://img.my.csdn.net/uploads/201211/30/1354241751_5582.PNG" srcset="/img/loading.gif"></p><p>实现代码：<br>先定义接口：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Sourceable</span> </span>&#123;      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method</span><span class="hljs-params">()</span></span>;  &#125;</code></pre></div><p>分别定义两个实现类：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SourceSub1</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Sourceable</span> </span>&#123;        <span class="hljs-meta">@Override</span>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method</span><span class="hljs-params">()</span> </span>&#123;          System.out.println(<span class="hljs-string">"this is the first sub!"</span>);      &#125;  &#125;</code></pre></div><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SourceSub2</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Sourceable</span> </span>&#123;        <span class="hljs-meta">@Override</span>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method</span><span class="hljs-params">()</span> </span>&#123;          System.out.println(<span class="hljs-string">"this is the second sub!"</span>);      &#125;  &#125;</code></pre></div><p>定义一个桥，持有Sourceable的一个实例：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Bridge</span> </span>&#123;      <span class="hljs-keyword">private</span> Sourceable source;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method</span><span class="hljs-params">()</span></span>&#123;          source.method();      &#125;            <span class="hljs-function"><span class="hljs-keyword">public</span> Sourceable <span class="hljs-title">getSource</span><span class="hljs-params">()</span> </span>&#123;          <span class="hljs-keyword">return</span> source;      &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setSource</span><span class="hljs-params">(Sourceable source)</span> </span>&#123;          <span class="hljs-keyword">this</span>.source = source;      &#125;  &#125;</code></pre></div><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyBridge</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Bridge</span> </span>&#123;      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method</span><span class="hljs-params">()</span></span>&#123;          getSource().method();      &#125;  &#125;</code></pre></div><p>测试类：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BridgeTest</span> </span>&#123;            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;                    Bridge bridge = <span class="hljs-keyword">new</span> MyBridge();                    <span class="hljs-comment">/*调用第一个对象*/</span>          Sourceable source1 = <span class="hljs-keyword">new</span> SourceSub1();          bridge.setSource(source1);          bridge.method();                    <span class="hljs-comment">/*调用第二个对象*/</span>          Sourceable source2 = <span class="hljs-keyword">new</span> SourceSub2();          bridge.setSource(source2);          bridge.method();      &#125;  &#125;</code></pre></div><p>output：<br>this is the first sub!<br>this is the second sub!<br>这样，就通过对Bridge类的调用，实现了对接口Sourceable的实现类SourceSub1和SourceSub2的调用。接下来我再画个图，大家就应该明白了，因为这个图是我们JDBC连接的原理，有数据库学习基础的，一结合就都懂了。<br><img src="http://img.my.csdn.net/uploads/201211/30/1354242717_1732.PNG" srcset="/img/loading.gif"></p><h3 id="组合模式（Composite）"><a href="#组合模式（Composite）" class="headerlink" title="组合模式（Composite）"></a>组合模式（Composite）</h3><p>组合模式有时又叫部分-整体模式在处理类似树形结构的问题时比较方便，看看关系图：<br><img src="http://img.my.csdn.net/uploads/201211/30/1354243465_5968.PNG" srcset="/img/loading.gif"></p><p>直接来看代码：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TreeNode</span> </span>&#123;            <span class="hljs-keyword">private</span> String name;      <span class="hljs-keyword">private</span> TreeNode parent;      <span class="hljs-keyword">private</span> Vector&lt;TreeNode&gt; children = <span class="hljs-keyword">new</span> Vector&lt;TreeNode&gt;();            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">TreeNode</span><span class="hljs-params">(String name)</span></span>&#123;          <span class="hljs-keyword">this</span>.name = name;      &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;          <span class="hljs-keyword">return</span> name;      &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;          <span class="hljs-keyword">this</span>.name = name;      &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">getParent</span><span class="hljs-params">()</span> </span>&#123;          <span class="hljs-keyword">return</span> parent;      &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setParent</span><span class="hljs-params">(TreeNode parent)</span> </span>&#123;          <span class="hljs-keyword">this</span>.parent = parent;      &#125;            <span class="hljs-comment">//添加孩子节点  </span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(TreeNode node)</span></span>&#123;          children.add(node);      &#125;            <span class="hljs-comment">//删除孩子节点  </span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(TreeNode node)</span></span>&#123;          children.remove(node);      &#125;            <span class="hljs-comment">//取得孩子节点  </span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Enumeration&lt;TreeNode&gt; <span class="hljs-title">getChildren</span><span class="hljs-params">()</span></span>&#123;          <span class="hljs-keyword">return</span> children.elements();      &#125;  &#125;</code></pre></div><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Tree</span> </span>&#123;        TreeNode root = <span class="hljs-keyword">null</span>;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Tree</span><span class="hljs-params">(String name)</span> </span>&#123;          root = <span class="hljs-keyword">new</span> TreeNode(name);      &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;          Tree tree = <span class="hljs-keyword">new</span> Tree(<span class="hljs-string">"A"</span>);          TreeNode nodeB = <span class="hljs-keyword">new</span> TreeNode(<span class="hljs-string">"B"</span>);          TreeNode nodeC = <span class="hljs-keyword">new</span> TreeNode(<span class="hljs-string">"C"</span>);                    nodeB.add(nodeC);          tree.root.add(nodeB);          System.out.println(<span class="hljs-string">"build the tree finished!"</span>);      &#125;  &#125;</code></pre></div><p>使用场景：将多个对象组合在一起进行操作，常用于表示树形结构中，例如二叉树，数等。</p><h3 id="享元模式（Flyweight）"><a href="#享元模式（Flyweight）" class="headerlink" title="享元模式（Flyweight）"></a>享元模式（Flyweight）</h3><p>享元模式的主要目的是实现对象的共享，即共享池，当系统中对象多的时候可以减少内存的开销，通常与工厂模式一起使用。<br><img src="http://img.my.csdn.net/uploads/201211/30/1354257773_2727.PNG" srcset="/img/loading.gif"></p><p>FlyWeightFactory负责创建和管理享元单元，当一个客户端请求时，工厂需要检查当前对象池中是否有符合条件的对象，如果有，就返回已经存在的对象，如果没有，则创建一个新对象，FlyWeight是超类。一提到共享池，我们很容易联想到Java里面的JDBC连接池，想想每个连接的特点，我们不难总结出：适用于作共享的一些个对象，他们有一些共有的属性，就拿数据库连接池来说，url、driverClassName、username、password及dbname，这些属性对于每个连接来说都是一样的，所以就适合用享元模式来处理，建一个工厂类，将上述类似属性作为内部数据，其它的作为外部数据，在方法调用时，当做参数传进来，这样就节省了空间，减少了实例的数量。<br>看个例子：<br><img src="http://img.my.csdn.net/uploads/201211/30/1354258649_9039.PNG" srcset="/img/loading.gif"></p><p>看下数据库连接池的代码：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConnectionPool</span> </span>&#123;            <span class="hljs-keyword">private</span> Vector&lt;Connection&gt; pool;            <span class="hljs-comment">/*公有属性*/</span>      <span class="hljs-keyword">private</span> String url = <span class="hljs-string">"jdbc:mysql://localhost:3306/test"</span>;      <span class="hljs-keyword">private</span> String username = <span class="hljs-string">"root"</span>;      <span class="hljs-keyword">private</span> String password = <span class="hljs-string">"root"</span>;      <span class="hljs-keyword">private</span> String driverClassName = <span class="hljs-string">"com.mysql.jdbc.Driver"</span>;        <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> poolSize = <span class="hljs-number">100</span>;      <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ConnectionPool instance = <span class="hljs-keyword">null</span>;      Connection conn = <span class="hljs-keyword">null</span>;        <span class="hljs-comment">/*构造方法，做一些初始化工作*/</span>      <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">ConnectionPool</span><span class="hljs-params">()</span> </span>&#123;          pool = <span class="hljs-keyword">new</span> Vector&lt;Connection&gt;(poolSize);            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; poolSize; i++) &#123;              <span class="hljs-keyword">try</span> &#123;                  Class.forName(driverClassName);                  conn = DriverManager.getConnection(url, username, password);                  pool.add(conn);              &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;                  e.printStackTrace();              &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;                  e.printStackTrace();              &#125;          &#125;      &#125;        <span class="hljs-comment">/* 返回连接到连接池 */</span>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">release</span><span class="hljs-params">()</span> </span>&#123;          pool.add(conn);      &#125;        <span class="hljs-comment">/* 返回连接池中的一个数据库连接 */</span>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> Connection <span class="hljs-title">getConnection</span><span class="hljs-params">()</span> </span>&#123;          <span class="hljs-keyword">if</span> (pool.size() &gt; <span class="hljs-number">0</span>) &#123;              Connection conn = pool.get(<span class="hljs-number">0</span>);              pool.remove(conn);              <span class="hljs-keyword">return</span> conn;          &#125; <span class="hljs-keyword">else</span> &#123;              <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;          &#125;      &#125;  &#125;</code></pre></div><p>通过连接池的管理，实现了数据库连接的共享，不需要每一次都重新创建连接，节省了数据库重新创建的开销，提升了系统的性能！</p><blockquote><p>以上是7种结构型模式，剩下为的11种行为型模式，共11种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。</p></blockquote><p>先来张图，看看这11中模式的关系：<br>第一类：通过父类与子类的关系进行实现。第二类：两个类之间。第三类：类的状态。第四类：通过中间类<br><img src="http://img.my.csdn.net/uploads/201211/30/1354264672_7575.PNG" srcset="/img/loading.gif"></p><h3 id="策略模式（strategy）"><a href="#策略模式（strategy）" class="headerlink" title="策略模式（strategy）"></a>策略模式（strategy）</h3><p>策略模式定义了一系列算法，并将每个算法封装起来，使他们可以相互替换，且算法的变化不会影响到使用算法的客户。需要设计一个接口，为一系列实现类提供统一的方法，多个实现类实现该接口，设计一个抽象类（可有可无，属于辅助类），提供辅助函数，关系图如下：<br><img src="http://img.my.csdn.net/uploads/201211/30/1354268408_3835.PNG" srcset="/img/loading.gif"></p><p>图中ICalculator提供同意的方法，<br>AbstractCalculator是辅助类，提供辅助方法，接下来，依次实现下每个类：<br>首先统一接口：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ICalculator</span> </span>&#123;      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">calculate</span><span class="hljs-params">(String exp)</span></span>;  &#125;</code></pre></div><p>辅助类：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractCalculator</span> </span>&#123;            <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] split(String exp,String opt)&#123;          String array[] = exp.split(opt);          <span class="hljs-keyword">int</span> arrayInt[] = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">2</span>];          arrayInt[<span class="hljs-number">0</span>] = Integer.parseInt(array[<span class="hljs-number">0</span>]);          arrayInt[<span class="hljs-number">1</span>] = Integer.parseInt(array[<span class="hljs-number">1</span>]);          <span class="hljs-keyword">return</span> arrayInt;      &#125;  &#125;</code></pre></div><p>三个实现类：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Plus</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractCalculator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ICalculator</span> </span>&#123;        <span class="hljs-meta">@Override</span>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">calculate</span><span class="hljs-params">(String exp)</span> </span>&#123;          <span class="hljs-keyword">int</span> arrayInt[] = split(exp,<span class="hljs-string">"\\+"</span>);          <span class="hljs-keyword">return</span> arrayInt[<span class="hljs-number">0</span>]+arrayInt[<span class="hljs-number">1</span>];      &#125;  &#125;</code></pre></div><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Minus</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractCalculator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ICalculator</span> </span>&#123;        <span class="hljs-meta">@Override</span>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">calculate</span><span class="hljs-params">(String exp)</span> </span>&#123;          <span class="hljs-keyword">int</span> arrayInt[] = split(exp,<span class="hljs-string">"-"</span>);          <span class="hljs-keyword">return</span> arrayInt[<span class="hljs-number">0</span>]-arrayInt[<span class="hljs-number">1</span>];      &#125;    &#125;</code></pre></div><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Multiply</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractCalculator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ICalculator</span> </span>&#123;        <span class="hljs-meta">@Override</span>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">calculate</span><span class="hljs-params">(String exp)</span> </span>&#123;          <span class="hljs-keyword">int</span> arrayInt[] = split(exp,<span class="hljs-string">"\\*"</span>);          <span class="hljs-keyword">return</span> arrayInt[<span class="hljs-number">0</span>]*arrayInt[<span class="hljs-number">1</span>];      &#125;  &#125;</code></pre></div><p>简单的测试类：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StrategyTest</span> </span>&#123;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;          String exp = <span class="hljs-string">"2+8"</span>;          ICalculator cal = <span class="hljs-keyword">new</span> Plus();          <span class="hljs-keyword">int</span> result = cal.calculate(exp);          System.out.println(result);      &#125;  &#125;</code></pre></div><p>输出：10<br>策略模式的决定权在用户，系统本身提供不同算法的实现，新增或者删除算法，对各种算法做封装。因此，策略模式多用在算法决策系统中，外部用户只需要决定用哪个算法即可。</p><h3 id="模板方法模式（Template-Method）"><a href="#模板方法模式（Template-Method）" class="headerlink" title="模板方法模式（Template Method）"></a>模板方法模式（Template Method）</h3><p>解释一下模板方法模式，就是指：一个抽象类中，有一个主方法，再定义1…n个方法，可以是抽象的，也可以是实际的方法，定义一个类，继承该抽象类，重写抽象方法，通过调用抽象类，实现对子类的调用，先看个关系图：<br><img src="http://img.my.csdn.net/uploads/201211/30/1354283441_1858.PNG" srcset="/img/loading.gif"></p><p>就是在AbstractCalculator类中定义一个主方法calculate，calculate()调用spilt()等，Plus和Minus分别继承AbstractCalculator类，通过对AbstractCalculator的调用实现对子类的调用，看下面的例子：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractCalculator</span> </span>&#123;            <span class="hljs-comment">/*主方法，实现对本类其它方法的调用*/</span>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">calculate</span><span class="hljs-params">(String exp,String opt)</span></span>&#123;          <span class="hljs-keyword">int</span> array[] = split(exp,opt);          <span class="hljs-keyword">return</span> calculate(array[<span class="hljs-number">0</span>],array[<span class="hljs-number">1</span>]);      &#125;            <span class="hljs-comment">/*被子类重写的方法*/</span>      <span class="hljs-function"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">calculate</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num1,<span class="hljs-keyword">int</span> num2)</span></span>;            <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] split(String exp,String opt)&#123;          String array[] = exp.split(opt);          <span class="hljs-keyword">int</span> arrayInt[] = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">2</span>];          arrayInt[<span class="hljs-number">0</span>] = Integer.parseInt(array[<span class="hljs-number">0</span>]);          arrayInt[<span class="hljs-number">1</span>] = Integer.parseInt(array[<span class="hljs-number">1</span>]);          <span class="hljs-keyword">return</span> arrayInt;      &#125;  &#125; ``` ```java<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Plus</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractCalculator</span> </span>&#123;        <span class="hljs-meta">@Override</span>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">calculate</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num1,<span class="hljs-keyword">int</span> num2)</span> </span>&#123;          <span class="hljs-keyword">return</span> num1 + num2;      &#125;  &#125;</code></pre></div><p>测试类：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StrategyTest</span> </span>&#123;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;          String exp = <span class="hljs-string">"8+8"</span>;          AbstractCalculator cal = <span class="hljs-keyword">new</span> Plus();          <span class="hljs-keyword">int</span> result = cal.calculate(exp, <span class="hljs-string">"\\+"</span>);          System.out.println(result);      &#125;  &#125;</code></pre></div><p>我跟踪下这个小程序的执行过程：首先将exp和”\+”做参数，调用AbstractCalculator类里的calculate(String,String)方法，在calculate(String,String)里调用同类的split()，之后再调用calculate(int ,int)方法，从这个方法进入到子类中，执行完return num1 + num2后，将值返回到AbstractCalculator类，赋给result，打印出来。正好验证了我们开头的思路。</p><h3 id="观察者模式（Observer）"><a href="#观察者模式（Observer）" class="headerlink" title="观察者模式（Observer）"></a>观察者模式（Observer）</h3><p>包括这个模式在内的接下来的四个模式，都是类和类之间的关系，不涉及到继承，学的时候应该 记得归纳，记得本文最开始的那个图。观察者模式很好理解，类似于邮件订阅和RSS订阅，当我们浏览一些博客或wiki时，经常会看到RSS图标，就这的意思是，当你订阅了该文章，如果后续有更新，会及时通知你。其实，简单来讲就一句话：当一个对象变化时，其它依赖该对象的对象都会收到通知，并且随着变化！对象之间是一种一对多的关系。先来看看关系图：<br><img src="http://img.my.csdn.net/uploads/201211/30/1354285683_8317.PNG" srcset="/img/loading.gif"></p><p>我解释下这些类的作用：MySubject类就是我们的主对象，Observer1和Observer2是依赖于MySubject的对象，当MySubject变化时，Observer1和Observer2必然变化。AbstractSubject类中定义着需要监控的对象列表，可以对其进行修改：增加或删除被监控对象，且当MySubject变化时，负责通知在列表内存在的对象。我们看实现代码：<br>一个Observer接口：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Observer</span> </span>&#123;      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">()</span></span>;  &#125;</code></pre></div><p>两个实现类：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Observer1</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Observer</span> </span>&#123;        <span class="hljs-meta">@Override</span>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">()</span> </span>&#123;          System.out.println(<span class="hljs-string">"observer1 has received!"</span>);      &#125;  &#125;</code></pre></div><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Observer2</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Observer</span> </span>&#123;        <span class="hljs-meta">@Override</span>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">()</span> </span>&#123;          System.out.println(<span class="hljs-string">"observer2 has received!"</span>);      &#125;    &#125;</code></pre></div><p>Subject接口及实现类：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Subject</span> </span>&#123;            <span class="hljs-comment">/*增加观察者*/</span>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(Observer observer)</span></span>;            <span class="hljs-comment">/*删除观察者*/</span>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">del</span><span class="hljs-params">(Observer observer)</span></span>;            <span class="hljs-comment">/*通知所有的观察者*/</span>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">notifyObservers</span><span class="hljs-params">()</span></span>;            <span class="hljs-comment">/*自身的操作*/</span>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operation</span><span class="hljs-params">()</span></span>;  &#125;```  ```java<span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractSubject</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Subject</span> </span>&#123;        <span class="hljs-keyword">private</span> Vector&lt;Observer&gt; vector = <span class="hljs-keyword">new</span> Vector&lt;Observer&gt;();      <span class="hljs-meta">@Override</span>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(Observer observer)</span> </span>&#123;          vector.add(observer);      &#125;        <span class="hljs-meta">@Override</span>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">del</span><span class="hljs-params">(Observer observer)</span> </span>&#123;          vector.remove(observer);      &#125;        <span class="hljs-meta">@Override</span>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">notifyObservers</span><span class="hljs-params">()</span> </span>&#123;          Enumeration&lt;Observer&gt; enumo = vector.elements();          <span class="hljs-keyword">while</span>(enumo.hasMoreElements())&#123;              enumo.nextElement().update();          &#125;      &#125;  &#125;</code></pre></div><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MySubject</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractSubject</span> </span>&#123;        <span class="hljs-meta">@Override</span>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operation</span><span class="hljs-params">()</span> </span>&#123;          System.out.println(<span class="hljs-string">"update self!"</span>);          notifyObservers();      &#125;    &#125;</code></pre></div><p>测试类：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ObserverTest</span> </span>&#123;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;          Subject sub = <span class="hljs-keyword">new</span> MySubject();          sub.add(<span class="hljs-keyword">new</span> Observer1());          sub.add(<span class="hljs-keyword">new</span> Observer2());                    sub.operation();      &#125;    &#125;</code></pre></div><p>输出：<br>update self!<br>observer1 has received!<br>observer2 has received!</p><p>这些东西，其实不难，只是有些抽象，不太容易整体理解，建议读者：根据关系图，新建项目，自己写代码（或者参考我的代码）,按照总体思路走一遍，这样才能体会它的思想，理解起来容易！</p><h3 id="迭代子模式（Iterator）"><a href="#迭代子模式（Iterator）" class="headerlink" title="迭代子模式（Iterator）"></a>迭代子模式（Iterator）</h3><p>顾名思义，迭代器模式就是顺序访问聚集中的对象，一般来说，集合中非常常见，如果对集合类比较熟悉的话，理解本模式会十分轻松。这句话包含两层意思：一是需要遍历的对象，即聚集对象，二是迭代器对象，用于对聚集对象进行遍历访问。我们看下关系图：<br><img src="http://img.my.csdn.net/uploads/201211/30/1354289861_5945.PNG" srcset="/img/loading.gif"></p><p>这个思路和我们常用的一模一样，MyCollection中定义了集合的一些操作，MyIterator中定义了一系列迭代操作，且持有Collection实例，我们来看看实现代码：<br>两个接口：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Collection</span> </span>&#123;            <span class="hljs-function"><span class="hljs-keyword">public</span> Iterator <span class="hljs-title">iterator</span><span class="hljs-params">()</span></span>;            <span class="hljs-comment">/*取得集合元素*/</span>      <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span></span>;            <span class="hljs-comment">/*取得集合大小*/</span>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span></span>;  &#125;</code></pre></div><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Iterator</span> </span>&#123;      <span class="hljs-comment">//前移  </span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">previous</span><span class="hljs-params">()</span></span>;            <span class="hljs-comment">//后移  </span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">next</span><span class="hljs-params">()</span></span>;      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasNext</span><span class="hljs-params">()</span></span>;            <span class="hljs-comment">//取得第一个元素  </span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">first</span><span class="hljs-params">()</span></span>;  &#125;</code></pre></div><p>两个实现：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyCollection</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Collection</span> </span>&#123;        <span class="hljs-keyword">public</span> String string[] = &#123;<span class="hljs-string">"A"</span>,<span class="hljs-string">"B"</span>,<span class="hljs-string">"C"</span>,<span class="hljs-string">"D"</span>,<span class="hljs-string">"E"</span>&#125;;      <span class="hljs-meta">@Override</span>      <span class="hljs-function"><span class="hljs-keyword">public</span> Iterator <span class="hljs-title">iterator</span><span class="hljs-params">()</span> </span>&#123;          <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> MyIterator(<span class="hljs-keyword">this</span>);      &#125;        <span class="hljs-meta">@Override</span>      <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> </span>&#123;          <span class="hljs-keyword">return</span> string[i];      &#125;        <span class="hljs-meta">@Override</span>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> </span>&#123;          <span class="hljs-keyword">return</span> string.length;      &#125;  &#125;</code></pre></div><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyIterator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Iterator</span> </span>&#123;        <span class="hljs-keyword">private</span> Collection collection;      <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> pos = -<span class="hljs-number">1</span>;            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyIterator</span><span class="hljs-params">(Collection collection)</span></span>&#123;          <span class="hljs-keyword">this</span>.collection = collection;      &#125;            <span class="hljs-meta">@Override</span>      <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">previous</span><span class="hljs-params">()</span> </span>&#123;          <span class="hljs-keyword">if</span>(pos &gt; <span class="hljs-number">0</span>)&#123;              pos--;          &#125;          <span class="hljs-keyword">return</span> collection.get(pos);      &#125;        <span class="hljs-meta">@Override</span>      <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">next</span><span class="hljs-params">()</span> </span>&#123;          <span class="hljs-keyword">if</span>(pos&lt;collection.size()-<span class="hljs-number">1</span>)&#123;              pos++;          &#125;          <span class="hljs-keyword">return</span> collection.get(pos);      &#125;        <span class="hljs-meta">@Override</span>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasNext</span><span class="hljs-params">()</span> </span>&#123;          <span class="hljs-keyword">if</span>(pos&lt;collection.size()-<span class="hljs-number">1</span>)&#123;              <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;          &#125;<span class="hljs-keyword">else</span>&#123;              <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;          &#125;      &#125;        <span class="hljs-meta">@Override</span>      <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">first</span><span class="hljs-params">()</span> </span>&#123;          pos = <span class="hljs-number">0</span>;          <span class="hljs-keyword">return</span> collection.get(pos);      &#125;    &#125;</code></pre></div><p>测试类：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;          Collection collection = <span class="hljs-keyword">new</span> MyCollection();          Iterator it = collection.iterator();                    <span class="hljs-keyword">while</span>(it.hasNext())&#123;              System.out.println(it.next());          &#125;      &#125;  &#125;</code></pre></div><p>输出：A B C D E<br>此处我们貌似模拟了一个集合类的过程，感觉是不是很爽？其实JDK中各个类也都是这些基本的东西，加一些设计模式，再加一些优化放到一起的，只要我们把这些东西学会了，掌握好了，我们也可以写出自己的集合类，甚至框架！</p><h3 id="责任链模式（Chain-of-Responsibility）"><a href="#责任链模式（Chain-of-Responsibility）" class="headerlink" title="责任链模式（Chain of Responsibility）"></a>责任链模式（Chain of Responsibility）</h3><p>接下来我们将要谈谈责任链模式，有多个对象，每个对象持有对下一个对象的引用，这样就会形成一条链，请求在这条链上传递，直到某一对象决定处理该请求。但是发出者并不清楚到底最终那个对象会处理该请求，所以，责任链模式可以实现，在隐瞒客户端的情况下，对系统进行动态的调整。先看看关系图：<br><img src="http://img.my.csdn.net/uploads/201212/01/1354294176_6016.PNG" srcset="/img/loading.gif"></p><p>Abstracthandler类提供了get和set方法，方便MyHandle类设置和修改引用对象，MyHandle类是核心，实例化后生成一系列相互持有的对象，构成一条链。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Handler</span> </span>&#123;      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span></span>;  &#125;  ```java<span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractHandler</span> </span>&#123;            <span class="hljs-keyword">private</span> Handler handler;        <span class="hljs-function"><span class="hljs-keyword">public</span> Handler <span class="hljs-title">getHandler</span><span class="hljs-params">()</span> </span>&#123;          <span class="hljs-keyword">return</span> handler;      &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setHandler</span><span class="hljs-params">(Handler handler)</span> </span>&#123;          <span class="hljs-keyword">this</span>.handler = handler;      &#125;        &#125;</code></pre></div><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Handler</span> </span>&#123;        <span class="hljs-keyword">private</span> String name;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyHandler</span><span class="hljs-params">(String name)</span> </span>&#123;          <span class="hljs-keyword">this</span>.name = name;      &#125;        <span class="hljs-meta">@Override</span>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span> </span>&#123;          System.out.println(name+<span class="hljs-string">"deal!"</span>);          <span class="hljs-keyword">if</span>(getHandler()!=<span class="hljs-keyword">null</span>)&#123;              getHandler().operator();          &#125;      &#125;  &#125;</code></pre></div><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;          MyHandler h1 = <span class="hljs-keyword">new</span> MyHandler(<span class="hljs-string">"h1"</span>);          MyHandler h2 = <span class="hljs-keyword">new</span> MyHandler(<span class="hljs-string">"h2"</span>);          MyHandler h3 = <span class="hljs-keyword">new</span> MyHandler(<span class="hljs-string">"h3"</span>);            h1.setHandler(h2);          h2.setHandler(h3);            h1.operator();      &#125;  &#125;</code></pre></div><p>输出：<br>h1deal!<br>h2deal!<br>h3deal!<br>此处强调一点就是，链接上的请求可以是一条链，可以是一个树，还可以是一个环，模式本身不约束这个，需要我们自己去实现，同时，在一个时刻，命令只允许由一个对象传给另一个对象，而不允许传给多个对象。</p><h3 id="命令模式（Command）"><a href="#命令模式（Command）" class="headerlink" title="命令模式（Command）"></a>命令模式（Command）</h3><p>命令模式很好理解，举个例子，司令员下令让士兵去干件事情，从整个事情的角度来考虑，司令员的作用是，发出口令，口令经过传递，传到了士兵耳朵里，士兵去执行。这个过程好在，三者相互解耦，任何一方都不用去依赖其他人，只需要做好自己的事儿就行，司令员要的是结果，不会去关注到底士兵是怎么实现的。我们看看关系图：<br><img src="http://img.my.csdn.net/uploads/201212/01/1354297121_8890.PNG" srcset="/img/loading.gif"></p><p>Invoker是调用者（司令员），Receiver是被调用者（士兵），MyCommand是命令，实现了Command接口，持有接收对象，看实现代码：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Command</span> </span>&#123;      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exe</span><span class="hljs-params">()</span></span>;  &#125;</code></pre></div><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyCommand</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Command</span> </span>&#123;        <span class="hljs-keyword">private</span> Receiver receiver;            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyCommand</span><span class="hljs-params">(Receiver receiver)</span> </span>&#123;          <span class="hljs-keyword">this</span>.receiver = receiver;      &#125;        <span class="hljs-meta">@Override</span>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exe</span><span class="hljs-params">()</span> </span>&#123;          receiver.action();      &#125;  &#125;</code></pre></div><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Receiver</span> </span>&#123;      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">action</span><span class="hljs-params">()</span></span>&#123;          System.out.println(<span class="hljs-string">"command received!"</span>);      &#125;  &#125;</code></pre></div><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Invoker</span> </span>&#123;            <span class="hljs-keyword">private</span> Command command;            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Invoker</span><span class="hljs-params">(Command command)</span> </span>&#123;          <span class="hljs-keyword">this</span>.command = command;      &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">action</span><span class="hljs-params">()</span></span>&#123;          command.exe();      &#125;  &#125; ``` ```java<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;          Receiver receiver = <span class="hljs-keyword">new</span> Receiver();          Command cmd = <span class="hljs-keyword">new</span> MyCommand(receiver);          Invoker invoker = <span class="hljs-keyword">new</span> Invoker(cmd);          invoker.action();      &#125;  &#125;</code></pre></div><p>输出：command received!<br>这个很哈理解，命令模式的目的就是达到命令的发出者和执行者之间解耦，实现请求和执行分开，熟悉Struts的同学应该知道，Struts其实就是一种将请求和呈现分离的技术，其中必然涉及命令模式的思想！</p><blockquote><p>其实每个设计模式都是很重要的一种思想，看上去很熟，其实是因为我们在学到的东西中都有涉及，尽管有时我们并不知道，其实在Java本身的设计之中处处都有体现，像AWT、JDBC、集合类、IO管道或者是Web框架，里面设计模式无处不在。因为我们篇幅有限，很难讲每一个设计模式都讲的很详细，不过我会尽我所能，尽量在有限的空间和篇幅内，把意思写清楚了，更好让大家明白。以下第三类和第四类。</p></blockquote><h3 id="备忘录模式（Memento）"><a href="#备忘录模式（Memento）" class="headerlink" title="备忘录模式（Memento）"></a>备忘录模式（Memento）</h3><p>主要目的是保存一个对象的某个状态，以便在适当的时候恢复对象，个人觉得叫备份模式更形象些，通俗的讲下：假设有原始类A，A中有各种属性，A可以决定需要备份的属性，备忘录类B是用来存储A的一些内部状态，类C呢，就是一个用来存储备忘录的，且只能存储，不能修改等操作。做个图来分析一下：<br><img src="http://img.my.csdn.net/uploads/201212/01/1354329495_6012.PNG" srcset="/img/loading.gif"></p><p>Original类是原始类，里面有需要保存的属性value及创建一个备忘录类，用来保存value值。Memento类是备忘录类，Storage类是存储备忘录的类，持有Memento类的实例，该模式很好理解。直接看源码：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Original</span> </span>&#123;            <span class="hljs-keyword">private</span> String value;            <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getValue</span><span class="hljs-params">()</span> </span>&#123;          <span class="hljs-keyword">return</span> value;      &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setValue</span><span class="hljs-params">(String value)</span> </span>&#123;          <span class="hljs-keyword">this</span>.value = value;      &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Original</span><span class="hljs-params">(String value)</span> </span>&#123;          <span class="hljs-keyword">this</span>.value = value;      &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> Memento <span class="hljs-title">createMemento</span><span class="hljs-params">()</span></span>&#123;          <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Memento(value);      &#125;            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">restoreMemento</span><span class="hljs-params">(Memento memento)</span></span>&#123;          <span class="hljs-keyword">this</span>.value = memento.getValue();      &#125;  &#125;</code></pre></div><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Memento</span> </span>&#123;            <span class="hljs-keyword">private</span> String value;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Memento</span><span class="hljs-params">(String value)</span> </span>&#123;          <span class="hljs-keyword">this</span>.value = value;      &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getValue</span><span class="hljs-params">()</span> </span>&#123;          <span class="hljs-keyword">return</span> value;      &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setValue</span><span class="hljs-params">(String value)</span> </span>&#123;          <span class="hljs-keyword">this</span>.value = value;      &#125;  &#125;</code></pre></div><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Storage</span> </span>&#123;            <span class="hljs-keyword">private</span> Memento memento;            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Storage</span><span class="hljs-params">(Memento memento)</span> </span>&#123;          <span class="hljs-keyword">this</span>.memento = memento;      &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> Memento <span class="hljs-title">getMemento</span><span class="hljs-params">()</span> </span>&#123;          <span class="hljs-keyword">return</span> memento;      &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setMemento</span><span class="hljs-params">(Memento memento)</span> </span>&#123;          <span class="hljs-keyword">this</span>.memento = memento;      &#125;  &#125;</code></pre></div><p>测试类：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;                    <span class="hljs-comment">// 创建原始类  </span>        Original origi = <span class="hljs-keyword">new</span> Original(<span class="hljs-string">"egg"</span>);            <span class="hljs-comment">// 创建备忘录  </span>        Storage storage = <span class="hljs-keyword">new</span> Storage(origi.createMemento());            <span class="hljs-comment">// 修改原始类的状态  </span>        System.out.println(<span class="hljs-string">"初始化状态为："</span> + origi.getValue());          origi.setValue(<span class="hljs-string">"niu"</span>);          System.out.println(<span class="hljs-string">"修改后的状态为："</span> + origi.getValue());            <span class="hljs-comment">// 回复原始类的状态  </span>        origi.restoreMemento(storage.getMemento());          System.out.println(<span class="hljs-string">"恢复后的状态为："</span> + origi.getValue());      &#125;  &#125;</code></pre></div><p>输出：<br>初始化状态为：egg<br>修改后的状态为：niu<br>恢复后的状态为：egg<br>简单描述下：新建原始类时，value被初始化为egg，后经过修改，将value的值置为niu，最后倒数第二行进行恢复状态，结果成功恢复了。其实我觉得这个模式叫“备份-恢复”模式最形象。</p><h3 id="状态模式（State）"><a href="#状态模式（State）" class="headerlink" title="状态模式（State）"></a>状态模式（State）</h3><p>核心思想就是：当对象的状态改变时，同时改变其行为，很好理解！就拿QQ来说，有几种状态，在线、隐身、忙碌等，每个状态对应不同的操作，而且你的好友也能看到你的状态，所以，状态模式就两点：1、可以通过改变状态来获得不同的行为。2、你的好友能同时看到你的变化。看图：<br><img src="http://img.my.csdn.net/uploads/201212/01/1354367681_4639.PNG" srcset="/img/loading.gif"></p><p>State类是个状态类，Context类可以实现切换，我们来看看代码：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.xtfggef.dp.state;    <span class="hljs-comment">/** </span><span class="hljs-comment"> * 状态类的核心类 </span><span class="hljs-comment"> * 2012-12-1 </span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> erqing </span><span class="hljs-comment"> * </span><span class="hljs-comment"> */</span>  <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">State</span> </span>&#123;            <span class="hljs-keyword">private</span> String value;            <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getValue</span><span class="hljs-params">()</span> </span>&#123;          <span class="hljs-keyword">return</span> value;      &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setValue</span><span class="hljs-params">(String value)</span> </span>&#123;          <span class="hljs-keyword">this</span>.value = value;      &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method1</span><span class="hljs-params">()</span></span>&#123;          System.out.println(<span class="hljs-string">"execute the first opt!"</span>);      &#125;            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method2</span><span class="hljs-params">()</span></span>&#123;          System.out.println(<span class="hljs-string">"execute the second opt!"</span>);      &#125;  &#125;</code></pre></div><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.xtfggef.dp.state;    <span class="hljs-comment">/** </span><span class="hljs-comment"> * 状态模式的切换类   2012-12-1 </span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> erqing </span><span class="hljs-comment"> *  </span><span class="hljs-comment"> */</span>  <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Context</span> </span>&#123;        <span class="hljs-keyword">private</span> State state;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Context</span><span class="hljs-params">(State state)</span> </span>&#123;          <span class="hljs-keyword">this</span>.state = state;      &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> State <span class="hljs-title">getState</span><span class="hljs-params">()</span> </span>&#123;          <span class="hljs-keyword">return</span> state;      &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setState</span><span class="hljs-params">(State state)</span> </span>&#123;          <span class="hljs-keyword">this</span>.state = state;      &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method</span><span class="hljs-params">()</span> </span>&#123;          <span class="hljs-keyword">if</span> (state.getValue().equals(<span class="hljs-string">"state1"</span>)) &#123;              state.method1();          &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (state.getValue().equals(<span class="hljs-string">"state2"</span>)) &#123;              state.method2();          &#125;      &#125;  &#125;</code></pre></div><p>测试类：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;                    State state = <span class="hljs-keyword">new</span> State();          Context context = <span class="hljs-keyword">new</span> Context(state);                    <span class="hljs-comment">//设置第一种状态  </span>        state.setValue(<span class="hljs-string">"state1"</span>);          context.method();                    <span class="hljs-comment">//设置第二种状态  </span>        state.setValue(<span class="hljs-string">"state2"</span>);          context.method();      &#125;  &#125;</code></pre></div><p>输出：<br>execute the first opt!<br>execute the second opt!<br>根据这个特性，状态模式在日常开发中用的挺多的，尤其是做网站的时候，我们有时希望根据对象的某一属性，区别开他们的一些功能，比如说简单的权限控制等。</p><h3 id="访问者模式（Visitor）"><a href="#访问者模式（Visitor）" class="headerlink" title="访问者模式（Visitor）"></a>访问者模式（Visitor）</h3><p>访问者模式把数据结构和作用于结构上的操作解耦合，使得操作集合可相对自由地演化。访问者模式适用于数据结构相对稳定算法又易变化的系统。因为访问者模式使得算法操作增加变得容易。若系统数据结构对象易于变化，经常有新的数据对象增加进来，则不适合使用访问者模式。访问者模式的优点是增加操作很容易，因为增加操作意味着增加新的访问者。访问者模式将有关行为集中到一个访问者对象中，其改变不影响系统数据结构。其缺点就是增加新的数据结构很困难。—— From 百科<br>简单来说，访问者模式就是一种分离对象数据结构与行为的方法，通过这种分离，可达到为一个被访问者动态添加新的操作而无需做其它的修改的效果。简单关系图：<br><img src="http://img.my.csdn.net/uploads/201212/01/1354372253_7681.PNG" srcset="/img/loading.gif"></p><p>来看看原码：一个Visitor类，存放要访问的对象，</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Visitor</span> </span>&#123;      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">visit</span><span class="hljs-params">(Subject sub)</span></span>;  &#125;</code></pre></div><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyVisitor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Visitor</span> </span>&#123;        <span class="hljs-meta">@Override</span>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">visit</span><span class="hljs-params">(Subject sub)</span> </span>&#123;          System.out.println(<span class="hljs-string">"visit the subject："</span>+sub.getSubject());      &#125;  &#125;</code></pre></div><p>Subject类，accept方法，接受将要访问它的对象，getSubject()获取将要被访问的属性，</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Subject</span> </span>&#123;      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">accept</span><span class="hljs-params">(Visitor visitor)</span></span>;      <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getSubject</span><span class="hljs-params">()</span></span>;  &#125;</code></pre></div><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MySubject</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Subject</span> </span>&#123;        <span class="hljs-meta">@Override</span>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">accept</span><span class="hljs-params">(Visitor visitor)</span> </span>&#123;          visitor.visit(<span class="hljs-keyword">this</span>);      &#125;        <span class="hljs-meta">@Override</span>      <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getSubject</span><span class="hljs-params">()</span> </span>&#123;          <span class="hljs-keyword">return</span> <span class="hljs-string">"love"</span>;      &#125;  &#125;</code></pre></div><p>测试：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;                    Visitor visitor = <span class="hljs-keyword">new</span> MyVisitor();          Subject sub = <span class="hljs-keyword">new</span> MySubject();          sub.accept(visitor);          &#125;  &#125;</code></pre></div><p>输出：visit the subject：love<br>该模式适用场景：如果我们想为一个现有的类增加新功能，不得不考虑几个事情：1、新功能会不会与现有功能出现兼容性问题？2、以后会不会再需要添加？3、如果类不允许修改代码怎么办？面对这些问题，最好的解决方法就是使用访问者模式，访问者模式适用于数据结构相对稳定的系统，把数据结构和算法解耦，</p><h3 id="中介者模式（Mediator）"><a href="#中介者模式（Mediator）" class="headerlink" title="中介者模式（Mediator）"></a>中介者模式（Mediator）</h3><p>中介者模式也是用来降低类类之间的耦合的，因为如果类类之间有依赖关系的话，不利于功能的拓展和维护，因为只要修改一个对象，其它关联的对象都得进行修改。如果使用中介者模式，只需关心和Mediator类的关系，具体类类之间的关系及调度交给Mediator就行，这有点像spring容器的作用。先看看图：<br><img src="http://img.my.csdn.net/uploads/201212/01/1354375826_1485.PNG" srcset="/img/loading.gif"></p><p>User类统一接口，User1和User2分别是不同的对象，二者之间有关联，如果不采用中介者模式，则需要二者相互持有引用，这样二者的耦合度很高，为了解耦，引入了Mediator类，提供统一接口，MyMediator为其实现类，里面持有User1和User2的实例，用来实现对User1和User2的控制。这样User1和User2两个对象相互独立，他们只需要保持好和Mediator之间的关系就行，剩下的全由MyMediator类来维护！基本实现：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Mediator</span> </span>&#123;      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">createMediator</span><span class="hljs-params">()</span></span>;      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">workAll</span><span class="hljs-params">()</span></span>;  &#125;</code></pre></div><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyMediator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Mediator</span> </span>&#123;        <span class="hljs-keyword">private</span> User user1;      <span class="hljs-keyword">private</span> User user2;            <span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">getUser1</span><span class="hljs-params">()</span> </span>&#123;          <span class="hljs-keyword">return</span> user1;      &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">getUser2</span><span class="hljs-params">()</span> </span>&#123;          <span class="hljs-keyword">return</span> user2;      &#125;        <span class="hljs-meta">@Override</span>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">createMediator</span><span class="hljs-params">()</span> </span>&#123;          user1 = <span class="hljs-keyword">new</span> User1(<span class="hljs-keyword">this</span>);          user2 = <span class="hljs-keyword">new</span> User2(<span class="hljs-keyword">this</span>);      &#125;        <span class="hljs-meta">@Override</span>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">workAll</span><span class="hljs-params">()</span> </span>&#123;          user1.work();          user2.work();      &#125;  &#125;</code></pre></div><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;            <span class="hljs-keyword">private</span> Mediator mediator;            <span class="hljs-function"><span class="hljs-keyword">public</span> Mediator <span class="hljs-title">getMediator</span><span class="hljs-params">()</span></span>&#123;          <span class="hljs-keyword">return</span> mediator;      &#125;            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">User</span><span class="hljs-params">(Mediator mediator)</span> </span>&#123;          <span class="hljs-keyword">this</span>.mediator = mediator;      &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">work</span><span class="hljs-params">()</span></span>;  &#125;</code></pre></div><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User1</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">User</span> </span>&#123;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">User1</span><span class="hljs-params">(Mediator mediator)</span></span>&#123;          <span class="hljs-keyword">super</span>(mediator);      &#125;            <span class="hljs-meta">@Override</span>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">work</span><span class="hljs-params">()</span> </span>&#123;          System.out.println(<span class="hljs-string">"user1 exe!"</span>);      &#125;  &#125;</code></pre></div><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User2</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">User</span> </span>&#123;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">User2</span><span class="hljs-params">(Mediator mediator)</span></span>&#123;          <span class="hljs-keyword">super</span>(mediator);      &#125;            <span class="hljs-meta">@Override</span>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">work</span><span class="hljs-params">()</span> </span>&#123;          System.out.println(<span class="hljs-string">"user2 exe!"</span>);      &#125;  &#125;</code></pre></div><p>测试类：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;          Mediator mediator = <span class="hljs-keyword">new</span> MyMediator();          mediator.createMediator();          mediator.workAll();      &#125;  &#125;</code></pre></div><p>输出：<br>user1 exe!<br>user2 exe!</p><h3 id="解释器模式（Interpreter）"><a href="#解释器模式（Interpreter）" class="headerlink" title="解释器模式（Interpreter）"></a>解释器模式（Interpreter）</h3><p>解释器模式是我们暂时的最后一讲，一般主要应用在OOP开发中的编译器的开发中，所以适用面比较窄。<br><img src="http://img.my.csdn.net/uploads/201212/02/1354377970_2591.PNG" srcset="/img/loading.gif"></p><p>Context类是一个上下文环境类，Plus和Minus分别是用来计算的实现，代码如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Expression</span> </span>&#123;      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">interpret</span><span class="hljs-params">(Context context)</span></span>;  &#125;</code></pre></div><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Plus</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Expression</span> </span>&#123;        <span class="hljs-meta">@Override</span>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">interpret</span><span class="hljs-params">(Context context)</span> </span>&#123;          <span class="hljs-keyword">return</span> context.getNum1()+context.getNum2();      &#125;  &#125; ``` ```java<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Minus</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Expression</span> </span>&#123;        <span class="hljs-meta">@Override</span>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">interpret</span><span class="hljs-params">(Context context)</span> </span>&#123;          <span class="hljs-keyword">return</span> context.getNum1()-context.getNum2();      &#125;  &#125;</code></pre></div><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Context</span> </span>&#123;            <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> num1;      <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> num2;            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Context</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num1, <span class="hljs-keyword">int</span> num2)</span> </span>&#123;          <span class="hljs-keyword">this</span>.num1 = num1;          <span class="hljs-keyword">this</span>.num2 = num2;      &#125;            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getNum1</span><span class="hljs-params">()</span> </span>&#123;          <span class="hljs-keyword">return</span> num1;      &#125;      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setNum1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num1)</span> </span>&#123;          <span class="hljs-keyword">this</span>.num1 = num1;      &#125;      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getNum2</span><span class="hljs-params">()</span> </span>&#123;          <span class="hljs-keyword">return</span> num2;      &#125;      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setNum2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num2)</span> </span>&#123;          <span class="hljs-keyword">this</span>.num2 = num2;      &#125;              &#125; ``` ```java<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;            <span class="hljs-comment">// 计算9+2-8的值  </span>        <span class="hljs-keyword">int</span> result = <span class="hljs-keyword">new</span> Minus().interpret((<span class="hljs-keyword">new</span> Context(<span class="hljs-keyword">new</span> Plus()                  .interpret(<span class="hljs-keyword">new</span> Context(<span class="hljs-number">9</span>, <span class="hljs-number">2</span>)), <span class="hljs-number">8</span>)));          System.out.println(result);      &#125;  &#125;</code></pre></div><p>最后输出正确的结果：3。<br>基本就这样，解释器模式用来做各种各样的解释器，如正则表达式等的解释器等等！</p><blockquote><p>设计模式基本就这么大概讲完了，总体感觉有点简略，的确，这么点儿篇幅，不足以对整个23种设计模式做全面的阐述，此处读者可将它作为一个理论基础去学习.</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>获取java的调用者信息栈</title>
    <link href="/2017/04/17/%E8%8E%B7%E5%8F%96java%E7%9A%84%E8%B0%83%E7%94%A8%E8%80%85%E4%BF%A1%E6%81%AF%E6%A0%88/"/>
    <url>/2017/04/17/%E8%8E%B7%E5%8F%96java%E7%9A%84%E8%B0%83%E7%94%A8%E8%80%85%E4%BF%A1%E6%81%AF%E6%A0%88/</url>
    
    <content type="html"><![CDATA[<p>获取某块代码的调用者信息，打印到控制台中<a id="more"></a></p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printCaller</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">try</span> &#123;        StackTraceElement[] trace = <span class="hljs-keyword">new</span> Throwable().fillInStackTrace().getStackTrace();        String caller = <span class="hljs-string">""</span>;        String callingClass = <span class="hljs-string">""</span>;        String callFile = <span class="hljs-string">""</span>;        <span class="hljs-keyword">int</span> lineNumber = <span class="hljs-number">0</span>;        System.out.println(<span class="hljs-string">"==========BEGIN OF CALLER INFO============"</span>);        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt; trace.length; i++) &#123;            callingClass = trace[i].getClassName();            callingClass = callingClass.substring(callingClass                    .lastIndexOf(<span class="hljs-string">'.'</span>) + <span class="hljs-number">1</span>);            caller = trace[i].getMethodName();            callFile = trace[i].getFileName();            lineNumber = trace[i].getLineNumber();            String method = String.format(Locale.US, <span class="hljs-string">"[%03d] %s.%s(%s:%d)"</span>                    , Thread.currentThread().getId(), callingClass, caller, callFile, lineNumber);            System.out.println(method);        &#125;        System.out.println(<span class="hljs-string">"==========END OF CALLER INFO============"</span>);    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;        e.printStackTrace();    &#125;&#125;</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>好用的Android开发工具类库</title>
    <link href="/2017/04/13/%E5%A5%BD%E7%94%A8%E7%9A%84Android%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB%E5%BA%93/"/>
    <url>/2017/04/13/%E5%A5%BD%E7%94%A8%E7%9A%84Android%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<p>这些类库用起来丝般顺滑，源码写的也特别棒。</p><blockquote><p>Read The Fucking Source Code</p></blockquote><a id="more"></a><p>收藏好用的Android开发工具类库 不定期更新中。。</p><hr><p>eventbus<br>greendao<br>butterknife<br>guava<br>fastjson<br>okhttp<br>glide<br>retrofit<br>rxpermissions<br>zxing</p><hr><p>compile ‘com.zhy:okhttputils:2.6.2’ // okhttp下的支持库 支持https等<br>compile ‘com.github.CymChad:BaseRecyclerViewAdapterHelper:v1.9.8’<br>compile ‘de.hdodenhof:circleimageview:2.1.0’ // 圆形图片<br>compile ‘com.github.niorgai:StatusBarCompat:1.1.0’ // 状态栏适配<br>compile ‘com.baoyz.actionsheet:library:1.1.6’ // 底部菜单 仿苹果<br>compile ‘com.github.SilenceDut:ExpandableLayout:v1.0.1’ // 可折叠item<br>compile ‘com.github.lovetuzitong:MultiImageSelector:1.2’ // 图片选择器</p><hr><p>leakcanary // 内存泄漏分析<br>stetho // 与chrome连接调试</p><hr><p>umeng // 统计相关</p>]]></content>
    
    
    
    <tags>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【android测试】adb shell svc命令</title>
    <link href="/2017/02/11/%E3%80%90android%E6%B5%8B%E8%AF%95%E3%80%91adb-shell-svc%E5%91%BD%E4%BB%A4/"/>
    <url>/2017/02/11/%E3%80%90android%E6%B5%8B%E8%AF%95%E3%80%91adb-shell-svc%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<p>svc命令<br>    这个脚本在/system/bin目录下，这个命令可以用来控制电源管理，wifi开关，数据开关(就是上网流量)</p><a id="more"></a><blockquote><p>svc power stayon [true|false|usb|ac]  </p></blockquote><p>设置屏幕的常亮，true保持常亮，false不保持，usb当插入usb时常亮，ac当插入电源时常亮      </p><blockquote><p>svc data disable</p></blockquote><p>这个命令可以关闭数据连接，就是上网流量，大家都知道控制上网的开关很多， 但是大都是通过在apn上的接入点加后缀来实现的，但是这个命令不会更改apn的任何设置，直接在底层关闭数据连接。 应该是最彻底的，而且又不影响apn的设置。这个跟apndroid有什么区别，apndroid是在关闭上网数据的时候，已经在下载的连接可能不会被强 制关闭(这个在apndroid自己的说明中也有提到)。比如你在下载一个10M的电影，下载了1M，不响下载了。用apndroid关闭连接，可能这个 下载还会继续，不会马上停掉。但是用这个命令，绝对毫不留情的咔嚓掉。</p><blockquote><p>svc data enable </p></blockquote><p>这个是打开上网数据连接，跟上一个命令是相反的。</p><blockquote><p>svc data prefer</p></blockquote><p>这个命令是控制3g数据连接比wifi优先。我们都知道，正常情况下，有wifi的时候，不会用到3g连接。但是这个命令是相反，有3g的话先用3g流量，没有3g的时候采用wifi.我想大家不会这么傻吧，所以这个命令没什么用。</p><blockquote><p>svc wifi disable </p></blockquote><p>关闭wifi 连接</p><blockquote><p>svc wifi enable </p></blockquote><p>开启wifi连接</p><blockquote><p>svc wifi prefer </p></blockquote><p>设置WIFI优先于移动网络的数据，一般应设置成这样，除非你刻意使用移动网络数据传输</p><blockquote><p>.watchprosp 动态监视android系统属性的变化，有变化就会输出:</p></blockquote><div class="hljs"><pre><code class="hljs stylus">C:\Users\beijing_zbs&gt;adb shell$ watchprops persist<span class="hljs-selector-class">.sys</span>.autolanguagewatchprops persist<span class="hljs-selector-class">.sys</span>.autolanguage<span class="hljs-number">1418093713</span> sys<span class="hljs-selector-class">.settings_secure_version</span> = <span class="hljs-string">'213'</span><span class="hljs-number">1418093719</span> persist<span class="hljs-selector-class">.sys</span><span class="hljs-selector-class">.localevar</span> = <span class="hljs-string">''</span><span class="hljs-number">1418093719</span> persist<span class="hljs-selector-class">.sys</span><span class="hljs-selector-class">.language</span> = <span class="hljs-string">'en'</span><span class="hljs-number">1418093719</span> persist<span class="hljs-selector-class">.sys</span><span class="hljs-selector-class">.country</span> = <span class="hljs-string">'US'</span><span class="hljs-number">1418093733</span> persist<span class="hljs-selector-class">.sys</span><span class="hljs-selector-class">.language</span> = <span class="hljs-string">'zh'</span><span class="hljs-number">1418093733</span> persist<span class="hljs-selector-class">.sys</span><span class="hljs-selector-class">.country</span> = <span class="hljs-string">'CN'</span><span class="hljs-number">1418093733</span> persist<span class="hljs-selector-class">.sys</span><span class="hljs-selector-class">.localevar</span> = <span class="hljs-string">''</span></code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>shell</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>我的2017</title>
    <link href="/2017/02/01/%E6%88%91%E7%9A%842017/"/>
    <url>/2017/02/01/%E6%88%91%E7%9A%842017/</url>
    
    <content type="html"><![CDATA[<p>我的新年计划，（吹个牛逼）</p><a id="more"></a><p>新年新气象，新年新计划，嗨起来！<br>2017，农历鸡年，本命年，自己也24了。</p><ol><li>看书 把买的书看完</li><li>增重</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>计划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>配置ssh服务器别名</title>
    <link href="/2016/12/07/%E9%85%8D%E7%BD%AEssh%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%88%AB%E5%90%8D/"/>
    <url>/2016/12/07/%E9%85%8D%E7%BD%AEssh%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%88%AB%E5%90%8D/</url>
    
    <content type="html"><![CDATA[<div class="hljs"><pre><code class="hljs routeros">cd ~/.sshvim configHost baal   HostName xxx.xxx.xxx.xxx  <span class="hljs-built_in"> User </span>xxxx   IdentityFile  ~/.ssh/id_rsa.pub   IdentitiesOnly <span class="hljs-literal">yes</span>ssh baal</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>ssh</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>记住Git密码</title>
    <link href="/2016/12/07/%E8%AE%B0%E4%BD%8FGit%E5%AF%86%E7%A0%81/"/>
    <url>/2016/12/07/%E8%AE%B0%E4%BD%8FGit%E5%AF%86%E7%A0%81/</url>
    
    <content type="html"><![CDATA[<p>每次操作都需要输入用户名和密码感觉很繁琐，解决方法，在本地的工程文件夹的.git下打开config文件<br>添加：</p><div class="hljs"><pre><code class="hljs cs">[<span class="hljs-meta">credential</span>]     helper = store</code></pre></div><p>再输入一次用户名密码后就可以保存住了。</p>]]></content>
    
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>tmux config</title>
    <link href="/2016/12/02/tmux-config/"/>
    <url>/2016/12/02/tmux-config/</url>
    
    <content type="html"><![CDATA[<p>tmux的简单配置</p><a id="more"></a><div class="hljs"><pre><code class="hljs sql"><span class="hljs-comment"># Set a Ctrl-b shortcut for reloading your tmux config</span>unbind rbind r source-file ~/.tmux.conf<span class="hljs-comment"># bind . to rename session</span>unbind .bind . command-prompt -I "<span class="hljs-comment">#S" "rename-session %%"</span><span class="hljs-comment"># bind prefix key</span><span class="hljs-keyword">set</span> -g prefix ^aunbind ^bbind a send-prefix<span class="hljs-comment"># Movement</span>bind ^k selectp -U <span class="hljs-comment"># 选择上窗格</span>bind ^j selectp -D <span class="hljs-comment"># 选择下窗格</span>bind ^h selectp -L <span class="hljs-comment"># 选择左窗格</span>bind ^l selectp -R <span class="hljs-comment"># 选择右窗格</span>bind h selectw -p <span class="hljs-comment"># 选择上窗口</span>bind l selectw -n <span class="hljs-comment"># 选择下窗口</span>bind-<span class="hljs-keyword">key</span> &lt; swap-<span class="hljs-keyword">window</span> -t - <span class="hljs-comment"># 移动窗口到上一个</span>bind-<span class="hljs-keyword">key</span> &gt; swap-<span class="hljs-keyword">window</span> -t + <span class="hljs-comment"># 移动窗口到下一个</span><span class="hljs-comment"># split panel</span>bind \ <span class="hljs-keyword">split</span>-<span class="hljs-keyword">window</span> -hbind - <span class="hljs-keyword">split</span>-<span class="hljs-keyword">window</span> -v<span class="hljs-comment">#Set default terminal to 256 colors</span><span class="hljs-keyword">set</span> -g <span class="hljs-keyword">default</span>-terminal <span class="hljs-string">"screen-256color"</span><span class="hljs-comment"># vim helper</span><span class="hljs-keyword">set</span> -g <span class="hljs-keyword">mode</span>-<span class="hljs-keyword">keys</span> vi<span class="hljs-keyword">set</span> -g <span class="hljs-keyword">status</span>-<span class="hljs-keyword">keys</span> vi<span class="hljs-keyword">set</span> -g <span class="hljs-keyword">window</span>-<span class="hljs-keyword">status</span>-<span class="hljs-keyword">current</span>-<span class="hljs-keyword">attr</span> underscore<span class="hljs-comment"># Add some nice copy and paste shortcuts.</span>bind -t vi-copy v <span class="hljs-keyword">begin</span>-selectionbind -t vi-copy y copy-selectionbind -t vi-copy V rectangle-toggle<span class="hljs-comment"># mix</span><span class="hljs-keyword">set</span> -g escape-<span class="hljs-built_in">time</span> <span class="hljs-number">0</span><span class="hljs-keyword">set</span> -g aggressive-<span class="hljs-keyword">resize</span> <span class="hljs-keyword">on</span><span class="hljs-keyword">set</span> -g history-<span class="hljs-keyword">limit</span> <span class="hljs-number">20000</span><span class="hljs-keyword">set</span> -g visual-activity <span class="hljs-keyword">off</span>bind s <span class="hljs-keyword">choose</span>-<span class="hljs-keyword">session</span><span class="hljs-comment"># title</span><span class="hljs-keyword">set</span> -g <span class="hljs-keyword">set</span>-titles <span class="hljs-keyword">on</span><span class="hljs-keyword">set</span> -g <span class="hljs-keyword">set</span>-titles-<span class="hljs-keyword">string</span> <span class="hljs-string">'#T TMUX:#S.#I.#P #W'</span> <span class="hljs-comment"># window number,program name,active (or not)</span><span class="hljs-comment"># status bar</span><span class="hljs-keyword">set</span> -g <span class="hljs-keyword">status</span> <span class="hljs-keyword">on</span><span class="hljs-keyword">set</span> -g <span class="hljs-keyword">status</span>-utf8 <span class="hljs-keyword">on</span><span class="hljs-keyword">set</span> -g <span class="hljs-keyword">status</span>-<span class="hljs-built_in">interval</span> <span class="hljs-number">1</span><span class="hljs-keyword">set</span> -g <span class="hljs-keyword">status</span>-<span class="hljs-keyword">left</span>-<span class="hljs-keyword">length</span> <span class="hljs-number">60</span><span class="hljs-keyword">set</span> -g <span class="hljs-keyword">status</span>-<span class="hljs-keyword">right</span>-<span class="hljs-keyword">length</span> <span class="hljs-number">90</span><span class="hljs-keyword">set</span> -g <span class="hljs-keyword">status</span>-<span class="hljs-keyword">left</span> <span class="hljs-string">'#[fg=green]#S'</span><span class="hljs-keyword">set</span> -g <span class="hljs-keyword">status</span>-<span class="hljs-keyword">right</span> <span class="hljs-string">'#[fg=yellow]#(uptime | egrep -o "[0-9]+ users?, +load.*"|perl -pe "s| averages?||"), %H:%M:%S'</span><span class="hljs-comment"># COLORS</span><span class="hljs-keyword">set</span> -g pane-border-fg colour236<span class="hljs-keyword">set</span> -g pane-border-bg black<span class="hljs-keyword">set</span> -g pane-active-border-fg colour245<span class="hljs-keyword">set</span> -g pane-active-border-bg black<span class="hljs-keyword">set</span> -g message-fg black<span class="hljs-keyword">set</span> -g message-bg green<span class="hljs-keyword">set</span> -g <span class="hljs-keyword">status</span>-bg colour236<span class="hljs-keyword">set</span> -g <span class="hljs-keyword">status</span>-fg colour241<span class="hljs-keyword">set</span> -g <span class="hljs-keyword">window</span>-<span class="hljs-keyword">status</span>-fg <span class="hljs-keyword">default</span><span class="hljs-keyword">set</span> -g <span class="hljs-keyword">window</span>-<span class="hljs-keyword">status</span>-bg <span class="hljs-keyword">default</span><span class="hljs-keyword">set</span> -g <span class="hljs-keyword">window</span>-<span class="hljs-keyword">status</span>-<span class="hljs-keyword">current</span>-bg colour235<span class="hljs-keyword">set</span> -g <span class="hljs-keyword">window</span>-<span class="hljs-keyword">status</span>-<span class="hljs-keyword">current</span>-fg colour255</code></pre></div>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>[转载]awesome-android-tips</title>
    <link href="/2016/08/05/%E8%BD%AC%E8%BD%BD-awesome-android-tips/"/>
    <url>/2016/08/05/%E8%BD%AC%E8%BD%BD-awesome-android-tips/</url>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/jiang111/awesome-android-tips">原文链接</a></p><a id="more"></a><h1 id="awesome-android-tips"><a href="#awesome-android-tips" class="headerlink" title="awesome-android-tips"></a>awesome-android-tips</h1><p>Android tips    </p><p>English_Version:<a href="https://github.com/jiang111/awesome-android-tips/blob/master/English_Version/README.md">https://github.com/jiang111/awesome-android-tips/blob/master/English_Version/README.md</a></p><p>这里收集了大家常用的一些Android代码,持续更新中,内容来自自己的平时积累和网络上看到的文章，部分原文地址在最下方。如有错误欢迎指正,如有侵权,请联系我删除。里面可能会有重复内容,请忽略或者提醒我删除。</p><blockquote><ul><li>setBackgroundResource(0) 可以移除 View 的背景色</li></ul></blockquote><blockquote><ul><li>Resources.getSystem().getDisplayMetrics().density 可以不用 Context 也能获取屏幕密度哦</li></ul></blockquote><blockquote><ul><li>通过重载 ViewGroup 的 dispatchDraw 可以实现一个简单的蒙版效果。 例如下拉刷新时，可以在 contentView 上加一层遮罩。 canvas.drawRect(0, mContentView.getTranslationY(), getWidth(), getHeight(), mMaskPaint);</li></ul></blockquote><blockquote><ul><li>new 出来的 View 可以用 View.generateViewId() （API 17 以上可用）   生成 id，系统保证唯一</li></ul></blockquote><blockquote><ul><li>使用 GridView时 android:padding 和 android:clipToPadding=”false” 配合使用效果更好哦。</li></ul></blockquote><blockquote><ul><li>在布局文件中，如果只是为了占位，可以用 Space 来取代 View。 最棒的一点是Space可以跳过 Draw 这个过程。</li></ul></blockquote><blockquote><ul><li>TypedValue.applyDimension(int unit, float value, DisplayMetrics metrics) 方便dp, px, sp 之间的转换。</li></ul></blockquote><blockquote><ul><li>Activity.startActivities() 这个方法最直接的理解就是使用intent开启多个Activity</li></ul></blockquote><blockquote><ul><li>TextUtils.isEmpty() 如果传入的String 为NULL或者Length为0的话就返回 true。</li></ul></blockquote><blockquote><ul><li>Html.fromHtml() 如果你对Html熟悉的话，可以很迅速通过这个方法处理一些富文本操作。比如超链接和图文排版等处理。</li></ul></blockquote><blockquote><ul><li>TextView.setError() 设置文本框错误提醒</li></ul></blockquote><blockquote><ul><li>Build.VERSION_CODES 有些时候我们的app需要根据不同的SDK版本进行执行不同的操作</li></ul></blockquote><blockquote><ul><li>PhoneNumberUtils.convertKeypadLettersToDigits 这个方法简单粗暴，会将输入的字母根据键盘上的映射转换为数字。</li></ul></blockquote><blockquote><ul><li>ArgbEvaluator ArgbEvaluator.evaluate(float fraction, Object startValue, Object endValue);根据一个起始颜色值和一个结束颜色值以及一个偏移量生成一个新的颜色，分分钟实现类似于微信底部栏滑动颜色渐变。</li></ul></blockquote><blockquote><ul><li>ValueAnimator.reverse() 顺畅的取消动画效果</li></ul></blockquote><blockquote><ul><li>DateUtils.formatDateTime()) 这个方法可以输出相应格式化的时间或者日期</li></ul></blockquote><blockquote><ul><li>Pair 这个类 可以用来存储存储一”组”数据。但不是key和value的关系。</li></ul></blockquote><blockquote><ul><li>SparseArray 目前有很多地方从性能优化方说使用SparseArray来替换hashMap，来节省内存，提高性能。</li></ul></blockquote><blockquote><ul><li>Linkify.addLinks() 这个类可以更方便的为文本添加超链接。</li></ul></blockquote><blockquote><ul><li>android.media.ThumbnailUtils这个类主要是用来处理缩略图相关的工作,比如:用来获取媒体（图片、视频）的缩略图;</li></ul></blockquote><blockquote><ul><li>Bitmap.extractAlpha ();返回一个新的Bitmap，capture原始图片的alpha值。有的时候我们需要动态的修改一个元素的背景图片又不希望使用多张图片的时候，通过这个方法，结合Canvas和Paint可以动态的修改一个纯色Bitmap的颜色。</li></ul></blockquote><blockquote><ul><li>模块间有消息需要传递时，使用LocalBroadcastManager替代Listener进行模块解耦。除了解耦，这样发送消息和执行消息差一个线程循环，可以减小方法的调用链，我这就碰到一次方法调用链太长导致StackOverflow的问题。</li></ul></blockquote><blockquote><ul><li>静态变量不要直接或者间接引用Activity、Service等。这会使用Activity以及它所引用的所有对象无法释放，然后，用户操作时间一长，内存就会狂升。</li></ul></blockquote><blockquote><ul><li>Handler机制有一个特点是不会随着Activity、Service的生命周期结束而结束。也就是说，如果你Post了一个Delay的Runnable，然后在Runnable执行之前退出了Activity，Runnable到时间之后还是要执行的。如果Runnable里面包含更新View的操作，程序崩溃了。</li></ul></blockquote><blockquote><ul><li>不少人在子线程中更新View时喜欢使用Context.runOnUiThread，这个方法有个缺点，就是一但Context生命周期结束，比如Activity已经销毁时，一调用就会崩溃。</li></ul></blockquote><blockquote><ul><li>SharedPreferences.Editor.commit这个方法是同步的，一直到把数据同步到Flash上面之后才会返回，由IO操作的不可控，尽量使用apply方法代替。apply只在API Level&gt;=9才会支持，需要做兼容。不过，最新的 <code>support v4</code> 包已经为我们做好了处理，使用  <code>SharedPreferencesCompat.EditorCompat.getInstance().apply(editor)</code> 即可。</li></ul></blockquote><blockquote><ul><li>PackageManager.getInstalledPackages这个方法经常使用，你可能不知道，当获取的结果数量比较多的时候，在某些机型上面调用它花费的时间可能秒级的，所以尽量在子线程中使用。另外，如果结果太多，超过系统设置的Binder数据最大传输量的上限，则会发生TransactionException，如果你使用这个方法获取机器上的己安装应用列表，最好做一下预防。</li></ul></blockquote><blockquote><ul><li>如果使用Context.startActivity启动外部应用，最好做一下异常预防，因为寻找不到对应的应用时，会抛出异常。如果你要打开的是应用内的Activity，不防使用显式Intent，这样能提高系统搜索目标Activity的效率。</li></ul></blockquote><blockquote><ul><li>Application的生命周期就是进程的生命周期。只有进程被干掉时，Application才会销毁。哪怕是没有Activity、Service在运行，Application也会存在。所以，为了减少内存压力，尽量不要在Application里面引用大对象、Context等。</li></ul></blockquote><blockquote><ul><li>getWindow().setLayout(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT);设置全屏方法一定要在setContentView之后</li></ul></blockquote><blockquote><ul><li>viewpager 的 setCurrentItem 一定要在 setAdapter 方法之后调用才会有效果.</li></ul></blockquote><blockquote><ul><li>判断手机是不是飞行模式  boolean isEnabled = Settings.System.getInt(context.getContentResolver(), Settings.System.AIRPLANE_MODE_ON, 0) == 1;</li></ul></blockquote><blockquote><ul><li>TabLayout 修改字体的方法<br>官方的 TabLayout 没有提供修改 TextView size 的方法，可以新建一个 style CustomTabLayoutTextAppearance 继承 TextAppearance.AppCompat.Widget.ActionBar.Title.Inverse ，然后增加 item ，设置 android:textAllCaps 为 true ，再设置 android:textSize 为你想设置的大小。<br><img src="http://ww1.sinaimg.cn/large/640f03afjw1ex0t17aj67j20uk0580uf.jpg" srcset="/img/loading.gif" alt=""><br>再在 TabLayout 的布局文件里设置 app:tabTextAppearance=”@style/CustomTabLayoutTextAppearance” 即可。<br><img src="http://ww1.sinaimg.cn/large/640f03afjw1ex0t1gub93j20ru0a477q.jpg" srcset="/img/loading.gif" alt=""></li></ul></blockquote><blockquote><ul><li>遍历HashMap的最佳方法</li></ul></blockquote><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printMap</span><span class="hljs-params">(Map mp)</span> </span>&#123;    Iterator it = mp.entrySet().iterator();    <span class="hljs-keyword">while</span> (it.hasNext()) &#123;        Map.Entry pair = (Map.Entry)it.next();        System.out.println(pair.getKey() + <span class="hljs-string">" = "</span> + pair.getValue());        it.remove(); <span class="hljs-comment">// avoids a ConcurrentModificationException</span>    &#125;&#125;</code></pre></div><blockquote><ul><li>使用Java在一个区间内产生随机整数数</li></ul></blockquote><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">randInt</span><span class="hljs-params">(<span class="hljs-keyword">int</span> min, <span class="hljs-keyword">int</span> max)</span> </span>&#123;    Random rand;    <span class="hljs-keyword">int</span> randomNum = rand.nextInt((max - min) + <span class="hljs-number">1</span>) + min;    <span class="hljs-keyword">return</span> randomNum;&#125;</code></pre></div><blockquote><ul><li>如果子类实现Serializable接口而父类未实现时，父类不会被序列化，但此时父类必须有个无参构造方法，否则会抛InvalidClassException异常。</li></ul></blockquote><blockquote><ul><li>transient关键字修饰变量可以限制序列化。</li></ul></blockquote><blockquote><ul><li>当使用JakeWharton的TabPageIndicator时，如果需要先做一些耗时的操作，然后再展示TabPageIndicator的话，需要先设置mIndirector.setVisibility(View.GONE);然后耗时任务结束以后再mIndirector.setVisibility(View.VISIBLE);否则会报错</li></ul></blockquote><blockquote><ul><li>类继承之间的调用顺序 父类static成员 -&gt; 子类static成员 -&gt; 父类普通成员初始化和初始化块 -&gt; 父类构造方法 -&gt; 子类普通成员初始化和初始化块 -&gt; 子类构造方法</li></ul></blockquote><blockquote><ul><li>华为手机无法显示log解决方案,.拨号界面输入(*#*#2846579#*#*) Service menu will appear.Go to “ProjectMenu” -&gt; “Background Setting” -&gt; “Log Setting”Open “Log switch” and set it to ON.Open “Log level setting” and set the log level you wish.</li></ul></blockquote><blockquote><ul><li>后台service经常因为重启之类的出现onStartCommand()中的Intent传递的参数为null， 通过在onStartCommand()中的返回值改成return super.onStartCommand(intent, Service.START_REDELIVER_INTENT, startId); 可以解决问题。下面介绍几个flag的意思<br /></li></ul></blockquote><blockquote><ul><li><table><thead><tr><th>flag</th><th align="center">解释</th></tr></thead><tbody><tr><td>START_STICKY</td><td align="center">如果service进程被kill掉，保留service的状态为开始状态，但不保留递送的intent对象。随后系统会尝试重新创建service，由于服务状态为开始状态，所以创建服务后一定会调用onStartCommand(Intent,int,int)方法。如果在此期间没有任何启动命令被传递到service，那么参数Intent将为null。</td></tr><tr><td>START_NOT_STICKY</td><td align="center">“非粘性的”。使用这个返回值时，如果在执行完onStartCommand后，服务被异常kill掉，系统不会自动重启该服务。</td></tr><tr><td>START_REDELIVER_INTENT</td><td align="center">重传Intent。使用这个返回值时，如果在执行完onStartCommand后，服务被异常kill掉，系统会自动重启该服务，并将Intent的值传入。</td></tr><tr><td>START_STICKY_COMPATIBILITY</td><td align="center">START_STICKY的兼容版本，但不保证服务被kill后一定能重启。</td></tr></tbody></table></li></ul></blockquote><blockquote><ul><li>不能在Activity没有完全显示时显示PopupWindow和Dialog</li></ul></blockquote><blockquote><ul><li>在多进程之间不要用SharedPreferences共享数据，虽然可以（MODE_MULTI_PROCESS），但极不稳定</li></ul></blockquote><blockquote><ul><li>有些时候不能使用Application的Context，不然会报错（比如启动Activity，显示Dialog等）<br><img src="https://pic3.zhimg.com/e3f3236cbd96c69cdea10d014bacbeae_b.png" srcset="/img/loading.gif" alt=""></li></ul></blockquote><blockquote><p>*备注：大家注意看到有一些NO上添加了一些数字，其实这些从能力上来说是YES，但是为什么说是NO呢？下面一个一个解释：</p></blockquote><ol><li>数字1：启动Activity在这些类中是可以的，但是需要创建一个新的task，一般情况不推荐；</li><li>数字2：在这些类中去layout inflate是合法的，但是会使用系统默认的主题样式，如果你自定义了某些样式可能不会被使用；</li><li>数字3：在Receiver为null时允许，在4.2或以上的版本中，用于获取黏性广播的当前值。（可以无视）；</li><li>ContentProvider、BroadcastReceiver之所以在上述表格中，是因为在其内部方法中都有一个context用于使用。</li></ol><blockquote><ul><li>谨慎使用Android的透明主题，透明主题会导致很多问题，比如：如果新的Activity采用了透明主题，那么当前Activity的onStop方法不会被调用；在设置为透明主题的Activity界面按Home键时，可能会导致刷屏不干净的问题；进入主题为透明主题的界面会有明显的延时感</li><li>不要在非UI线程中初始化ViewStub，否则会返回null</li></ul></blockquote><blockquote><ul><li>尽量不要通过Application缓存数据，这不稳定</li></ul></blockquote><blockquote><ul><li>华为手机无法打开USB调试的问题，</li></ul></blockquote><ol><li>插好数据线,拨号界面 输入 <em>#</em>#2846579#<em>#</em> 进入工程模式</li><li>projectmenu→3后台设置→4USB端口配置→Balong调试模式,点确定</li><li>不要拔线,退出工程模式,直接重启手机,电脑中显示可移动磁盘(若仍未出现,重复步骤1、2)</li><li>这个是关闭USB调试的情况下电脑中使用手机的可移动磁盘的方法，使用后下拉菜单中usb选项也回来了。</li></ol><blockquote><ul><li>android listview中的消息被软键盘遮挡了,在设置listview的时候加上android:transcriptMode=”normal”就好了</li></ul></blockquote><blockquote><ul><li>TextUtils 是一个非常好用的工具类，把 List<String> 转成字符串，逗号分隔，逗号分隔的 String 字符串，切割成 List<String> ，分别可以用 TextUtils 的 join 和 split 方法。如果要对 List 去重，则可以用 Collection 的 frequency 方法。</li></ul></blockquote><blockquote><ul><li>在activity中调用 moveTaskToBack (boolean nonRoot)方法即可将activity 退到后台，注意不是finish()退出。</li></ul></blockquote><blockquote><ul><li>activity中的runOnUiThrea(Runnable action)方法可以直接回到主线程</li></ul></blockquote><blockquote><ul><li>listview有个footerDividersEnabled和headerDividersEnabled方法可以设置listview的顶部和底部divide，但是必须保证你设置了headview和footview才会有效果</li></ul></blockquote><blockquote><ul><li>Throwable类中的getStackTrace()方法，根据这个方法可以得到函数的逐层调用地址，其返回值为StackTraceElement[]；</li></ul></blockquote><blockquote><ul><li>StackTraceElement类，其中四个方法getClassName()，getFileName()，getLineNumber()，getMethodName()在调试程序打印Log时非常有用；</li></ul></blockquote><blockquote><ul><li>UncaughtExceptionHandler接口，再好的代码异常难免，利用此接口可以对未捕获的异常善后</li></ul></blockquote><blockquote><ul><li>Resources类中的getIdentifier(name, defType, defPackage)方法，根据资源名称获取其ID，做UI时经常用到；</li></ul></blockquote><blockquote><ul><li>view的isShown方法，只有当view本身以及它的所有祖先们都是visible时，isShown（）才返回TRUE。而平常我们调用if(view.getVisibility() == View.VISIBLE)只是对view本身而不对祖先的可见性进行判断。</li></ul></blockquote><blockquote><ul><li>Arrays类中的一系列关于数组操作的工具方法：binarySearch()，asList()，equals()，sort()，toString()，copyOfRange()等；Collections类中的一系列关于集合操作的工具方法：sort()，reverse()等；</li></ul></blockquote><blockquote><ul><li>TextView类中的append(CharSequence)方法，添加文本。一些特殊文本直接用+连接会变成String；</li></ul></blockquote><blockquote><ul><li>System类中的arraycopy(src, srcPos, dest, destPos, length)方法，用来copy数组；</li></ul></blockquote><blockquote><ul><li>Fragment类中的onHiddenChanged(boolean)方法，使用FragmentTransaction中的hide()，show()时貌似Fragment的其它生命周期方法都不会被调用，太坑爹！</li></ul></blockquote><blockquote><ul><li>Activity类中的onWindowFocusChanged(boolean)，onNewIntent(intent)等回调方法；</li></ul></blockquote><blockquote><ul><li>TextView类中的setTransformationMethod(TransformationMethod)方法，可用来实现“显示密码”功能</li></ul></blockquote><blockquote><ul><li>PageTransformer接口，用来自定义ViewPager页面切换动画，用setPageTransformer(boolean, PageTransformer)方法来进行设置；</li></ul></blockquote><blockquote><ul><li>apache提供的一系列jar包：commons-lang.jar，commons-collections.jar，commons-beanutils.jar等，里面很多方法可能是你曾经用几十几百行代码实现过的，但是执行效率或许要差很多，比如：ArrayUtils，StringUtils……；</li></ul></blockquote><blockquote><ul><li>ActivityLifecycleCallbacks接口，用于在Application类中监听各Activity的状态变化 ![阅读地址]{<a href="http://mp.weixin.qq.com/s?__biz=MzA3ODkzNzM3NQ==&amp;mid=401277907&amp;idx=1&amp;sn=0b2246f5178292596fc3a8295283359c#rd}" target="_blank" rel="noopener">http://mp.weixin.qq.com/s?__biz=MzA3ODkzNzM3NQ==&amp;mid=401277907&amp;idx=1&amp;sn=0b2246f5178292596fc3a8295283359c#rd}</a></li></ul></blockquote><blockquote><ul><li>ActionBar.hide()/.show() 顾名思义，隐藏和显示ActionBar，可以优雅地在全屏和带Actionbar之间转换。</li></ul></blockquote><blockquote><ul><li>SystemClock.sleep() 这个方法在保证一定时间的 sleep 时很方便，通常我用来进行 debug 和模拟网络延时。</li></ul></blockquote><blockquote><ul><li>UrlQuerySanitizer——使用这个工具可以方便对 URL 进行检查。</li></ul></blockquote><blockquote><ul><li>ActivityOptions ——方便的定义两个Activity切换的动画。 使用ActivityOptionsCompat 可以很好解决旧版本的兼容问题。</li></ul></blockquote><blockquote><ul><li>getParent().requestDisallowInterceptTouchEvent(true);剥夺父view对touch事件的处理权，谁用谁知道。</li></ul></blockquote><blockquote><ul><li>HandlerThread，代替不停new Thread开子线程的重复体力写法。</li></ul></blockquote><blockquote><ul><li>IntentService,一个可以干完活后自己去死且不需要我们去管理子线程的Service</li></ul></blockquote><blockquote><ul><li>Executors. newSingleThreadExecutor();这个是java的，之前不知道它，自己花很大功夫去研究了单线程顺序执行的任务队列 </li></ul></blockquote><blockquote><ul><li>android:animateLayoutChanges=”true”，LinearLayout中添加View的动画的办法，支持通过setLayoutTransition()自定义动画。</li></ul></blockquote><blockquote><ul><li>AsyncQueryHandler，如果做系统工具类的开发，比如联系人短信辅助工具等，肯定免不了和ContentProvider打交道，如果数据量不是很大的情况下，随便搞，如果数据量大的情况下，了解下这个类是很有必要的，需要注意的是，这玩意儿吃异常..</li></ul></blockquote><blockquote><ul><li>ViewFlipper，实现多个view的切换(循环)，可自定义动画效果，且可针对单个切换指定动画。</li></ul></blockquote><blockquote><ul><li>android util包中的Pair类，可以方便的用来存储一”组”数据。注意不是key value</li></ul></blockquote><blockquote><ul><li>android:descendantFocusability，ListView的item中CheckBox等元素抢焦点导致item点击事件无法响应时，除了给对应的元素设置 focusable,更简单的是在item根布局加上android:descendantFocusability=”blocksDescendants” </li></ul></blockquote><blockquote><ul><li>includeFontPadding=”false”，TextView默认上下是有一定的padding的，有时候我们可能不需要上下这部分留白，加上它即可。</li></ul></blockquote><blockquote><ul><li>Messenger，面试的时候通常都会被问到进程间通信，一般情况下大家都是开始背书，AIDL巴拉巴拉。。有一天在鸿神的博客看到这个，嗯，如他所说，又可以装一下了。 </li></ul></blockquote><blockquote><ul><li>EditTxt.setImeOptions， 使用EditText弹出软键盘时，修改回车键的显示内容(一直很讨厌用回车键来交互，所以之前一直不知道这玩意儿) </li></ul></blockquote><blockquote><ul><li>java8中新增的LocalDate和LocalTime接口，Date虽然是个万能接口，但是它真的不好用，有了这俩，终于可以愉快的处理日期时间了。</li></ul></blockquote><blockquote><ul><li>WeakHashMap，直接使用HashMap有时候会带来内存溢出的风险，使用WaekHashMap实例化Map。当使用者不再有对象引用的时候，WeakHashMap将自动被移除对应Key值的对象。</li></ul></blockquote><blockquote><ul><li>使用SnackBar的时候，不要使用view.getRootView()作为snackbar的view,华为荣耀7 会出问题。</li></ul></blockquote><blockquote><ul><li>设置TextView单行显示的时候不要用Lines=1,而要用singleLine=”true” ,因为魅族部分手机在设置Lines=1的时候，然后TextView的值全为数字的时候， 你就会懵逼了.</li></ul></blockquote><blockquote><ul><li>TouchDelegate可用于更改View的触摸区域。场景：比如在RecyclerView的ItemView里包含了CheckBox组件, 然后想实现点击ItemView的时候，也可以触发CheckBox，就可以使用此类</li></ul></blockquote><blockquote><ul><li>ArgbEvaluator可用于计算不同颜色值之间的插值，配合ValueAnimator.ofObject或者ViewPager.PageTransformer使用，可以实现不同颜色之间的平滑过渡。</li></ul></blockquote><blockquote><ul><li>Palette可用于提取一张图片的颜色。</li></ul></blockquote><blockquote><ul><li>ViewDragHelper,做过自定义ViewGroup的童鞋都应该知道这个东西吧，用来处理触摸事件的神器，妈妈再也不用担心我自定义控件了。</li></ul></blockquote><blockquote><ul><li>PageTransformer用于定义ViewPager页面切换时的动画效果（淡入淡出，放大缩小神马的…）官方有例子，直接看吧。</li></ul></blockquote><blockquote><ul><li>Formatter.formatFileSize() 这个方法会格式化数据的大小，根据输入的字节大小，返回 B KB MB GB 等等（最大支持到 PB）。当然要注意的是输入的最大值是 Long.MAX_VALUE.</li></ul></blockquote><blockquote><ul><li>Activity.recreate重新创建Activity。有什么用呢？可以在程序更换主题后，立马刷新当前Activity，而不会有明显的重启Activity的动画。</li></ul></blockquote><blockquote><ul><li>View.getContext顾名思义，就不用解释了吧…以前在写RecyclerView的Adapter的时候，为了使用LayoutInflater，经常傻乎乎地在构造函数中传入一个外部的context….是不是只有我不知道而已（笑cry脸）</li></ul></blockquote><blockquote><ul><li>View.post方便在非UI线程对界面进行修改，与Handler的作用类似。并且由于post的Runnable会保证在该View绘制完成的前提下才调用，所以一般也可以用于获取View的宽高。</li></ul></blockquote><blockquote><ul><li>Activity.runOnUiThread与View.post类似，方便在非UI线程中对界面进行修改。</li></ul></blockquote><blockquote><ul><li>Fragment在配合PagerAdapter使用的时候可以重写setUserVisibleHintFragment()方法，然后根据参数的布尔值（true的话表示当前Fragment对用户可见),来执行一些逻辑。</li></ul></blockquote><blockquote><ul><li>android:animateLayoutChanges 这是一个非常酷炫的属性。在父布局加上 android:animateLayoutChanges=”true” 后，如果触发了layout方法（比如它的子View设置为GONE），系统就会自动帮你加上布局改变时的动画特效！！</li></ul></blockquote><blockquote><ul><li>android:clipToPadding 设置父view是否允许其子view在它的padding（这里指的是父View的padding）中绘制。是不是有点绕？举个实际场景吧：假如有个ListView，我们想要在初始位置时，第一项Item离顶部有10dp的距离，就可以在ListView的布局中加入android:clipToPadding=”false” android:paddingTop=”10dp”即可。是不是很方便呢？</li></ul></blockquote><blockquote><ul><li>rv 的 Layoutmanager 可以直接申明在 xml 中,具体代码可查看RecyclerView.createLayoutManager 方法.<br><img src="https://raw.githubusercontent.com/jiang111/awesome-android-tips/master/img/recycler_1.jpeg" srcset="/img/loading.gif" alt=""><br><img src="https://raw.githubusercontent.com/jiang111/awesome-android-tips/master/img/recycler_2.jpeg" srcset="/img/loading.gif" alt=""></li></ul></blockquote><blockquote><ul><li>RecyclerView在23.2.+的版本中新增了自动测量的功能，由于新增了自动测量，那么它的item的根布局在需要测量的方向上就不能写match_parent了，需要改成wrap_content</li></ul></blockquote><blockquote><ul><li>getParent().requestDisallowInterceptTouchEvent(true);剥夺父view对touch事件的处理权，谁用谁知道。</li></ul></blockquote><blockquote><ul><li>Canvas中clipRect、clipPath和clipRegion剪切区域的API。</li></ul></blockquote><blockquote><ul><li>GradientDrawable 有个阴影效果还不错，以为是切的图片，一看代码，什么鬼= =！</li></ul></blockquote><blockquote><ul><li>有朋友提到了在自定义View时有些方法在开启硬件加速的时候没有效果的问题，在API16之后确实有很多方法不支持硬件加速，通常我们关闭硬件加速都是在清单文件中通过&lt;application android:hardwareAccelerated=”false” …&gt;，其实android也提供了针对特定View关闭硬件加速的方法,调用View.setLayerType(View.LAYER_TYPE_SOFTWARE, null);即可。</li></ul></blockquote><blockquote><ul><li>PointF，graphics包中的一个类，我们经常见到在处理Touch事件的时候分别定义一个downX，一个downY用来存储一个坐标，如果坐标少还好，如果要记录的坐标过多那代码就不好看了。用PointF(float x, float y);来描述一个坐标点会清楚很多。</li></ul></blockquote><blockquote><ul><li>StateListDrawable，定义Selector通常的办法都是xml文件，但是有的时候我们的图片资源可能是从服务器动态获取的，比如很多app所谓的皮肤，这种时候就只能通StateListDrawable来完成了，各种addState即可。</li></ul></blockquote><blockquote><ul><li>android:duplicateParentState=”true”，让子View跟随其Parent的状态，如pressed等。常见的使用场景是某些时候一个按钮很小，我们想要扩大其点击区域的时候通常会再给其包裹一层布局，将点击事件写到Parent上，这时候如果希望被包裹按钮的点击效果对应的Selector继续生效的话，这时候duplicateParentState就派上用场了。</li></ul></blockquote><blockquote><ul><li>ViewConfiguration.getScaledTouchSlop();触发移动事件的最小距离，自定义View处理touch事件的时候，有的时候需要判断用户是否真的存在movie，系统提供了这样的方法。</li></ul></blockquote><blockquote><ul><li>ViewStub，有的时候一块区域需要根据情况显示不同的布局，通常我们都会通过setVisibility的方法来显示和隐藏不同的布局，但是这样默认是全部加载的，用ViewStub可以更好的提升性能。</li></ul></blockquote><blockquote><ul><li>onTrimMemory，在Activity中重写此方法，会在内存紧张的时候回调（支持多个级别），便于我们主动的进行资源释放，避免OOM。</li></ul></blockquote><blockquote><ul><li>TextView.setCompoundDrawablePadding，代码设置TextView的drawable padding。</li></ul></blockquote><blockquote><ul><li>ImageSwitcher，可以用来做图片切换的一个类，类似于幻灯片。</li></ul></blockquote><blockquote><ul><li>在自定义控件的时候,能用drawable来绘制圆，或者其他样式的时候,尽量用drawable,因为drawable的效果要远胜于canvas.drawXXX().</li></ul></blockquote><blockquote><ul><li>如果想要自定义View支持SwipeRefreshLayout，只需要声明并实现ScrollingView接口即可，RecyclerView和NestedScrollView已经实现此接口。</li></ul></blockquote><blockquote><ul><li>AtomicFile——通过使用备份文件进行文件的原子化操作。这个知识点之前我也写过，不过最好还是有出一个官方的版本比较好。</li></ul></blockquote><blockquote><ul><li>DatabaseUtils——一个包含各种数据库操作的使用工具。</li></ul></blockquote><blockquote><ul><li>Activity.isChangingConfigurations ()——如果在 Activity 中 configuration 会经常改变的话，使用这个方法就可以不用手动做保存状态的工作了。</li></ul></blockquote><blockquote><ul><li>SearchRecentSuggestionsProvider——可以创建最近提示效果的 provider，是一个简单快速的方法。</li></ul></blockquote><blockquote><ul><li>android:clipChildren (ViewGroup)——如果此属性设置为不可用，那么 ViewGroup 的子 View 在绘制的时候会超出它的范围，在做动画的时候需要用到。</li></ul></blockquote><blockquote><ul><li>android:fillViewport (ScrollView)——在这片文章中有详细介绍文章链接，可以解决在 ScrollView 中当内容不足的时候填不满屏幕的问题。</li></ul></blockquote><blockquote><ul><li>android:tileMode (BitmapDrawable)——可以指定图片使用重复填充的模式。</li></ul></blockquote><blockquote><ul><li>android:enterFadeDuration/android:exitFadeDuration (Drawables)——此属性在 Drawable 具有多种状态的时候，可以定义它展示前的淡入淡出效果。</li></ul></blockquote><blockquote><ul><li>Log.wtf()的意思是What a Terrible Failure,而不是What The Fuck!</li></ul></blockquote><blockquote><ul><li>使用RenderScript虚化图片效果。如果你的app的minSDK为16或者更低，你需要使用support模式，因为很多方法都是在API 17之后添加的。renderscriptTargetApi最高到23，但是你应该把它设置到能保持脚本中使用到的功能完整的最低API。如果你想在support模式下target API 21+你必须使用gradle-plugin 2.1.0 和 buildToolsVersion “23.0.3” 或者以上。需要在gradle中添加renderscriptTargetApi 18,renderscriptSupportModeEnabled true 这两句话</li></ul></blockquote><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Bitmap <span class="hljs-title">blurBitmap</span><span class="hljs-params">(Context context, Bitmap src, <span class="hljs-keyword">int</span> radius)</span> </span>&#123;        Bitmap dest = src.copy(src.getConfig(), <span class="hljs-keyword">true</span>);        RenderScript rs = RenderScript.create(context);        Allocation allocation = Allocation.createFromBitmap(rs, src);        Type t = allocation.getType();        Allocation blurredAllocation = Allocation.createTyped(rs, t);        ScriptIntrinsicBlur blurScript = ScriptIntrinsicBlur.create(rs, Element.U8_4(rs));        blurScript.setRadius(radius);        blurScript.setInput(allocation);        blurScript.forEach(blurredAllocation);        blurredAllocation.copyTo(dest);        allocation.destroy();        blurredAllocation.destroy();        blurScript.destroy();        t.destroy();        rs.destroy();        <span class="hljs-keyword">return</span> dest;    &#125;</code></pre></div><blockquote><ul><li>如果想把一个view保存为Bitmap，正常情况下用第一种方法就可以了，但是如果是ScrollView，则必须采用第二种方法。 <br /><br><img src="https://raw.githubusercontent.com/jiang111/awesome-android-tips/master/img/capture_view_1.jpg" srcset="/img/loading.gif" alt=""><br><img src="https://raw.githubusercontent.com/jiang111/awesome-android-tips/master/img/capture_view_2.jpg" srcset="/img/loading.gif" alt=""></li></ul></blockquote><blockquote><ul><li>当Activity LauncherMode 为singleTask singleInstance时,使用startActivityForResult会立马返回，不能正常调用。具体请看<a href="http://www.360doc.com/content/15/0123/14/12928831_443085580.shtml" target="_blank" rel="noopener">http://www.360doc.com/content/15/0123/14/12928831_443085580.shtml</a></li></ul></blockquote><blockquote><ul><li>当PopupWindow中有EditText控件时,因为Popupwindow 默认没有获取到焦点，需要手动设置焦点，这样子view才能获取到事件的监听。所以你需要在创建完popwindow后设置他的焦点，popupWindow.setFocusable(true);就可以让EditText获取焦点。</li></ul></blockquote><blockquote><ul><li>PopupWindow默认点击外部的时候不消失，需要对PopupWindow 设置一个背景图popWindow.setBackgroundDrawable(new BitmapDrawable());要创建一个空对象，设置为null是不行的，或者就创建一个全透明的背景图。</li></ul></blockquote><blockquote><ul><li>android中的序列化官方推荐Parceble,其实Parceble最好用于内存之间数据的交换,如果要把数据写入硬盘的话,推荐实现Serializable</li></ul></blockquote><blockquote><ul><li>tools标签可以很好的帮助开发者实时预览xml的效果,并且运行以后tools标签的内容不会展示出来.例如:</li></ul></blockquote><div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">TextView</span></span><span class="hljs-tag">    <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">"match_parent"</span></span><span class="hljs-tag">    <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">"wrap_content"</span></span><span class="hljs-tag">    <span class="hljs-attr">tools:text</span>=<span class="hljs-string">"这段话只在预览时能看到,运行以后就看不到了"</span> /&gt;</span></code></pre></div><blockquote><ul><li>android studio 2.1起已经支持jdk8了,使用的时候要在gradle中加上,需要把buildToolsVersion更新到24以上的版本</li></ul></blockquote><div class="hljs"><pre><code class="hljs properties"><span class="hljs-attr">android</span> <span class="hljs-string">&#123;</span>    <span class="hljs-attr">defaultConfig</span> <span class="hljs-string">&#123;</span>    <span class="hljs-attr">...</span>            <span class="hljs-attr">jackOptions</span> <span class="hljs-string">&#123;</span>                <span class="hljs-attr">enabled</span> <span class="hljs-string">true</span>            <span class="hljs-attr">&#125;</span>        <span class="hljs-attr">&#125;</span>   <span class="hljs-attr">...</span>    <span class="hljs-attr">compileOptions</span> <span class="hljs-string">&#123;</span>        <span class="hljs-attr">targetCompatibility</span> <span class="hljs-string">1.8</span>        <span class="hljs-attr">sourceCompatibility</span> <span class="hljs-string">1.8</span>    <span class="hljs-attr">&#125;</span><span class="hljs-attr">&#125;</span></code></pre></div><blockquote><ul><li>6.0之后getResources().getColor()方法被废弃了，大家可以用ContextCompat.getColor(context, R.color.color_name)替换，ContextCompat 是 v4 包里的，请放心使用，另外还有getDrawable()等方法</li></ul></blockquote><blockquote><ul><li>图片的资源文件官方推荐只把launcher放在mipmap文件夹下面，而app用到的资源文件建议放在drawable下面。</li></ul></blockquote><blockquote><ul><li>SharedPreference.Editor的apply是异步操作，不会返回成功的状态，而commit是同步操作，因此，在多个并发的提交commit的时候，他们会等待正在处理的commit保存到磁盘后再操作下一个数据，从而降低了效率。</li></ul></blockquote><blockquote><ul><li>如果你在 manifest 中把一个 activity 设置成 android:windowSoftInputMode=”adjustResize”，那么 ScrollView（或者其它可伸缩的 ViewGroups）会缩小，从而为软键盘腾出空间。但是，如果你在 activity 的主题中设置了 android:windowFullscreen=”true”，那么 ScrollView 不会缩小。这是因为该属性强制 ScrollView 全屏显示。然而在主题中设置 android:fitsSystemWindows=”false” 也会导致 adjustResize 不起作用</li></ul></blockquote><blockquote><ul><li>在Android 4.0以后，在Manifest.xml中静态注册的广播，程序安装后必须启动一次才能接收到广播，比如你的应用监听开机启动的广播，必须要你的程序被运行过才能监听到</li></ul></blockquote><blockquote><ul><li>Activity的onDestory方法调用时机是不确定的（有时候离开界面很久之后才会调用onDestory方法），应该避免指望通过onDestory方法去释放与Activity相关的资源，否则会导致一些随机bug</li></ul></blockquote><blockquote><ul><li>2.X时代Bitmap对象虽然存储在堆内存中，但是用了一个byte数组存储其像素信息。通过计数器来记录该像素信息被引用的个数。有人认为这个byte数组在native堆中，但事实上它也在堆中。只有在使用者调用recycle()后，Bitmap对象才会释放像素信息，才会在失去引用后被垃圾回收机制销毁。再加上DVM的heap size有严格的阀值，所以在使用大量图片资源的时候，及其容易发生OOM。解决办法一般都是，用一个哈希表存储Bitmap对象的软引用，作为内存缓存，并在适当时机掉用其recycle()。3.0以上版本Bitmap对象可以通过垃圾回收机制完全销毁，理论上不用再调用recycle()。</li></ul></blockquote><blockquote><ul><li>.gitignore只能忽略那些原来没有被track的文件，如果某些文件已经被纳入了版本管理中，则修改.gitignore是无效的。那么解决方法就是先把本地缓存删除（改变成未track状态），然后再提交：</li></ul></blockquote><div class="hljs"><pre><code class="hljs pgsql">git rm -r <span class="hljs-comment">--cached .</span>git <span class="hljs-keyword">add</span> .git <span class="hljs-keyword">commit</span> -m <span class="hljs-string">'update .gitignore'</span></code></pre></div><blockquote><ul><li>时间戳请使用long或者String类型接收，遇到的坑,由于项目中的model好多都是通过GsonFormat生成的，服务器给的json中的时间戳都是10位的，导致了GsonFormat自动解析成了int, 当测试人员选择时间为2100年的时候时间戳是4开头的十位 用int类型接收越界了,导致报错</li></ul></blockquote><blockquote><ul><li>为你的app添加默认布局样式,比如:每一个控件都需要写width和height属性,然而很多的控件的宽高属性都是wrap_content,那么我们可以通过在style文件添加如下样式:</li></ul></blockquote><div class="hljs"><pre><code class="hljs applescript">&lt;style <span class="hljs-built_in">name</span>=<span class="hljs-string">"Theme.YourApp"</span> parent=<span class="hljs-string">"android:style/Theme.Light"</span>&gt;    &lt;<span class="hljs-built_in">item</span> <span class="hljs-built_in">name</span>=<span class="hljs-string">"android:layout_width"</span>&gt;wrap_content&lt;/<span class="hljs-built_in">item</span>&gt;    &lt;<span class="hljs-built_in">item</span> <span class="hljs-built_in">name</span>=<span class="hljs-string">"android:layout_height"</span>&gt;wrap_content&lt;/<span class="hljs-built_in">item</span>&gt;&lt;/style&gt;</code></pre></div><p>这样,控件的宽高默认都是wrap_content样式啦。</p><blockquote><ul><li>在style中写的样式通过视同parent标签来扩展你的样式,这样更高效。</li></ul></blockquote><div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"Fill"</span>&gt;</span><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"android:layout_width"</span>&gt;</span>fill_parent<span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span></span><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"android:layout_height"</span>&gt;</span>fill_parent<span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"Fill.Height"</span> <span class="hljs-attr">parent</span>=<span class="hljs-string">"@style/Fill"</span>&gt;</span><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"android:orientation"</span>&gt;</span>vertical<span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span></code></pre></div><blockquote><ul><li>Android上的应用切换按钮列出的其实不是应用而是Task，所以你会看到有的应用在切换视图里有多个任务。如果你的应用中有逻辑上相互独立的部分，或者想在多窗口环境下并排显示应用的两个不同部分，这种情况就适合多任务了。使用manifest属性(静态)或者 intent flags(动态)可以实现这一点,详见视频: <a href="http://v.youku.com/v_show/id_XMTU2ODk4NDg2NA==.html?f=26587294" target="_blank" rel="noopener">http://v.youku.com/v_show/id_XMTU2ODk4NDg2NA==.html?f=26587294</a></li></ul></blockquote><p><img src="https://raw.githubusercontent.com/jiang111/awesome-android-tips/master/img/multy_task1.jpg" srcset="/img/loading.gif" width = "50%" height="300px" /><img src="https://raw.githubusercontent.com/jiang111/awesome-android-tips/master/img/multy_task2.jpg" srcset="/img/loading.gif" width = "50%"  height="300px"/></p><blockquote><ul><li>当app的theme用的是NoActionBar,但是在layout中仍然用到toolbar的时候,不要在style文件中加fitsSystemWindows属性,而是在用到toolbar的layout最外层加fitsSystemWindows,否则当你使用EditText,在小米手机上长按EditText调出系统粘贴功能的时候,粘贴的layout的布局会错位.</li></ul></blockquote><blockquote><ul><li>当WebView与ScrollView嵌套使用,并且WebView有字体放大缩小的功能时,当切换webview的字体后,webview的高度并不能很好的计算出来,这时候可以通过注入的方式,让js算出高度,经测试,这样是最可靠的,代码地址:<a href="http://blog.csdn.net/jys1115/article/details/43525979" target="_blank" rel="noopener">http://blog.csdn.net/jys1115/article/details/43525979</a></li></ul></blockquote><p>####摘自如下地址(部分)：</p><blockquote><ul><li><a href="http://oakzmm.com/2015/08/04/cool-Android-api/" target="_blank" rel="noopener">http://oakzmm.com/2015/08/04/cool-Android-api/</a></li><li><a href="http://oakzmm.com/2015/08/11/cool-Android-api-2/" target="_blank" rel="noopener">http://oakzmm.com/2015/08/11/cool-Android-api-2/</a></li><li><a href="http://weibo.com/liangfeizc?from=feed&amp;loc=nickname" target="_blank" rel="noopener">http://weibo.com/liangfeizc?from=feed&amp;loc=nickname</a></li><li><a href="http://zhuanlan.zhihu.com/zmywly8866/20309921" target="_blank" rel="noopener">http://zhuanlan.zhihu.com/zmywly8866/20309921</a></li><li><a href="http://www.zhihu.com/question/33636939" target="_blank" rel="noopener">http://www.zhihu.com/question/33636939</a></li><li><a href="http://gold.xitu.io/entry/56c2b9b779bc4400540894ac" target="_blank" rel="noopener">http://gold.xitu.io/entry/56c2b9b779bc4400540894ac</a></li><li><a href="https://www.zhihu.com/question/33636939/answer/57239990?group_id=612750833369153536" target="_blank" rel="noopener">https://www.zhihu.com/question/33636939/answer/57239990?group_id=612750833369153536</a></li><li><a href="http://mp.weixin.qq.com/s?__biz=MzA4MTM2MjE2MA==&amp;mid=2650836293&amp;idx=3&amp;sn=2624066ababb6b613634015f54ea19b6&amp;scene=0#wechat_redirect" target="_blank" rel="noopener">http://mp.weixin.qq.com/s?__biz=MzA4MTM2MjE2MA==&amp;mid=2650836293&amp;idx=3&amp;sn=2624066ababb6b613634015f54ea19b6&amp;scene=0#wechat_redirect</a></li><li><a href="http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2016/0504/4205.html" target="_blank" rel="noopener">http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2016/0504/4205.html</a></li><li><a href="https://zhuanlan.zhihu.com/p/20309921" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/20309921</a></li><li><a href="http://www.pfeng.org/archives/840#123-tsina-1-92600-1bb80a0982f5c2ea1fcaf67d7fdce2f1" target="_blank" rel="noopener">http://www.pfeng.org/archives/840#123-tsina-1-92600-1bb80a0982f5c2ea1fcaf67d7fdce2f1</a></li></ul></blockquote><h3 id="License"><a href="#License" class="headerlink" title="License"></a>License</h3><div class="hljs"><pre><code>Copyright 2016 NewTabLicensed under the Apache License, Version 2.0 (the &quot;License&quot;);you may not use this file except in compliance with the License.You may obtain a copy of the License at    http://www.apache.org/licenses/LICENSE-2.0Unless required by applicable law or agreed to in writing, softwaredistributed under the License is distributed on an &quot;AS IS&quot; BASIS,WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.See the License for the specific language governing permissions andlimitations under the License.</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RxJava</title>
    <link href="/2016/08/01/RxJava/"/>
    <url>/2016/08/01/RxJava/</url>
    
    <content type="html"><![CDATA[<p>一些临时乱记<a id="more"></a></p><h2 id="操作符分类"><a href="#操作符分类" class="headerlink" title="操作符分类"></a>操作符分类</h2><h3 id="创建操作"><a href="#创建操作" class="headerlink" title="创建操作"></a>创建操作</h3><p> Create, Defer, Empty/Never/Throw, From, Interval, Just, Range, Repeat, Start, Timer</p><h3 id="变换操作"><a href="#变换操作" class="headerlink" title="变换操作"></a>变换操作</h3><p> Buffer, FlatMap, GroupBy, Map, Scan和Window</p><h3 id="过滤操作"><a href="#过滤操作" class="headerlink" title="过滤操作"></a>过滤操作</h3><p> Debounce, Distinct, ElementAt, Filter, First, IgnoreElements, Last, Sample, Skip, SkipLast, Take, TakeLast</p><h3 id="组合操作"><a href="#组合操作" class="headerlink" title="组合操作"></a>组合操作</h3><p> And/Then/When, CombineLatest, Join, Merge, StartWith, Switch, Zip</p><h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><p> Catch和Retry</p><h3 id="辅助操作"><a href="#辅助操作" class="headerlink" title="辅助操作"></a>辅助操作</h3><p> Delay, Do, Materialize/Dematerialize, ObserveOn, Serialize, Subscribe, SubscribeOn, TimeInterval, Timeout,<br> Timestamp, Using</p><h3 id="条件和布尔操作"><a href="#条件和布尔操作" class="headerlink" title="条件和布尔操作"></a>条件和布尔操作</h3><p> All, Amb, Contains, DefaultIfEmpty, SequenceEqual, SkipUntil, SkipWhile, TakeUntil, TakeWhile</p><h3 id="算术和集合操作"><a href="#算术和集合操作" class="headerlink" title="算术和集合操作"></a>算术和集合操作</h3><p> Average, Concat, Count, Max, Min, Reduce, Sum</p><h3 id="转换操作"><a href="#转换操作" class="headerlink" title="转换操作"></a>转换操作</h3><p> To</p><h3 id="连接操作"><a href="#连接操作" class="headerlink" title="连接操作"></a>连接操作</h3><p> Connect, Publish, RefCount, Replay</p><h3 id="反压操作，用于增加特殊的流程控制策略的操作符"><a href="#反压操作，用于增加特殊的流程控制策略的操作符" class="headerlink" title="反压操作，用于增加特殊的流程控制策略的操作符"></a>反压操作，用于增加特殊的流程控制策略的操作符</h3><h2 id="Scheduler"><a href="#Scheduler" class="headerlink" title="Scheduler"></a>Scheduler</h2><div class="hljs"><pre><code>如果你想给Observable操作符链添加多线程功能，你可以指定操作符（或者特定的Observable）在特定的调度器(Scheduler)上执行</code></pre></div><h3 id="调度器的种类"><a href="#调度器的种类" class="headerlink" title="调度器的种类"></a>调度器的种类</h3><ul><li><p>Schedulers.computation( )</p><p>  用于计算任务，如事件循环或和回调处理，不要用于IO操作(IO操作请使用Schedulers.io())；默认线程数等于处理器的数量</p></li><li><p>Schedulers.from(executor)</p><p>  使用指定的Executor作为调度器</p></li><li><p>Schedulers.immediate( )</p><p>  在当前线程立即开始执行任务</p></li><li><p>Schedulers.io( )</p><p>  用于IO密集型任务，如异步阻塞IO操作，这个调度器的线程池会根据需要增长；对于普通的计算任务，请使用Schedulers.computation()；Schedulers.io( )默认是一个CachedThreadScheduler，很像一个有线程缓存的新线程调度器</p></li><li><p>Schedulers.newThread( )</p><p>  为每个任务创建一个新线程</p></li><li><p>Schedulers.trampoline( )</p><p>  当其它排队的任务完成后，在当前线程排队开始执行</p></li></ul><h3 id="默认调度器"><a href="#默认调度器" class="headerlink" title="默认调度器"></a>默认调度器</h3><ul><li><p>buffer(timespan)    </p><p>  computation</p></li><li><p>buffer(timespan, count)    </p><p>  computation</p></li><li><p>buffer(timespan, timeshift)    </p><p>  computation</p></li><li><p>debounce(timeout, unit)    </p><p>  computation</p></li><li><p>delay(delay, unit)    </p><p>  computation</p></li><li><p>delaySubscription(delay, unit)    </p><p>  computation</p></li><li><p>interval    </p><p>  computation</p></li><li><p>repeat    </p><p>  trampoline</p></li><li><p>replay(time, unit)    </p><p>  computation</p></li><li><p>replay(buffersize, time, unit)    </p><p>  computation</p></li><li><p>replay(selector, time, unit)    </p><p>  computation</p></li><li><p>replay(selector, buffersize, time, unit)    </p><p>  computation</p></li><li><p>retry    </p><p>  trampoline</p></li><li><p>sample(period, unit)    </p><p>  computation</p></li><li><p>skip(time, unit)    </p><p>  computation</p></li><li><p>skipLast(time, unit)    </p><p>  computation</p></li><li><p>take(time, unit)    </p><p>  computation</p></li><li><p>takeLast(time, unit)    </p><p>  computation</p></li><li><p>takeLast(count, time, unit)    </p><p>  computation</p></li><li><p>takeLastBuffer(time, unit)    </p><p>  computation</p></li><li><p>takeLastBuffer(count, time, unit)    </p><p>  computation</p></li><li><p>throttleFirst    </p><p>  computation</p></li><li><p>throttleLast    </p><p>  computation</p></li><li><p>throttleWithTimeout    </p><p>  computation</p></li><li><p>timeInterval    </p><p>  immediate</p></li><li><p>timeout(timeoutSelector)    </p><p>  immediate</p></li><li><p>timeout(firstTimeoutSelector, timeoutSelector)    </p><p>  immediate</p></li><li><p>timeout(timeoutSelector, other)    </p><p>  immediate</p></li><li><p>timeout(timeout, timeUnit)    </p><p>  computation</p></li><li><p>timeout(firstTimeoutSelector, timeoutSelector, other)    </p><p>  immediate</p></li><li><p>timeout(timeout, timeUnit, other)    </p><p>  computation</p></li><li><p>timer    </p><p>  computation</p></li><li><p>timestamp    </p><p>  immediate</p></li><li><p>window(timespan)    </p><p>  computation</p></li><li><p>window(timespan, count)    </p><p>  computation</p></li><li><p>window(timespan, timeshift)    </p><p>  computation</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Android</tag>
      
      <tag>RxJava</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>朱子家训</title>
    <link href="/2016/08/01/%E6%9C%B1%E5%AD%90%E5%AE%B6%E8%AE%AD/"/>
    <url>/2016/08/01/%E6%9C%B1%E5%AD%90%E5%AE%B6%E8%AE%AD/</url>
    
    <content type="html"><![CDATA[<p>黎明即起，灑掃庭除，要內外整潔；既昏便息，關鎖門戶，必親自檢點。一粥一飯，當思來處不易；半絲半縷，恒念物力維艱。<a id="more"></a>宜未雨而綢繆，毋臨渴而掘井。自奉必須儉約，宴客切勿留連。器具質而潔，瓦缶勝金玉；飲食約而精，園蔬愈珍饈。勿營華屋，勿謀良田。三姑六婆，實淫盜之媒；婢美妾嬌，非閨房之福。童僕勿用俊美，妻妾切忌豔妝。祖宗雖遠，祭祀不可不誠；子孫雖愚，經書不可不讀。居身務期儉約；教子要有義方。莫貪意外之財，莫飲過量之酒。與肩挑貿易，毋佔便宜；見窮苦親鄰，須加溫恤。刻薄成家，理無久享；倫常乖舛，立見消亡。兄弟叔姪，須分多潤寡；長幼內外，宜法肅辭嚴。聽婦言，乖骨肉，豈是丈夫？重貲財，薄父母，不成人子。嫁女擇佳婿，毋索重聘；娶媳求淑女，勿計厚奩。見富貴而生諂容者，最可恥；遇貧窮而作驕態者，賤莫甚。居家戒爭訟，訟則終凶；處世戒多言，言多必失。勿恃勢力而凌逼孤寡；毋貪口腹而恣殺牲禽。乖僻自是，悔誤必多，頹惰自甘，家道難成。狎暱惡少，久必受其累；屈志老成，急則可相依。輕聽發言，安知非人之譖愬？當忍耐三思；因事相爭，焉知非我之不是？須平心再想。施惠無念，受恩莫忘。凡事當留餘地，得意不宜再往。人有喜慶，不可生妒忌心；人有禍患，不可生喜幸心。善欲人見，不是真善；惡恐人知，便是大惡。見色而起淫心，報在妻女；匿怨而用暗箭，禍延子孫。家門和順，雖饔餐不繼，亦有餘歡；國課早完，即囊橐無餘，自得至樂，讀書志在聖賢，非徒科第；為官心存君國，豈計身家？守分安命，順時聽天。為人若此，庶乎近焉。</p><p>黎明即起，洒扫庭除，要内外整洁；既昏便息，关锁门户，必亲自检点。一粥一饭，当思来处不易；半丝半缕，恒念物力维艰。宜未雨而绸缪，毋临渴而掘井。自奉必须俭约，宴客切勿留连。器具质而洁，瓦缶胜金玉；饮食约而精，园蔬愈珍馐。勿营华屋，勿谋良田。三姑六婆，实淫盗之媒；婢美妾娇，非闺房之福。童仆勿用俊美，妻妾切忌艳妆。祖宗虽远，祭祀不可不诚；子孙虽愚，经书不可不读。居身务期简朴；教子要有义方。勿贪意外之财，勿饮过量之酒。与肩挑贸易，勿占便宜；见穷苦亲邻，须加温恤。刻薄成家，理无久享；伦常乖舛，立见消亡。兄弟叔侄，需分多润寡，长幼内外，宜法肃辞严。听妇言，乖骨肉，岂是丈夫，重赀才，薄父母，不成人子。嫁女择佳婿，无索重聘；娶媳求淑女，勿计厚奁。见富贵而生谄容者，最可耻；遇贫穷而作骄态者，贱莫甚。居家戒争讼，讼则终凶；处世戒多言，言多必失。勿恃势力而凌逼孤寡；勿贪口腹而恣杀生禽。乖僻自是，悔误必多；颓隳自甘，家道难成。狎暱恶少，久必受其累；屈志老成，急则可相依。轻听发言，安知非人之谮愬？当忍耐三思；因事相争，焉知非我之不是？须平心暗想。施惠无念，受恩莫忘。凡事当留余地，得意不宜再往。人有喜庆，不可生嫉妒心；人有祸患，不可生喜幸心。善欲人见，不是真善；恶恐人知，便是大恶。见色而起淫心，报在妻女；匿怨而用暗箭，祸延子孙。家门和顺，虽饔飧不继，亦有余欢；国课早完，即囊橐无余，自得至乐。读书志在圣贤，非徒科第；为官心存君国，岂计身家？守分安命，顺时听天。为人若此，庶乎近焉。</p>]]></content>
    
    
    
    <tags>
      
      <tag>鸡汤</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Chrome Inspect</title>
    <link href="/2016/07/29/Chrome-Inspect/"/>
    <url>/2016/07/29/Chrome-Inspect/</url>
    
    <content type="html"><![CDATA[<p><a href="https://developers.google.com/web/tools/chrome-devtools/debug/remote-debugging/remote-debugging" target="_blank" rel="noopener">Remote debug live content on an Android device from your Windows, Mac, or Linux computer.</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>Android</tag>
      
      <tag>Tools</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>openssl学习</title>
    <link href="/2016/07/16/openssl%E5%AD%A6%E4%B9%A0/"/>
    <url>/2016/07/16/openssl%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<blockquote><p>柯克霍夫原则:即使密码系统的任何细节已为人悉知，只要密钥未泄漏，它也应是安全的。</p></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Java注解学习</title>
    <link href="/2016/07/02/Java%E6%B3%A8%E8%A7%A3%E5%AD%A6%E4%B9%A0/"/>
    <url>/2016/07/02/Java%E6%B3%A8%E8%A7%A3%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<p>这段时间使用了butterKnife、retrofit等框架，对Java注解产生了兴趣，感觉不懂Annotation，用着这些框架也不放心：）</p><a id="more"></a><h3 id="什么是注解（Annotation）："><a href="#什么是注解（Annotation）：" class="headerlink" title="什么是注解（Annotation）："></a>什么是注解（Annotation）：</h3><ul><li> Annotation（注解）就是Java提供了一种元程序中的元素关联任何信息和着任何元数据（metadata）的途径和方法。Annotion(注解)是一个接口，程序可以通过反射来获取指定程序元素的Annotion对象，然后通过Annotion对象来获取注解里面的元数据。</li><li> Annotation(注解)是JDK5.0及以后版本引入的。它可以用于创建文档，跟踪代码中的依赖性，甚至执行基本编译时检查。从某些方面看，annotation就像修饰符一样被使用，并应用于包、类 型、构造方法、方法、成员变量、参数、本地变量的声明中。这些信息被存储在Annotation的“name=value”结构对中。</li><li> Annotation的成员在Annotation类型中以无参数的方法的形式被声明。其方法名和返回值定义了该成员的名字和类型。在此有一个特定的默认语法：允许声明任何Annotation成员的默认值：一个Annotation可以将name=value对作为没有定义默认值的Annotation成员的值，当然也可以使用name=value对来覆盖其它成员默认值。这一点有些近似类的继承特性，父类的构造函数可以作为子类的默认构造函数，但是也可以被子类覆盖。</li><li> Annotation能被用来为某个程序元素（类、方法、成员变量等）关联任何的信息。需要注意的是，这里存在着一个基本的规则：Annotation不能影响程序代码的执行，无论增加、删除 Annotation，代码都始终如一的执行。另外，尽管一些annotation通过java的反射api方法在运行时被访问，而java语言解释器在工作时忽略了这些annotation。正是由于java虚拟机忽略了Annotation，导致了annotation类型在代码中是“不起作用”的； 只有通过某种配套的工具才会对annotation类型中的信息进行访问和处理。本文中将涵盖标准的Annotation和meta-annotation类型，陪伴这些annotation类型的工具是java编译器（当然要以某种特殊的方式处理它们）。</li></ul><h3 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h3><ul><li>在Java5.0中，定义的元注解为：<blockquote><p>1.@Target<br>2.@Retention<br>3.@Documented<br>4.@Inherited</p></blockquote></li></ul><h3 id="Target"><a href="#Target" class="headerlink" title="@Target"></a>@Target</h3><ul><li>作用：用于描述注解的使用范围（即：被描述的注解可以用在什么地方）</li><li>取值(ElementType)有：<blockquote><p>1.CONSTRUCTOR:用于描述构造器<br>2.FIELD:用于描述域<br>3.LOCAL_VARIABLE:用于描述局部变量<br>4.METHOD:用于描述方法<br>5.PACKAGE:用于描述包<br>6.PARAMETER:用于描述参数<br>7.TYPE:用于描述类、接口(包括注解类型) 或enum声明</p></blockquote></li><li>示例<div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Target</span>(ElementType.FIELD)<span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> NoDBColumn &#123;&#125;<span class="hljs-meta">@Target</span>(&#123;ElementType.TYPE,ElementType.FIELD&#125;)<span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> NoDBColumn &#123;&#125;</code></pre></div></li></ul><h3 id="Retention"><a href="#Retention" class="headerlink" title="@Retention"></a>@Retention</h3><ul><li>作用：表示需要在什么级别保存该注释信息，用于描述注解的生命周期（即：被描述的注解在什么范围内有效）。默认为CLASS，值为SOURCE大都为MarkAnnotation，这类Annotation大都用来校验，比如Override,Deprecated,SuppressWarnings。</li><li>取值（RetentionPoicy）有：<blockquote><p>1.SOURCE:在源文件中有效（即源文件保留）<br>2.CLASS:在class文件中有效（即class保留）<br>3.RUNTIME:在运行时有效（即运行时保留）</p></blockquote></li><li>示例<div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Target</span>(ElementType.FIELD)<span class="hljs-meta">@Retention</span>(RetentionPolicy.RUNTIME)<span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Column &#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">name</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> "fieldName"</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">setFuncName</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> "setField"</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getFuncName</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> "getField"</span>;     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">defaultDBValue</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">false</span></span>;&#125;</code></pre></div><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo</span> </span>&#123;    <span class="hljs-meta">@Column</span>(name = <span class="hljs-string">"java"</span>,setFuncName = <span class="hljs-string">"jdj"</span>,getFuncName = <span class="hljs-string">"jjj"</span>,defaultDBValue = <span class="hljs-keyword">false</span>)    <span class="hljs-keyword">private</span> String ss;    <span class="hljs-meta">@SuppressWarnings</span>(<span class="hljs-string">"不能这么用"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getString</span><span class="hljs-params">()</span></span>&#123;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.toString();    &#125;&#125;</code></pre></div></li></ul><h3 id="Documented"><a href="#Documented" class="headerlink" title="@Documented"></a>@Documented</h3><ul><li>@Documented用于描述其它类型的annotation应该被作为被标注的程序成员的公共API，因此可以被例如javadoc此类的工具文档化。即是否会保存到Javadoc文档中。</li></ul><h3 id="Inherited"><a href="#Inherited" class="headerlink" title="@Inherited"></a>@Inherited</h3><ul><li>@Inherited 元注解是一个标记注解，@Inherited阐述了某个被标注的类型是被继承的。如果一个使用了@Inherited修饰的annotation类型被用于一个class，则这个annotation将被用于该class的子类。</li><li>注意：@Inherited annotation类型是被标注过的class的子类所继承。类并不从它所实现的接口继承annotation，方法并不从它所重载的方法继承annotation。</li><li>当@Inherited annotation类型标注的annotation的Retention是RetentionPolicy.RUNTIME，则反射API增强了这种继承性。如果我们使用java.lang.reflect去查询一个@Inherited annotation类型的annotation时，反射代码检查将展开工作：检查class和其父类，直到发现指定的annotation类型被发现，或者到达类继承结构的顶层。</li><li>示例<div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Inherited</span><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Greeting &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> FontColor&#123; BULE,RED,GREEN&#125;;    <span class="hljs-function">String <span class="hljs-title">name</span><span class="hljs-params">()</span></span>;    <span class="hljs-function">FontColor <span class="hljs-title">fontColor</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> FontColor.GREEN</span>;&#125;</code></pre></div></li></ul><h3 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h3><ul><li><p>使用@interface自定义注解时，自动继承了java.lang.annotation.Annotation接口，由编译程序自动完成其他细节。在定义注解时，不能继承其他的注解或接口。@interface用来声明一个注解，其中的每一个方法实际上是声明了一个配置参数。方法的名称就是参数的名称，返回值类型就是参数的类型（返回值类型只能是基本类型、Class、String、enum）。可以通过default来声明参数的默认值。</p></li><li><p>定义注解格式：<br><code>public @interface 注解名 {定义体}</code></p></li><li><p>注解参数的可支持数据类型：</p><blockquote><p>1.所有基本数据类型（int,float,boolean,byte,double,char,long,short)<br>2.String类型<br>3.Class类型<br>4.enum类型<br>5.Annotation类型<br>6.以上所有类型的数组</p></blockquote></li><li><p>Annotation类型里面的参数该怎么设定: </p><blockquote><p>第一,只能用public或默认(default)这两个访问权修饰.例如,String value();这里把方法设为defaul默认类型；　 　<br>第二,参数成员只能用基本类型byte,short,char,int,long,float,double,boolean八种基本数据类型和 String,Enum,Class,annotations等数据类型,以及这一些类型的数组.例如,String value();这里的参数成员就为String;　　<br>第三,如果只有一个参数成员,最好把参数名称设为”value”,后加小括号.</p></blockquote></li></ul><h3 id="注解处理器类库-java-lang-reflect-AnnotatedElement"><a href="#注解处理器类库-java-lang-reflect-AnnotatedElement" class="headerlink" title="注解处理器类库(java.lang.reflect.AnnotatedElement)"></a>注解处理器类库(java.lang.reflect.AnnotatedElement)</h3><ul><li><p>Java使用Annotation接口来代表程序元素前面的注解，该接口是所有Annotation类型的父接口。除此之外，Java在java.lang.reflect 包下新增了AnnotatedElement接口，该接口代表程序中可以接受注解的程序元素，该接口主要有如下几个实现类：</p><blockquote><p>Class：类定义<br>Constructor：构造器定义<br>Field：累的成员变量定义<br>Method：类的方法定义<br>Package：类的包定义</p></blockquote></li><li><p>java.lang.reflect 包下主要包含一些实现反射功能的工具类，实际上，java.lang.reflect 包所有提供的反射API扩充了读取运行时Annotation信息的能力。当一个Annotation类型被定义为运行时的Annotation后，该注解才能是运行时可见，当class文件被装载时被保存在class文件中的Annotation才会被虚拟机读取。</p></li><li><p>　AnnotatedElement 接口是所有程序元素（Class、Method和Constructor）的父接口，所以程序通过反射获取了某个类的AnnotatedElement对象之后，程序就可以调用该对象的如下四个个方法来访问Annotation信息：</p><blockquote><p>方法1：<T extends Annotation> T getAnnotation(Class<T> annotationClass): 返回改程序元素上存在的、指定类型的注解，如果该类型注解不存在，则返回null。<br>方法2：Annotation[] getAnnotations():返回该程序元素上存在的所有注解。<br>方法3：boolean is AnnotationPresent(Class&lt;?extends Annotation&gt; annotationClass):判断该程序元素上是否包含指定类型的注解，存在则返回true，否则返回false.<br>方法4：Annotation[] getDeclaredAnnotations()：返回直接存在于此元素上的所有注释。与此接口中的其他方法不同，该方法将忽略继承的注释。（如果没有注释直接存在于此元素上，则返回长度为零的一个数组。）该方法的调用者可以随意修改返回的数组；这不会对其他调用者返回的数组产生任何影响。</p></blockquote></li><li><p>示例</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/***********注解声明***************/</span><span class="hljs-comment">/**</span><span class="hljs-comment"> * 水果名称注解</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> peida</span><span class="hljs-comment"> *</span><span class="hljs-comment"> */</span><span class="hljs-meta">@Target</span>(ElementType.FIELD)<span class="hljs-meta">@Retention</span>(RetentionPolicy.RUNTIME)<span class="hljs-meta">@Documented</span><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> FruitName &#123;    <span class="hljs-function">String <span class="hljs-title">value</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> ""</span>;&#125;</code></pre></div><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 水果颜色注解</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> peida</span><span class="hljs-comment"> *</span><span class="hljs-comment"> */</span><span class="hljs-meta">@Target</span>(ElementType.FIELD)<span class="hljs-meta">@Retention</span>(RetentionPolicy.RUNTIME)<span class="hljs-meta">@Documented</span><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> FruitColor &#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 颜色枚举</span><span class="hljs-comment">     * <span class="hljs-doctag">@author</span> peida</span><span class="hljs-comment">     *</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> Color&#123; BULE,RED,GREEN&#125;;        <span class="hljs-comment">/**</span><span class="hljs-comment">     * 颜色属性</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span>    <span class="hljs-function">Color <span class="hljs-title">fruitColor</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> Color.GREEN</span>;&#125;</code></pre></div><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 水果供应者注解</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> peida</span><span class="hljs-comment"> *</span><span class="hljs-comment"> */</span><span class="hljs-meta">@Target</span>(ElementType.FIELD)<span class="hljs-meta">@Retention</span>(RetentionPolicy.RUNTIME)<span class="hljs-meta">@Documented</span><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> FruitProvider &#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 供应商编号</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">id</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> -1</span>;        <span class="hljs-comment">/**</span><span class="hljs-comment">     * 供应商名称</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">name</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> ""</span>;        <span class="hljs-comment">/**</span><span class="hljs-comment">     * 供应商地址</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">address</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> ""</span>;&#125;</code></pre></div><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/***********注解使用***************/</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Apple</span> </span>&#123;        <span class="hljs-meta">@FruitName</span>(<span class="hljs-string">"Apple"</span>)    <span class="hljs-keyword">private</span> String appleName;        <span class="hljs-meta">@FruitColor</span>(fruitColor=Color.RED)    <span class="hljs-keyword">private</span> String appleColor;        <span class="hljs-meta">@FruitProvider</span>(id=<span class="hljs-number">1</span>,name=<span class="hljs-string">"陕西红富士集团"</span>,address=<span class="hljs-string">"陕西省西安市延安路89号红富士大厦"</span>)    <span class="hljs-keyword">private</span> String appleProvider;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAppleColor</span><span class="hljs-params">(String appleColor)</span> </span>&#123;        <span class="hljs-keyword">this</span>.appleColor = appleColor;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getAppleColor</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> appleColor;    &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAppleName</span><span class="hljs-params">(String appleName)</span> </span>&#123;        <span class="hljs-keyword">this</span>.appleName = appleName;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getAppleName</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> appleName;    &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAppleProvider</span><span class="hljs-params">(String appleProvider)</span> </span>&#123;        <span class="hljs-keyword">this</span>.appleProvider = appleProvider;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getAppleProvider</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> appleProvider;    &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">displayName</span><span class="hljs-params">()</span></span>&#123;        System.out.println(<span class="hljs-string">"水果的名字是：苹果"</span>);    &#125;&#125;</code></pre></div><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/***********注解处理器***************/</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FruitInfoUtil</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getFruitInfo</span><span class="hljs-params">(Class&lt;?&gt; clazz)</span></span>&#123;                String strFruitName=<span class="hljs-string">" 水果名称："</span>;        String strFruitColor=<span class="hljs-string">" 水果颜色："</span>;        String strFruitProvicer=<span class="hljs-string">"供应商信息："</span>;                Field[] fields = clazz.getDeclaredFields();                <span class="hljs-keyword">for</span>(Field field :fields)&#123;            <span class="hljs-keyword">if</span>(field.isAnnotationPresent(FruitName<span class="hljs-class">.<span class="hljs-keyword">class</span>))</span>&#123;                FruitName fruitName = (FruitName) field.getAnnotation(FruitName<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;                strFruitName=strFruitName+fruitName.value();                System.out.println(strFruitName);            &#125;            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(field.isAnnotationPresent(FruitColor<span class="hljs-class">.<span class="hljs-keyword">class</span>))</span>&#123;                FruitColor fruitColor= (FruitColor) field.getAnnotation(FruitColor<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;                strFruitColor=strFruitColor+fruitColor.fruitColor().toString();                System.out.println(strFruitColor);            &#125;            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(field.isAnnotationPresent(FruitProvider<span class="hljs-class">.<span class="hljs-keyword">class</span>))</span>&#123;                FruitProvider fruitProvider= (FruitProvider) field.getAnnotation(FruitProvider<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;                strFruitProvicer=<span class="hljs-string">" 供应商编号："</span>+fruitProvider.id()+<span class="hljs-string">" 供应商名称："</span>+fruitProvider.name()+<span class="hljs-string">" 供应商地址："</span>+fruitProvider.address();                System.out.println(strFruitProvicer);            &#125;        &#125;    &#125;&#125;</code></pre></div><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/***********输出结果***************/</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FruitRun</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> args</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;                FruitInfoUtil.getFruitInfo(Apple<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;            &#125;&#125;==================================== 水果名称：Apple 水果颜色：RED 供应商编号：<span class="hljs-number">1</span> 供应商名称：陕西红富士集团 供应商地址：陕西省西安市延安路<span class="hljs-number">89</span>号红富士大厦</code></pre></div></li></ul><hr><blockquote><p>感谢 <a href="http://www.cnblogs.com/peida/" target="_blank" rel="noopener">http://www.cnblogs.com/peida/</a></p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>注解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>git aliases at oh-my-zsh</title>
    <link href="/2016/06/22/git-aliases-at-oh-my-zsh/"/>
    <url>/2016/06/22/git-aliases-at-oh-my-zsh/</url>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/robbyrussell/oh-my-zsh/wiki/Plugin:git">https://github.com/robbyrussell/oh-my-zsh/wiki/Plugin:git</a></p><h2 id="The-git-Plugin"><a href="#The-git-Plugin" class="headerlink" title="The git Plugin"></a>The git Plugin</h2><a id="more"></a><p>The <a href="https://github.com/robbyrussell/oh-my-zsh/tree/master/plugins/git">git</a> plugin provides many <a href="#aliases">aliases</a> and a few useful <a href="#functions">functions</a>.</p><p>Enable it by adding <em>git</em> to the <a href="https://github.com/robbyrussell/oh-my-zsh/blob/master/templates/zshrc.zsh-template#L48"><em>plugins array</em></a> before sourcing OMZ (see [[Plugins]]).</p><h2 id="Aliases"><a href="#Aliases" class="headerlink" title="Aliases"></a>Aliases</h2><table><thead><tr><th align="left">Alias</th><th align="left">Command</th></tr></thead><tbody><tr><td align="left">g</td><td align="left">git</td></tr><tr><td align="left">ga</td><td align="left">git add</td></tr><tr><td align="left">gaa</td><td align="left">git add –all</td></tr><tr><td align="left">gapa</td><td align="left">git add –patch</td></tr><tr><td align="left">gb</td><td align="left">git branch</td></tr><tr><td align="left">gba</td><td align="left">git branch -a</td></tr><tr><td align="left">gbda</td><td align="left">git branch –merged | command grep -vE “^(*|\s<em>master\s</em>$)” | command xargs -n 1 git branch -d</td></tr><tr><td align="left">gbl</td><td align="left">git blame -b -w</td></tr><tr><td align="left">gbnm</td><td align="left">git branch –no-merged</td></tr><tr><td align="left">gbr</td><td align="left">git branch –remote</td></tr><tr><td align="left">gbs</td><td align="left">git bisect</td></tr><tr><td align="left">gbsb</td><td align="left">git bisect bad</td></tr><tr><td align="left">gbsg</td><td align="left">git bisect good</td></tr><tr><td align="left">gbsr</td><td align="left">git bisect reset</td></tr><tr><td align="left">gbss</td><td align="left">git bisect start</td></tr><tr><td align="left">gc</td><td align="left">git commit -v</td></tr><tr><td align="left">gc!</td><td align="left">git commit -v –amend</td></tr><tr><td align="left">gca</td><td align="left">git commit -v -a</td></tr><tr><td align="left">gcam</td><td align="left">git commit -a -m</td></tr><tr><td align="left">gca!</td><td align="left">git commit -v -a –amend</td></tr><tr><td align="left">gcan!</td><td align="left">git commit -v -a -s –no-edit –amend</td></tr><tr><td align="left">gcb</td><td align="left">git checkout -b</td></tr><tr><td align="left">gcf</td><td align="left">git config –list</td></tr><tr><td align="left">gcl</td><td align="left">git clone –recursive</td></tr><tr><td align="left">gclean</td><td align="left">git clean -df</td></tr><tr><td align="left">gcm</td><td align="left">git checkout master</td></tr><tr><td align="left">gcmsg</td><td align="left">git commit -m</td></tr><tr><td align="left">gco</td><td align="left">git checkout</td></tr><tr><td align="left">gcount</td><td align="left">git shortlog -sn</td></tr><tr><td align="left">gcp</td><td align="left">git cherry-pick</td></tr><tr><td align="left">gcs</td><td align="left">git commit -S</td></tr><tr><td align="left">gd</td><td align="left">git diff</td></tr><tr><td align="left">gdca</td><td align="left">git diff –cached</td></tr><tr><td align="left">gdt</td><td align="left">git diff-tree –no-commit-id –name-only -r</td></tr><tr><td align="left">gdw</td><td align="left">git diff –word-diff</td></tr><tr><td align="left">gf</td><td align="left">git fetch</td></tr><tr><td align="left">gfa</td><td align="left">git fetch –all –prune</td></tr><tr><td align="left">gfo</td><td align="left">git fetch origin</td></tr><tr><td align="left">gg</td><td align="left">git gui citool</td></tr><tr><td align="left">gga</td><td align="left">git gui citool –amend</td></tr><tr><td align="left">ggpull</td><td align="left">ggl</td></tr><tr><td align="left">ggpur</td><td align="left">ggu</td></tr><tr><td align="left">ggpush</td><td align="left">ggp</td></tr><tr><td align="left">ggsup</td><td align="left">git branch –set-upstream-to = origin/$(current_branch)</td></tr><tr><td align="left">gignore</td><td align="left">git update-index –assume-unchanged</td></tr><tr><td align="left">gignored</td><td align="left"><code>git ls-files -v | grep &quot;^[[:lower:]]&quot;</code></td></tr><tr><td align="left">git-svn-dcommit-push</td><td align="left">git svn dcommit &amp;&amp; git push github master:svntrunk</td></tr><tr><td align="left">gk</td><td align="left">\gitk –all –branches</td></tr><tr><td align="left">gke</td><td align="left">\gitk –all $(git log -g –pretty = format:%h)</td></tr><tr><td align="left">gl</td><td align="left">git pull</td></tr><tr><td align="left">glg</td><td align="left">git log –stat –color</td></tr><tr><td align="left">glgg</td><td align="left">git log –graph –color</td></tr><tr><td align="left">glgga</td><td align="left">git log –graph –decorate –all</td></tr><tr><td align="left">glgm</td><td align="left">git log –graph –max-count = 10</td></tr><tr><td align="left">glgp</td><td align="left">git log –stat –color -p</td></tr><tr><td align="left">glo</td><td align="left">git log –oneline –decorate –color</td></tr><tr><td align="left">glog</td><td align="left">git log –oneline –decorate –color –graph</td></tr><tr><td align="left">glol</td><td align="left">git log –graph –pretty = format:’%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset’ –abbrev-commit</td></tr><tr><td align="left">glola</td><td align="left">git log –graph –pretty = format:’%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset’ –abbrev-commit –all</td></tr><tr><td align="left">glp</td><td align="left">_git_log_prettily</td></tr><tr><td align="left">gm</td><td align="left">git merge</td></tr><tr><td align="left">gmom</td><td align="left">git merge origin/master</td></tr><tr><td align="left">gmt</td><td align="left">git mergetool –no-prompt</td></tr><tr><td align="left">gmtvim</td><td align="left">git mergetool –no-prompt –tool = vimdiff</td></tr><tr><td align="left">gmum</td><td align="left">git merge upstream/master</td></tr><tr><td align="left">gp</td><td align="left">git push</td></tr><tr><td align="left">gpd</td><td align="left">git push –dry-run</td></tr><tr><td align="left">gpoat</td><td align="left">git push origin –all &amp;&amp; git push origin –tags</td></tr><tr><td align="left"></td><td align="left"></td></tr><tr><td align="left">gpristine</td><td align="left">git reset –hard &amp;&amp; git clean -dfx</td></tr><tr><td align="left"></td><td align="left"></td></tr><tr><td align="left">gpu</td><td align="left">git push upstream</td></tr><tr><td align="left">gpv</td><td align="left">git push -v</td></tr><tr><td align="left">gr</td><td align="left">git remote</td></tr><tr><td align="left">gra</td><td align="left">git remote add</td></tr><tr><td align="left">grb</td><td align="left">git rebase</td></tr><tr><td align="left">grba</td><td align="left">git rebase –abort</td></tr><tr><td align="left">grbc</td><td align="left">git rebase –continue</td></tr><tr><td align="left">grbi</td><td align="left">git rebase -i</td></tr><tr><td align="left">grbm</td><td align="left">git rebase master</td></tr><tr><td align="left">grbs</td><td align="left">git rebase –skip</td></tr><tr><td align="left">grh</td><td align="left">git reset HEAD</td></tr><tr><td align="left">grhh</td><td align="left">git reset HEAD –hard</td></tr><tr><td align="left">grmv</td><td align="left">git remote rename</td></tr><tr><td align="left">grrm</td><td align="left">git remote remove</td></tr><tr><td align="left">grset</td><td align="left">git remote set-url</td></tr><tr><td align="left">grt</td><td align="left">cd $(git rev-parse –show-toplevel || echo “.”)</td></tr><tr><td align="left">gru</td><td align="left">git reset –</td></tr><tr><td align="left">grup</td><td align="left">git remote update</td></tr><tr><td align="left">grv</td><td align="left">git remote -v</td></tr><tr><td align="left">gsb</td><td align="left">git status -sb</td></tr><tr><td align="left">gsd</td><td align="left">git svn dcommit</td></tr><tr><td align="left">gsi</td><td align="left">git submodule init</td></tr><tr><td align="left">gsps</td><td align="left">git show –pretty = short –show-signature</td></tr><tr><td align="left">gsr</td><td align="left">git svn rebase</td></tr><tr><td align="left">gss</td><td align="left">git status -s</td></tr><tr><td align="left">gst</td><td align="left">git status</td></tr><tr><td align="left">gsta</td><td align="left">git stash</td></tr><tr><td align="left">gstaa</td><td align="left">git stash apply</td></tr><tr><td align="left">gstd</td><td align="left">git stash drop</td></tr><tr><td align="left">gstl</td><td align="left">git stash list</td></tr><tr><td align="left">gstp</td><td align="left">git stash pop</td></tr><tr><td align="left">gsts</td><td align="left">git stash show –text</td></tr><tr><td align="left">gsu</td><td align="left">git submodule update</td></tr><tr><td align="left">gts</td><td align="left">git tag -s</td></tr><tr><td align="left">gunignore</td><td align="left">git update-index –no-assume-unchanged</td></tr><tr><td align="left">gunwip</td><td align="left">git log -n 1 | grep -q -c “--wip--“ &amp;&amp; git reset HEAD~1</td></tr><tr><td align="left">gup</td><td align="left">git pull –rebase</td></tr><tr><td align="left">gupv</td><td align="left">git pull –rebase -v</td></tr><tr><td align="left">glum</td><td align="left">git pull upstream master</td></tr><tr><td align="left">gvt</td><td align="left">git verify-tag</td></tr><tr><td align="left">gwch</td><td align="left">git whatchanged -p –abbrev-commit –pretty = medium</td></tr><tr><td align="left">gwip</td><td align="left">git add -A; git rm $(git ls-files –deleted) 2&gt; /dev/null; git commit -m “–wip–”</td></tr></tbody></table><h2 id="Deprecated-Aliases"><a href="#Deprecated-Aliases" class="headerlink" title="Deprecated Aliases"></a>Deprecated Aliases</h2><p>These are aliases that have been removed, renamed, or otherwise modified in a way that may, or may not, receive further support.</p><table><thead><tr><th align="left">Alias</th><th align="left">Command</th><th>Modification</th></tr></thead><tbody><tr><td align="left">gap</td><td align="left">git add –patch</td><td>new alias <code>gapa</code></td></tr><tr><td align="left">gcl</td><td align="left">git config –list</td><td>new alias <code>gcf</code></td></tr><tr><td align="left">gdc</td><td align="left">git diff –cached</td><td>new alias <code>gdca</code></td></tr><tr><td align="left">gdt</td><td align="left">git difftool</td><td>no replacement</td></tr><tr><td align="left">ggpull</td><td align="left">git pull origin $(current_branch)</td><td>new alias <code>ggl</code> (<code>ggpull</code> still exists for now though)</td></tr><tr><td align="left">ggpur</td><td align="left">git pull –rebase origin $(current_branch)</td><td>new alias <code>ggu</code> (<code>ggpur</code> still exists for now though)</td></tr><tr><td align="left">ggpush</td><td align="left">git push origin $(current_branch)</td><td>new alias <code>ggp</code> (<code>ggpush</code> still exists for now though)</td></tr><tr><td align="left">gk</td><td align="left">gitk –all –branches</td><td>now aliased to <code>\gitk --all --branches</code></td></tr><tr><td align="left">glg</td><td align="left">git log –stat –max-count = 10</td><td>now aliased to <code>git log --stat --color</code></td></tr><tr><td align="left">glgg</td><td align="left">git log –graph –max-count = 10</td><td>now aliased to <code>git log --graph --color</code></td></tr><tr><td align="left">gwc</td><td align="left">git whatchanged -p –abbrev-commit –pretty = medium</td><td>new alias <code>gwch</code></td></tr><tr><td align="left">gwip</td><td align="left">git add -A; git ls-files –deleted -z | xargs -r0 git rm; git commit -m “–wip–”</td><td>now aliased to <code>git add -A; git rm $(git ls-files --deleted) 2&gt; /dev/null; git commit -m &quot;--wip--&quot;</code></td></tr></tbody></table><h2 id="Functions"><a href="#Functions" class="headerlink" title="Functions"></a>Functions</h2><h3 id="Current"><a href="#Current" class="headerlink" title="Current"></a>Current</h3><table><thead><tr><th align="left">Command</th><th align="left">Description</th></tr></thead><tbody><tr><td align="left">current_branch</td><td align="left">Return the name of the current branch</td></tr><tr><td align="left">current_repository</td><td align="left">Return the names of the current remotes</td></tr><tr><td align="left">git_current_user_name</td><td align="left">Returns the <code>user.name</code> config value</td></tr><tr><td align="left">git_current_user_email</td><td align="left">Returns the <code>user.email</code> config value</td></tr></tbody></table><h3 id="WiP"><a href="#WiP" class="headerlink" title="WiP"></a>WiP</h3><p>These features allow to pause a branch development and switch to another one (<em>“Work in Progress”</em>,  or wip). When you want to go back to work, just unwip it.</p><table><thead><tr><th align="left">Command</th><th align="left">Description</th></tr></thead><tbody><tr><td align="left">work_in_progress</td><td align="left">Echoes a warning if the current branch is a wip</td></tr><tr><td align="left">gwip</td><td align="left">Commit wip branch</td></tr><tr><td align="left">gunwip</td><td align="left">Uncommit wip branch</td></tr></tbody></table>]]></content>
    
    
    
    <tags>
      
      <tag>git</tag>
      
      <tag>shell</tag>
      
      <tag>oh-my-zsh</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android博客收集</title>
    <link href="/2016/06/20/Android%E5%8D%9A%E5%AE%A2%E6%94%B6%E9%9B%86/"/>
    <url>/2016/06/20/Android%E5%8D%9A%E5%AE%A2%E6%94%B6%E9%9B%86/</url>
    
    <content type="html"><![CDATA[<blockquote><p>看到了一些不错的博客，mark一下<br>from <a href="https://github.com/venshine/AndroidNote">https://github.com/venshine/AndroidNote</a><br>我又添加了一部分自己收集的</p></blockquote><a id="more"></a><h2 id="神一般的公司"><a href="#神一般的公司" class="headerlink" title="神一般的公司"></a>神一般的公司</h2><ul><li>Square<br><a href="http://square.github.io/" target="_blank" rel="noopener">http://square.github.io/</a></li><li>Facebook<br><a href="https://code.facebook.com/projects/" target="_blank" rel="noopener">https://code.facebook.com/projects/</a></li><li>LinkedIn<br><a href="http://linkedin.github.io/" target="_blank" rel="noopener">http://linkedin.github.io/</a></li><li>Google</li></ul><h2 id="RxJava"><a href="#RxJava" class="headerlink" title="RxJava"></a>RxJava</h2><h3 id="入门教程"><a href="#入门教程" class="headerlink" title="入门教程"></a>入门教程</h3><ul><li><a href="https://gank.io/post/560e15be2dca930e00da1083#toc_2" target="_blank" rel="noopener">给 Android 开发者的 RxJava 详解</a></li><li><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/topics/Getting-Started.html" target="_blank" rel="noopener">RxJava入门指南</a></li></ul><h3 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h3><ul><li><a href="http://gank.io/post/56e80c2c677659311bed9841?hmsr=toutiao.io&utm_medium=toutiao.io&utm_source=toutiao.io" target="_blank" rel="noopener">RxJava 与 Retrofit 结合的最佳实践</a></li></ul><h2 id="MediaPlayer"><a href="#MediaPlayer" class="headerlink" title="MediaPlayer"></a>MediaPlayer</h2><h3 id="android-openslmediaplayer"><a href="#android-openslmediaplayer" class="headerlink" title="android-openslmediaplayer"></a>android-openslmediaplayer</h3><ul><li>Re-implementation of Android’s MediaPlayer and audio effect classes based on OpenSL ES APIs.</li><li><a href="https://github.com/h6ah4i/android-openslmediaplayer">android-openslmediaplayer</a></li></ul><h2 id="控件"><a href="#控件" class="headerlink" title="控件"></a>控件</h2><h3 id="下拉刷新-加载更多"><a href="#下拉刷新-加载更多" class="headerlink" title="下拉刷新 + 加载更多"></a>下拉刷新 + 加载更多</h3><ul><li><a href="https://github.com/liaohuqiu/android-Ultra-Pull-To-Refresh">任意控件实现下拉刷新</a><br> <a href="https://github.com/liaohuqiu/android-Ultra-Pull-To-Refresh/blob/master/README-cn.md">中文文档</a></li><li><a href="https://github.com/sfsheng0322/MarqueeView">俗名：垂直跑马灯；学名：垂直翻页公告</a></li><li><a href="https://github.com/baoyachi/StepView">Step by step，流程指示器</a></li></ul><h3 id="Toggle-Button"><a href="#Toggle-Button" class="headerlink" title="Toggle Button"></a>Toggle Button</h3><ul><li><a href="https://github.com/kyleduo/SwitchButton">多种风格SwitchButton</a></li><li><a href="https://github.com/Nightonke/JellyToggleButton">JellyToggleButton</a><br>果冻效果ToggleButton</li></ul><h3 id="FloatActionButton"><a href="#FloatActionButton" class="headerlink" title="FloatActionButton"></a>FloatActionButton</h3><ul><li><a href="https://github.com/oguzbilgener/CircularFloatingActionMenu">CircularFloatingActionMenu</a></li><li><a href="https://github.com/Trity93/android-floating-action-button">android-floating-action-button</a></li></ul><h3 id="Material-Design"><a href="#Material-Design" class="headerlink" title="Material Design"></a>Material Design</h3><ul><li><a href="https://github.com/rey5137/material">material</a></li></ul><h3 id="可拖拽的gridView"><a href="#可拖拽的gridView" class="headerlink" title="可拖拽的gridView"></a>可拖拽的gridView</h3><ul><li><a href="https://github.com/xmuSistone/android-drag-square">android-drag-square</a></li><li><a href="https://github.com/halibobo/TouchListenerConflict">TouchListenerConflict</a></li><li><a href="https://github.com/fishCoder/DragGridView">DragGridView</a></li></ul><h3 id="Lock-View"><a href="#Lock-View" class="headerlink" title="Lock View"></a>Lock View</h3><ul><li><a href="https://github.com/aritraroy/PinLockView">PinLockView</a></li></ul><h3 id="RecyclerView-ListView"><a href="#RecyclerView-ListView" class="headerlink" title="RecyclerView/ListView"></a>RecyclerView/ListView</h3><ul><li><a href="https://github.com/TonicArtos/SuperSLiM">SuperSLiM</a><br>A layout manager for the RecyclerView with interchangeable linear, grid, and staggered displays of views, all with configurable section headers including the sticky variety as specified in the material design docs.</li><li><a href="https://github.com/waynell/VideoListPlayer">VideoListPlayer</a><br>VideoListPlayer实现了在列表控件（ListView, RecyclerView）中加载并播放视频，并支持滑动时自动播放/暂停的功能</li><li><a href="https://github.com/nikhilpanju/RecyclerViewEnhanced">RecyclerViewEnhanced</a><br>支持侧滑的recyclerView</li><li><a href="https://github.com/ulexzhong/PinnedHeaderLetterListView">PinnedHeaderLetterListView</a></li><li><a href="https://github.com/qs-lll/ExpandingPager">ExpandingPager</a><br>炒鸡牛逼的ExpandingPager效果</li><li><a href="https://github.com/CaMnter/EasyRecyclerViewSidebar">EasyRecyclerViewSidebar</a></li></ul><h3 id="Loading-View"><a href="#Loading-View" class="headerlink" title="Loading View"></a>Loading View</h3><ul><li><a href="https://github.com/JeasonWong/BezierLoadingView">BezierLoadingView</a></li><li><a href="https://github.com/ldoublem/LoadingView">LoadingView</a></li><li><a href="https://github.com/feeeei/CircleSeekbar">CircleSeekbar</a><br>一款圆环形的选择器，支持叠加使用。</li></ul><h3 id="多主题框架"><a href="#多主题框架" class="headerlink" title="多主题框架"></a>多主题框架</h3><ul><li><a href="https://github.com/Bilibili/MagicaSakura">MagicaSakura</a></li></ul><h3 id="Android版的代码高亮"><a href="#Android版的代码高亮" class="headerlink" title="Android版的代码高亮"></a>Android版的代码高亮</h3><ul><li><a href="https://github.com/Thereisnospon/CodeView">codeView</a></li></ul><h3 id="Dialog"><a href="#Dialog" class="headerlink" title="Dialog"></a>Dialog</h3><ul><li><a href="https://github.com/javiersantos/BottomDialogs">BottomDialogs</a><br>An Android library that shows a customizable Material-based bottom sheet. API 11+ required.</li></ul><h3 id="跑马灯"><a href="#跑马灯" class="headerlink" title="跑马灯"></a>跑马灯</h3><ul><li><a href="https://github.com/sfsheng0322/MarqueeView">MarqueeView</a></li></ul><h2 id="Log工具"><a href="#Log工具" class="headerlink" title="Log工具"></a>Log工具</h2><ul><li><a href="https://github.com/JakeWharton/timber">timber</a></li></ul><h2 id="模糊工具（高斯模糊）"><a href="#模糊工具（高斯模糊）" class="headerlink" title="模糊工具（高斯模糊）"></a>模糊工具（高斯模糊）</h2><ul><li><a href="https://github.com/wasabeef/Blurry">Blurry</a></li></ul><h2 id="在线压缩图片"><a href="#在线压缩图片" class="headerlink" title="在线压缩图片"></a>在线压缩图片</h2><ul><li><a href="https://tinypng.com/" target="_blank" rel="noopener">tinypng</a></li></ul><h2 id="在线编程"><a href="#在线编程" class="headerlink" title="在线编程"></a>在线编程</h2><ul><li><a href="http://www.shucunwang.com/RunCode/java/" target="_blank" rel="noopener">在线编程</a></li></ul><h2 id="面试-amp-简历"><a href="#面试-amp-简历" class="headerlink" title="面试&amp;简历"></a>面试&amp;简历</h2><h3 id="stormzhang原创"><a href="#stormzhang原创" class="headerlink" title="stormzhang原创"></a>stormzhang原创</h3><ul><li><a href="http://mp.weixin.qq.com/s?__biz=MzA4NTQwNDcyMA==&mid=402970472&idx=1&sn=b9738c66fb5750c2515d57357c01a83f&scene=21#wechat_redirect" target="_blank" rel="noopener">你真的会写简历么？</a></li><li><a href="http://mp.weixin.qq.com/s?__biz=MzA4NTQwNDcyMA==&mid=2650661810&idx=1&sn=f8c1ca67527459db3189a978f0e44cef&scene=21#wechat_redirect" target="_blank" rel="noopener">面试时企业最看中你什么能力？</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzA4NTQwNDcyMA==&mid=2650661871&idx=1&sn=158c380826bb9138fdb2976152dc279b&scene=0&key=f5c31ae61525f82e22762b63d33db67ac2c3b9129c378c3aa7e88c19f2611fad10b345893a62055c91c4cec68db049d5&ascene=0&uin=MTg0MzczMzc0MQ%3D%3D" target="_blank" rel="noopener">我面试到底问什么？</a></li></ul><h2 id="第一部分-nbsp-nbsp-nbsp-nbsp-技术框架"><a href="#第一部分-nbsp-nbsp-nbsp-nbsp-技术框架" class="headerlink" title="第一部分&nbsp;&nbsp;&nbsp;&nbsp;技术框架"></a>第一部分&nbsp;&nbsp;&nbsp;&nbsp;技术框架</h2><h3 id="图片加载"><a href="#图片加载" class="headerlink" title="图片加载"></a>图片加载</h3><ul><li><a href="https://github.com/bumptech/glide">Glide</a></li><li><a href="http://fresco-cn.org/" target="_blank" rel="noopener">Fresco</a></li><li><a href="http://developer.android.com/intl/zh-cn/training/volley/request.html#request-image" target="_blank" rel="noopener">Volley</a></li><li><a href="http://square.github.io/picasso/" target="_blank" rel="noopener">Picasso</a></li><li><a href="https://github.com/nostra13/Android-Universal-Image-Loader">Universal Image Loader</a></li></ul><h3 id="网络请求"><a href="#网络请求" class="headerlink" title="网络请求"></a>网络请求</h3><ul><li><a href="http://square.github.io/okhttp/" target="_blank" rel="noopener">okhttp</a></li><li><a href="http://square.github.io/retrofit/" target="_blank" rel="noopener">retrofit</a></li><li><a href="http://developer.android.com/intl/zh-cn/training/volley/index.html" target="_blank" rel="noopener">Volley</a></li><li><a href="http://loopj.com/android-async-http/" target="_blank" rel="noopener">android-async-http</a></li></ul><h3 id="数据库ORM"><a href="#数据库ORM" class="headerlink" title="数据库ORM"></a>数据库ORM</h3><ul><li><a href="http://ormlite.com/" target="_blank" rel="noopener">OrmLite</a></li><li><a href="http://greenrobot.org/greendao/" target="_blank" rel="noopener">greenDAO</a></li><li><a href="http://satyan.github.io/sugar/" target="_blank" rel="noopener">sugar</a></li><li><a href="https://github.com/realm/realm-java">realm</a></li></ul><h3 id="Json解析"><a href="#Json解析" class="headerlink" title="Json解析"></a>Json解析</h3><ul><li><a href="https://github.com/google/gson">gson</a></li><li><a href="https://github.com/alibaba/fastjson">fastjson</a></li><li><a href="https://github.com/FasterXML/jackson">jackson</a></li></ul><h3 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h3><ul><li><a href="http://google.github.io/dagger/" target="_blank" rel="noopener">Dagger 2</a></li><li><a href="http://jakewharton.github.io/butterknife/" target="_blank" rel="noopener">Butter Knife</a></li><li><a href="https://github.com/roboguice/roboguice">RoboGuice</a></li></ul><h3 id="快速开发"><a href="#快速开发" class="headerlink" title="快速开发"></a>快速开发</h3><ul><li><a href="https://github.com/yangfuhai/afinal">afinal</a></li><li><a href="https://github.com/wyouflf/xUtils3">xUtils3</a></li><li><a href="https://github.com/white-cat/ThinkAndroid">ThinkAndroid</a></li><li><a href="https://github.com/gdpancheng/LoonAndroid3">LoonAndroid3</a></li><li><a href="https://github.com/kymjs/KJFrameForAndroid">KJFrameForAndroid</a></li></ul><h3 id="动态加载"><a href="#动态加载" class="headerlink" title="动态加载"></a>动态加载</h3><ul><li><a href="https://github.com/singwhatiwanna/dynamic-load-apk">dynamic-load-apk</a></li><li><a href="https://github.com/CtripMobile/DynamicAPK">DynamicAPK</a></li><li><a href="https://github.com/Qihoo360/DroidPlugin">DroidPlugin</a></li><li><a href="https://github.com/mmin18/AndroidDynamicLoader">AndroidDynamicLoader</a></li><li><a href="https://github.com/houkx/android-pluginmgr">android-pluginmgr</a></li><li><a href="https://github.com/DroidPluginTeam/DroidPlugin">DroidPlugin</a></li><li><a href="https://github.com/bunnyblue/ACDD">ACDD</a></li></ul><h3 id="热修复"><a href="#热修复" class="headerlink" title="热修复"></a>热修复</h3><ul><li><a href="https://github.com/alibaba/AndFix">AndFix</a></li><li><a href="https://github.com/rovo89/Xposed">Xposed</a></li><li><a href="https://github.com/alibaba/dexposed">dexposed</a></li><li><a href="https://github.com/dodola/HotFix">HotFix</a></li><li><a href="https://github.com/jasonross/Nuwa">Nuwa</a></li><li><a href="https://github.com/bunnyblue/DroidFix">DroidFix</a></li></ul><h3 id="事件总线"><a href="#事件总线" class="headerlink" title="事件总线"></a>事件总线</h3><ul><li><a href="http://greenrobot.org/eventbus/" target="_blank" rel="noopener">EventBus</a></li><li><a href="http://square.github.io/otto/" target="_blank" rel="noopener">Otto</a></li></ul><h2 id="第二部分-nbsp-nbsp-nbsp-nbsp-博客社区"><a href="#第二部分-nbsp-nbsp-nbsp-nbsp-博客社区" class="headerlink" title="第二部分&nbsp;&nbsp;&nbsp;&nbsp;博客社区"></a>第二部分&nbsp;&nbsp;&nbsp;&nbsp;博客社区</h2><h3 id="个人博客"><a href="#个人博客" class="headerlink" title="个人博客"></a>个人博客</h3><ul><li><a href="http://blog.csdn.net/luoshengyang" target="_blank" rel="noopener">老罗的Android之旅</a></li><li><a href="http://www.jcodecraeer.com/" target="_blank" rel="noopener">泡在网上的日子</a></li><li><a href="http://www.trinea.cn/" target="_blank" rel="noopener">Trinea</a></li><li><a href="http://blog.csdn.net/guolin_blog" target="_blank" rel="noopener">郭霖</a></li><li><a href="http://blog.csdn.net/xiaanming" target="_blank" rel="noopener">夏安明</a></li><li><a href="http://blog.csdn.net/lmj623565791" target="_blank" rel="noopener">鸿阳</a></li><li><a href="http://androidweekly.cn/" target="_blank" rel="noopener">Android开发技术周报</a></li><li><a href="http://blog.csdn.net/singwhatiwanna" target="_blank" rel="noopener">任玉刚</a></li><li><a href="http://blog.chengyunfeng.com/" target="_blank" rel="noopener">云在千峰</a></li><li><a href="http://hukai.me/" target="_blank" rel="noopener">胡凯</a></li><li><a href="http://stormzhang.com/" target="_blank" rel="noopener">stormzhang</a></li><li><a href="https://github.com/litesuits">马天宇</a></li><li><a href="http://www.lcode.org/" target="_blank" rel="noopener">江清清的技术专栏</a></li><li><a href="http://www.ruanyifeng.com/blog/" target="_blank" rel="noopener">阮一峰的网络日志</a></li><li><a href="http://blog.kymjs.com/" target="_blank" rel="noopener">张涛-开源实验室</a></li><li><a href="https://xiequan.info/" target="_blank" rel="noopener">谢权SELF</a></li><li><a href="http://blog.csdn.net/bboyfeiyu" target="_blank" rel="noopener">Mr.Simple的专栏</a></li><li><a href="http://droidyue.com/" target="_blank" rel="noopener">技术小黑屋</a></li><li><a href="https://drakeet.me/" target="_blank" rel="noopener">Drakeet的个人博客</a></li><li><a href="http://blog.csdn.net/eclipsexys" target="_blank" rel="noopener">eclipse_xu</a></li><li><a href="http://blog.csdn.net/ElinaVampire" target="_blank" rel="noopener">子墨博客</a></li><li><a href="http://blog.csdn.net/wwj_748" target="_blank" rel="noopener">巫山老妖</a></li><li><a href="http://blog.csdn.net/aigestudio" target="_blank" rel="noopener">AigeStudio</a></li><li><a href="http://www.xuanyusong.com/" target="_blank" rel="noopener">雨松MOMO程序研究院</a></li></ul><h3 id="团队博客"><a href="#团队博客" class="headerlink" title="团队博客"></a>团队博客</h3><ul><li><a href="http://android-developers.blogspot.com/" target="_blank" rel="noopener">Android官方技术博客</a></li><li><a href="http://tech.meituan.com/" target="_blank" rel="noopener">美团点评技术团队</a></li><li><a href="http://www.alloyteam.com/" target="_blank" rel="noopener">腾讯全端 AlloyTeam 团队</a></li><li><a href="http://djt.qq.com/" target="_blank" rel="noopener">腾讯大讲堂</a></li><li><a href="http://blog.qiji.tech/" target="_blank" rel="noopener">奇迹空间技术学习小组</a></li><li><a href="https://corner.squareup.com/" target="_blank" rel="noopener">Square</a></li><li><a href="https://code.facebook.com/" target="_blank" rel="noopener">Facebook</a></li><li><a href="http://gslab.qq.com/" target="_blank" rel="noopener">腾讯游戏安全实验室</a></li></ul><h3 id="技术社区"><a href="#技术社区" class="headerlink" title="技术社区"></a>技术社区</h3><ul><li><a href="http://www.csdn.net/" target="_blank" rel="noopener">CSDN</a></li><li><a href="http://www.cnblogs.com/" target="_blank" rel="noopener">博客园</a></li><li><a href="http://www.iteye.com/" target="_blank" rel="noopener">ITEYE</a></li><li><a href="http://www.51cto.com/" target="_blank" rel="noopener">51CTO</a></li><li><a href="http://www.oschina.net/" target="_blank" rel="noopener">开源中国</a></li><li><a href="http://www.linuxidc.com/" target="_blank" rel="noopener">Linux公社</a></li><li><a href="http://www.eoeandroid.com/" target="_blank" rel="noopener">EOE</a></li><li><a href="http://www.cocoachina.com/" target="_blank" rel="noopener">CocoaChina</a></li><li><a href="http://www.open-open.com/" target="_blank" rel="noopener">深度开源</a></li><li><a href="http://blog.jobbole.com/" target="_blank" rel="noopener">伯乐在线</a></li><li><a href="http://www.importnew.com/" target="_blank" rel="noopener">ImportNew</a></li><li><a href="http://gold.xitu.io/" target="_blank" rel="noopener">稀土掘金</a></li><li><a href="http://www.ibm.com/developerworks/cn/" target="_blank" rel="noopener">IMB developerWorks</a></li><li><a href="https://segmentfault.com/" target="_blank" rel="noopener">segmentfault</a></li><li><a href="http://www.infoq.com/cn/" target="_blank" rel="noopener">InfoQ</a></li><li><a href="http://blog.chinaunix.net/" target="_blank" rel="noopener">ChinaUnix</a></li><li><a href="http://blog.itpub.net/" target="_blank" rel="noopener">ITPUB</a></li></ul><h2 id="第三部分-nbsp-nbsp-nbsp-nbsp-技术书籍"><a href="#第三部分-nbsp-nbsp-nbsp-nbsp-技术书籍" class="headerlink" title="第三部分&nbsp;&nbsp;&nbsp;&nbsp;技术书籍"></a>第三部分&nbsp;&nbsp;&nbsp;&nbsp;技术书籍</h2><h3 id="计算机基础"><a href="#计算机基础" class="headerlink" title="计算机基础"></a>计算机基础</h3><ul><li><p><a href="https://book.douban.com/subject/1142213/" target="_blank" rel="noopener">《计算机科学导论》</a><br>本书是大学计算机相关专业的基础课教材，涉及到计算机科学的各个方面。本书着重讲解基本概念而不是数学模型和技术细节，通过大量的图表和演示范例讲解计算机科学的基础知识。</p></li><li><p><a href="https://book.douban.com/subject/5333562/" target="_blank" rel="noopener">《深入理解计算机系统》</a><br>本书从程序员的视角详细阐述计算机系统的本质概念，并展示这些概念如何实实在在地影响应用程序的正确性、性能和实用性。</p></li></ul><h3 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h3><ul><li><p><a href="https://book.douban.com/subject/3852290/" target="_blank" rel="noopener">《现代操作系统》</a><br>本书是操作系统领域的经典之作，书中集中讨论了操作系统的基本原理，包括进程、线程、存储管理、文件系统、输入/输出、死锁等，同时还包含了有关计算机安全、多媒体操作系统、掌上计算机操作系统、微内核、多核处理机上的虚拟机以及操作系统设计等方面的内容。</p></li><li><p><a href="https://book.douban.com/subject/5064311/" target="_blank" rel="noopener">《操作系统：精髓与设计原理》</a><br>本书不仅全面地讲述了操作系统的基本概念、原理和方法，还清楚地展现了当代操作系统的本质和特点。作者针对近几年操作系统领域的最新变化，对操作系统的设计原理进行深入的阐述，同时将其对操作系统整个领域全面而深入的理解呈现给读者。</p></li></ul><h3 id="体系结构"><a href="#体系结构" class="headerlink" title="体系结构"></a>体系结构</h3><ul><li><p><a href="https://book.douban.com/subject/20452387/" target="_blank" rel="noopener">《计算机体系结构：量化研究方法》</a><br>本书是最权威的计算机体系结构著作，是久负盛名的经典作品。书中系统地介绍了计算机系统的设计基础、指令集系统结构、流水线和指令集并行技术、层次化存储系统与存储设备、互连网络以及多处理器系统等重要内容。</p></li><li><p><a href="https://book.douban.com/subject/2110638/" target="_blank" rel="noopener">《计算机组成与设计：硬件/软件接口》</a><br>本书是计算机组成的经典教材。全书着眼于当前计算机设计中最基本的概念，展示了软硬件间的关系，并全面介绍当代计算机系统发展的主流技术和最新成就。</p></li><li><p><a href="https://book.douban.com/subject/6398113/" target="_blank" rel="noopener">《计算机组成与体系结构：性能设计》</a><br>本书是介绍当代计算机体系主流技术和最新技术的优秀教材，以Intel x86和ARM两个处理器系列为例，深入讨论了计算机组成与体系结构的基本原理和概念，并将它们运用到当代计算机系统设计的问题中。</p></li><li><p><a href="https://book.douban.com/subject/1881545/" target="_blank" rel="noopener">《计算机组成与体系结构》</a><br>本书系统介绍计算机组成与体系结构，主要内容包括：数字逻辑和数字系统、机器层次的数据表示方法、汇编层次的机器组织和结构、存储器的组成和结构、接口和通信、功能组织、多处理器和可供选择的其他结构、性能增强、网络结构和分布式计算机系统等。</p></li><li><p><a href="https://book.douban.com/subject/1737686/" target="_blank" rel="noopener">《计算机组织与体系结构》</a><br>本书是介绍当代计算机体系主流技术的最新技术的优秀教材。作者以Intel Pentium 4和IBM/Motorola PowerPC作为考察实例，将当代计算机系统性能问题和计算机组织与体系结构的基本概念及原理紧密联系起来。</p></li></ul><h3 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h3><ul><li><p><a href="https://book.douban.com/subject/10510747/" target="_blank" rel="noopener">《计算机网络》</a><br>本书是国内外使用最广泛、最权威的计算机网络经典教材。全书按照网络协议模型自下而上（物理层、数据链路层、介质访问控制层、网络层、传输层和应用层）有系统地介绍了计算机网络的基本原理，并结合Internet给出了大量的协议实例。在讲述网络各层次内容的同时，还与时俱进地引入了最新的网络技术，包括无线网络、3G蜂窝网络、RFID与传感器网络、内容分发与P2P网络、流媒体传输与IP语音，以及延迟容忍网络等。</p></li><li><p><a href="https://book.douban.com/subject/26176870/" target="_blank" rel="noopener">《计算机网络：自顶向下方法》</a><br>本书首创采用自顶向下的方法讲解计算机网络的原理和协议，出版以来已被几百所大学和学院选用，是业界最经典的计算机网络教材之一。</p></li><li><p><a href="https://book.douban.com/subject/20560942/" target="_blank" rel="noopener">《深入理解计算机网络》</a><br>本书结合最新计算机网络技术，全面、系统、深入地阐述了计算机网络的体系结构、工作原理，以及各种通信协议实现原理，能满足读者系统和深入地学习和研究计算机网络技术的需求。</p></li><li><p><a href="https://book.douban.com/subject/1088054/" target="_blank" rel="noopener">《TCP/IP详解 卷1：协议》</a><br>《TCP/IP详解·卷1：协议》是一本完整而详细的TCP/IP协议指南，描述了属于每一层的各个协议以及它们如何在不同操作系统中运行。</p></li><li><p><a href="https://book.douban.com/subject/1087767/" target="_blank" rel="noopener">《TCP/IP详解 卷2：实现》</a><br>《TCP/IP详解·卷2：实现》完整而详细地介绍了TCP/IP协议是如何实现的。</p></li><li><p><a href="https://book.douban.com/subject/1058634/" target="_blank" rel="noopener">《TCP/IP详解 卷3：TCP事务协议、HTTP、NNTP和UNIX域协议》</a><br>《TCP/IP详解·卷3：TCP事务协议、HTTP、NNTP和UNIX域协议》是“TCP/IP详解系列”的延续。主要内容包括：TCP事务协议，即T/TCP，这是对TCP的扩展，使客户-服务器事务更快、更高效和更可靠。</p></li><li><p><a href="https://book.douban.com/subject/5386194/" target="_blank" rel="noopener">《TCP/IP协议族》</a><br>《世界著名计算机教材精选·TCP/IP协议族(第4版)》是介绍TCP/IP协议族的经典图书的最新版本。</p></li><li><p><a href="https://book.douban.com/subject/10746113/" target="_blank" rel="noopener">《HTTP权威指南》</a><br>本书详细解释了HTTP协议，包括HTTP是如何工作的，如何用HTTP来开发基于Web的应用程序，核心的因特网协议如何与架构构建块交互，如何正确实现因特网客户和服务器等。</p></li></ul><h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><ul><li><p><a href="https://book.douban.com/subject/10548379/" target="_blank" rel="noopener">《数据库系统概念》</a><br>本书是数据库领域的殿堂级作品，是夯实数据库理论基础，增强数据库技术内功的必备之选，对深入理解数据库，深入研究数据库，深入操作数据库都具有极强的指导作用。</p></li><li><p><a href="https://book.douban.com/subject/4838430/" target="_blank" rel="noopener">《数据库系统实现》</a><br>本书是关于数据库系统实现方面内容最为全面的著作之一，是美国斯坦福大学计算机科学专业数据库系列课程第二门课程的指定教材。</p></li><li><p><a href="https://book.douban.com/subject/23008813/" target="_blank" rel="noopener">《高性能MySQL》</a><br>本书是MySQL 领域的经典之作，拥有广泛的影响力。</p></li><li><p><a href="https://book.douban.com/subject/1909003/" target="_blank" rel="noopener">《MySQL 5 权威指南》</a><br>本书是MySQL数据库管理员和开发人员的必备参考书。</p></li><li><p><a href="https://book.douban.com/subject/25798102/" target="_blank" rel="noopener">《MongoDB权威指南》</a><br>本书是一本广受好评的MongoDB权威著作。书中介绍了面向文档的存储方式及利用MongoDB的无模式数据模型处理文档、集合和多个数据库，讲述了如何执行基本的写操作以及各种复杂的条件查询，还介绍了索引、聚合工具以及其他高级查询技术，另外对监控、安全性和身份验证、备份和修复、水平扩展MongoDB数据库等内容也有所涉及。</p></li><li><p><a href="https://book.douban.com/subject/25900156/" target="_blank" rel="noopener">《Redis设计与实现》</a><br>本书系统而全面地描述了Redis内部运行机制，是NoSQL数据库开发人员案头必备。</p></li><li><p><a href="https://book.douban.com/subject/25662138/" target="_blank" rel="noopener">《NoSQL精粹》</a><br>《NoSQL精粹》为考虑是否可以使用和如何使用NoSQL数据库的企业提供了可靠的决策依据。书中全方位比较了关系型数据库与NoSQL数据库的异同；分别以Riak、MongoDB、Cassandra和Neo4J为代表，详细讲解了键值数据库、文档数据库、列族数据库和图数据库这4大类NoSQL数据库的优劣势、用法和适用场合；深入探讨了实现NoSQL数据库系统的各种细节，以及与关系型数据库的混用。</p></li></ul><h3 id="编译原理"><a href="#编译原理" class="headerlink" title="编译原理"></a>编译原理</h3><ul><li><a href="https://book.douban.com/subject/3296317/" target="_blank" rel="noopener">《编译原理》</a><br>本书是编译领域无可替代的经典著作，被广大计算机专业人士誉为“龙书”。本书全面、深入地探讨了编译器设计方面的重要主题，包括词法分析、语法分析、语法制导定义和语法制导翻译、运行时刻环境、目标代码生成、代码优化技术、并行性检测以及过程间分析技术，并在相关章节中给出大量的实例。</li></ul><h3 id="数据结构-amp-算法"><a href="#数据结构-amp-算法" class="headerlink" title="数据结构&amp;算法"></a>数据结构&amp;算法</h3><ul><li><p><a href="https://book.douban.com/subject/1139426/" target="_blank" rel="noopener">《数据结构与算法分析：C语言描述》</a><br>本书是《Data Structures and Algorithm Analysis in C》一书第2版的简体中译本，原书曾被评为20世纪顶尖的30部计算机著作之一。在本书中，作者更加精炼并强化了他对算法和数据结构方面创新的处理方法。通过C程序的实现，着重阐述了抽象数据类型的概念，并对算法的效率、性能和运行时间进行了分析。</p></li><li><p><a href="https://book.douban.com/subject/3351237/" target="_blank" rel="noopener">《数据结构与算法分析：Java语言描述》</a><br>本书是国外数据结构与算法分析方面的经典教材，使用卓越的Java编程语言作为实现工具讨论了数据结构（组织大量数据的方法）和算法分析（对算法运行时间的估计）。 随着计算机速度的不断增加和功能的日益强大，人们对有效编程和算法分析的要求也不断增长。本书把算法分析与最有效率的Java程序的开发有机地结合起来，深入分析每种算法，内容全面、缜密严格，并细致讲解精心构造程序的方法。</p></li><li><p><a href="https://book.douban.com/subject/1886174/" target="_blank" rel="noopener">《数据结构（C语言版）》</a><br>《数据结构》(C语言版)针对采用ANSI C实现数据结构进行了全面的描述和深入的讨论。书中详细讨论了栈、队列、链表以及查找结构、高级树结构等功能，对裴波那契堆、伸展树、红黑树、2-3树、2-3-4树、二项堆、最小-最大堆、双端堆等新的数据结构进行了有效分析。</p></li><li><p><a href="https://book.douban.com/subject/2024655/" target="_blank" rel="noopener">《数据结构（C语言版） 严蔚敏》</a><br>本书是为“数据结构”课程编写的教材，也可作为学习数据结构及其算法的C程序设计的参数教材。<br>本书的前半部分从抽象数据类型的角度讨论各种基本类型的数据结构及其应用；后半部分主要讨论查找和排序的各种实现方法及其综合分析比较。</p></li><li><p><a href="https://book.douban.com/subject/20432061/" target="_blank" rel="noopener">《算法导论》</a><br>本书将严谨性和全面性融为一体，深入讨论各类算法，并着力使这些算法的设计和分析能为各个层次的读者接受。</p></li><li><p><a href="https://book.douban.com/subject/19952400/" target="_blank" rel="noopener">《算法》</a><br>本书是算法领域经典的参考书，涵盖所有程序员必须掌握的50种算法，全面介绍了关于算法和数据结构的必备知识，并特别针对排序、搜索、图处理和字符串处理进行了论述。</p></li></ul><h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><ul><li><p><a href="https://book.douban.com/subject/1052241/" target="_blank" rel="noopener">《设计模式：可复用面向对象软件的基础》</a><br>本书是引导读者走出软件设计迷宫的指路明灯，凝聚了软件开发界几十年设计经验的结晶。四位顶尖的面向对象领域专家精心选取了具有价值的设计实践，加以分类整理和命名，并用简洁而易于重用的形式表达出来。本书已经成为面向对象技术人员的圣经和词典，书中定义的23个模式逐渐成为开发界技术交流所必备的基础知识和语汇。</p></li><li><p><a href="https://book.douban.com/subject/2243615/" target="_blank" rel="noopener">《Head First 设计模式》</a><br>《O’Reilly：Head First设计模式（中文版）》趋近完美，因为它在提供专业知识的同时，仍然具有相当高的可读性。</p></li><li><p><a href="https://book.douban.com/subject/2334288/" target="_blank" rel="noopener">《大话设计模式》</a><br>本书是准备攀登面向对象编程高峰朋友们的引路人和提携者，是学习、体会和领悟了众多大师智慧结晶后的图书作品，是你深入理解和感受GoF的《设计模式》及其它大师作品的必备书籍。本书通篇都是以情景对话的形式，用多个小故事或编程示例来组织讲解GoF总结的23个设计模式。</p></li></ul><h3 id="软件工程"><a href="#软件工程" class="headerlink" title="软件工程"></a>软件工程</h3><ul><li><p><a href="https://book.douban.com/subject/6047742/" target="_blank" rel="noopener">《软件工程：实践者的研究方法》</a><br>《软件工程:实践者的研究方法(原书第7版)》自1982年发行第1版以来，一直受到软件工程界的高度重视，成为高等院校计算机相关专业软件工程课程的重要教学参考书。近30年来，它的各个后继版本一直都是软件专业人土熟悉的读物，在国际软件工程一界享有无可置疑的权威地位。它在全面而系统地介绍软件工程的有关概念、原则、方法和工具方面获得了广大读者的好评。</p></li><li><p><a href="https://book.douban.com/subject/6109617/" target="_blank" rel="noopener">《软件工程》</a><br>本书是系统介绍软件工程理论的经典教材，自1982年初版以来，随着软件工程学科的发展不断更新版本，影响了一代又一代软件工程人才，对学科的发展建设也产生了积极影响。全书分四部分完整讨论了软件工程的各级段内容，是软件工程和系统工程专业本科和研究生的优秀教材，也是软件工程师必备的参考书籍。</p></li><li><p><a href="https://book.douban.com/subject/3892590/" target="_blank" rel="noopener">《面向对象分析与设计》</a><br>本书是一本注重实效的书，面向架构师和软件开发者等软件工程实践者的实际需要，通过大量例子说明了基本概念，解释了方法，并展示了在不同领域的成功应用。</p></li><li><p><a href="https://book.douban.com/subject/3530721/" target="_blank" rel="noopener">《深入浅出面向对象分析与设计》</a><br>本书将告诉你如何分析、设计以及撰写真正面向对象的软件；容易重用、好维护、可扩展的软件；不再使你心碎的软件；让你增添新功能而不会破坏旧机制的软件。</p></li></ul><h3 id="数字图像处理"><a href="#数字图像处理" class="headerlink" title="数字图像处理"></a>数字图像处理</h3><ul><li><p><a href="https://book.douban.com/subject/6434627/" target="_blank" rel="noopener">《数字图像处理》</a><br>本书是数字图像处理领域的杰作。</p></li><li><p><a href="https://book.douban.com/subject/5921462/" target="_blank" rel="noopener">《图像处理、分析与机器视觉》</a><br>本书是为计算机专业图像处理、图像分析和机器视觉课程编写的教材。书中针对图像处理、图像分析和机器视觉领域的有关原理与技术展开了广泛而深入的讨论，包括图像预处理、图像分割、形状表示与描述、物体识别与图像理解、三维视觉、数学形态学图像处理技术、离散图像变换、图像压缩、纹理描述、运动分析等。</p></li><li><p><a href="https://book.douban.com/subject/26344083/" target="_blank" rel="noopener">《数字图像处理：MATLAB》</a><br>本书是图像处理基础理论论述同以MATLAB为主要工具的软件实践方法相对照的第一本书，书中集成了冈萨雷斯和伍兹所著的《数字图像处理》一书中重要的原文材料和MathWorks公司的图像处理工具箱。本书的特色在于重点强调怎样通过开发新代码来加强这些软件工具。本书在介绍MATLAB编程基础知识之后，讲述了图像处理的主干内容，包括灰度变换、线性和非线性空间滤波、频率域滤波、图像复原与重建、彩色图像处理、图像压缩、图像分割、区域和边界表示与描述。</p></li></ul><h3 id="计算机图形学"><a href="#计算机图形学" class="headerlink" title="计算机图形学"></a>计算机图形学</h3><ul><li><p><a href="https://book.douban.com/subject/26403265/" target="_blank" rel="noopener">《计算机图形学》</a><br>本书是一本经典著作，全面系统地讲解了计算机图形学的基本概念和相关技术。</p></li><li><p><a href="https://book.douban.com/subject/3129340/" target="_blank" rel="noopener">《计算机图形学》</a><br>本书与大多数传统的计算机图形学教材不同，它仅简要介绍交互式计算机图形学方面的基本知识，主要侧重于介绍计算机图形学在数学及其他科学领域的应用，解决实际问题。</p></li><li><p><a href="https://book.douban.com/subject/3561816/" target="_blank" rel="noopener">《计算机图形学》</a><br>本书通过最能代表技术发展状况的示例综合介绍了计算机图形学方面的原则和技巧，书中对每个概念都进行了详细介绍，阐述了其背后的数学原理，并给出了用OpenGL实现的代码以及实现结果展示。</p></li><li><p><a href="https://book.douban.com/subject/26220248/" target="_blank" rel="noopener">《OpenGL编程指南》</a><br>本书清晰地讲解了OpenGL的相关功能与技术，包括几何对象顶点的传递、细分，几何着色器中的几何变换，通过片元着色器来操作像素和纹理贴图，以及基于帧缓存对象和计算着色器的先进数据操作技术。</p></li><li><p><a href="https://book.douban.com/subject/10774590/" target="_blank" rel="noopener">《OpenGL超级宝典》</a><br>本书是OpenGL及3D图形编程最好的入门指南，涵盖了使用最新版本的OpenGL进行编程所需要的主要知识。</p></li></ul><h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><ul><li><p><a href="https://book.douban.com/subject/2287506/" target="_blank" rel="noopener">《深入理解LINUX内核》</a><br>本书指导你对内核中使用的最重要的数据结构、算法和程序设计诀窍进行一次遍历。通过对表面特性的探究，作者给那些想知道自己机器工作原理的人提供了颇有价值的见解。</p></li><li><p><a href="https://book.douban.com/subject/4843567/" target="_blank" rel="noopener">《深入Linux内核架构》</a><br>本书讨论了Linux内核的概念、结构和实现。</p></li><li><p><a href="https://book.douban.com/subject/4831448/" target="_blank" rel="noopener">《Linux程序设计》</a><br>本书是Linux程序设计领域的经典名著，以简单易懂、内容全面和示例丰富而受到广泛好评。</p></li><li><p><a href="https://book.douban.com/subject/6097773/" target="_blank" rel="noopener">《Linux内核设计与实现》</a><br>本书详细描述了Linux内核的主要子系统和特点，包括Linux内核的设计、实现和接口。</p></li><li><p><a href="https://book.douban.com/subject/7564417/" target="_blank" rel="noopener">《Linux/Unix设计思想》</a><br>本书将Linux的开发方式与Unix的原理有效地结合起来，总结出Linux与Unix软件开发中的设计原则。</p></li><li><p><a href="https://book.douban.com/subject/4889838/" target="_blank" rel="noopener">《鸟哥的Linux私房菜：基础学习篇(第3版)》</a><br>本书是最具知名度的Linux入门书《鸟哥的Linux私房菜基础学习篇》的最新版，全面而详细地介绍了Linux操作系统。本书内容丰富全面，基本概念的讲解非常细致，深入浅出。各种功能和命令的介绍，都配以大量的实例操作和详尽的解析。本书是初学者学习Linux不可多得的一本入门好书。</p></li><li><p><a href="https://book.douban.com/subject/10794788/" target="_blank" rel="noopener">《鸟哥的Linux私房菜：服务器架设篇(第3版)》</a><br>您已有Linux基础，想要进一步学习服务器架设？还想了解如何维护与管理您的服务器？本书是您绝佳的选择。</p></li></ul><h3 id="Android"><a href="#Android" class="headerlink" title="Android"></a>Android</h3><ul><li><p><a href="https://book.douban.com/subject/25741542/" target="_blank" rel="noopener">《Android开发权威指南》</a><br>本书是一本全面介绍Android应用开发的专著。</p></li><li><p><a href="https://book.douban.com/subject/6811238/" target="_blank" rel="noopener">《Android内核剖析》</a><br>本书详细分析了Android内核的内部机制，包括窗口管理系统、Activity管理系统、输入法框架、编译系统等，为Android内核定制及高级应用程序开发提供技术参考。  </p></li><li><p><a href="https://book.douban.com/subject/26599538/" target="_blank" rel="noopener">《Android开发艺术探索》</a><br>本书是一本Android进阶类书籍，采用理论、源码和实践相结合的方式来阐述高水准的Android应用开发要点。</p></li><li><p><a href="https://book.douban.com/subject/26644935/" target="_blank" rel="noopener">《Android源码设计模式解析与实战》</a><br>本书从Android源码的角度由浅入深地剖析设计模式的运用，让工程师们把设计与模式重视起来，提升自己的设计能力与代码质量。</p></li><li><p><a href="https://book.douban.com/subject/26377840/" target="_blank" rel="noopener">《深入解析Android 5.0系统》</a><br>本书详细剖析了最新Android 5.0 系统主要框架的原理和具体实现。</p></li><li><p><a href="https://book.douban.com/subject/25921329/" target="_blank" rel="noopener">《深入理解Android内核设计思想》</a><br>本书从操作系统的基础知识入手，全面剖析进程/线程、内存管理、Binder机制、GUI显示系统、多媒体管理、输入系统等核心技术在Android中的实现原理。</p></li><li><p><a href="https://book.douban.com/subject/20556210/" target="_blank" rel="noopener">《Android软件安全与逆向分析》</a><br>本书由浅入深、循序渐进地讲解了Android 系统的软件安全、逆向分析与加密解密技术。包括Android软件逆向分析和系统安全方面的必备知识及概念、如何静态分析Android 软件、如何动态调试Android 软件、Android 软件的破解与反破解技术的探讨，以及对典型Android 病毒的全面剖析。</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Android</tag>
      
      <tag>blog</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>adb 模拟按键事件</title>
    <link href="/2016/05/25/adb-%E6%A8%A1%E6%8B%9F%E6%8C%89%E9%94%AE%E4%BA%8B%E4%BB%B6/"/>
    <url>/2016/05/25/adb-%E6%A8%A1%E6%8B%9F%E6%8C%89%E9%94%AE%E4%BA%8B%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<p>adb 模拟按键事件</p><a id="more"></a><p>例子：</p><p>//这条命令相当于按了设备的Backkey键<br>adb shell input keyevent 4   </p><p> //可以解锁屏幕</p><p>adb shell input keyevent  82 </p><p>//在屏幕上做划屏操作，前四个数为坐标点，后面是滑动的时间（单位毫秒）</p><p>adb shell input swipe 50 250 250 250 500 </p><p>//在屏幕上点击坐标点x=50  y=250的位置。</p><p>adb shell input tap 50 250 </p><p>//输入字符abc</p><p>adb shell input text abc</p><p>每个数字与keycode对应表如下：<br>0 –&gt;  “KEYCODE_UNKNOWN”<br>1 –&gt;  “KEYCODE_MENU”<br>2 –&gt;  “KEYCODE_SOFT_RIGHT”<br>3 –&gt;  “KEYCODE_HOME”<br>4 –&gt;  “KEYCODE_BACK”<br>5 –&gt;  “KEYCODE_CALL”<br>6 –&gt;  “KEYCODE_ENDCALL”<br>7 –&gt;  “KEYCODE_0”<br>8 –&gt;  “KEYCODE_1”<br>9 –&gt;  “KEYCODE_2”<br>10 –&gt;  “KEYCODE_3”<br>11 –&gt;  “KEYCODE_4”<br>12 –&gt;  “KEYCODE_5”<br>13 –&gt;  “KEYCODE_6”<br>14 –&gt;  “KEYCODE_7”<br>15 –&gt;  “KEYCODE_8”<br>16 –&gt;  “KEYCODE_9”<br>17 –&gt;  “KEYCODE_STAR”<br>18 –&gt;  “KEYCODE_POUND”<br>19 –&gt;  “KEYCODE_DPAD_UP”<br>20 –&gt;  “KEYCODE_DPAD_DOWN”<br>21 –&gt;  “KEYCODE_DPAD_LEFT”<br>22 –&gt;  “KEYCODE_DPAD_RIGHT”<br>23 –&gt;  “KEYCODE_DPAD_CENTER”<br>24 –&gt;  “KEYCODE_VOLUME_UP”<br>25 –&gt;  “KEYCODE_VOLUME_DOWN”<br>26 –&gt;  “KEYCODE_POWER”<br>27 –&gt;  “KEYCODE_CAMERA”<br>28 –&gt;  “KEYCODE_CLEAR”<br>29 –&gt;  “KEYCODE_A”<br>30 –&gt;  “KEYCODE_B”<br>31 –&gt;  “KEYCODE_C”<br>32 –&gt;  “KEYCODE_D”<br>33 –&gt;  “KEYCODE_E”<br>34 –&gt;  “KEYCODE_F”<br>35 –&gt;  “KEYCODE_G”<br>36 –&gt;  “KEYCODE_H”<br>37 –&gt;  “KEYCODE_I”<br>38 –&gt;  “KEYCODE_J”<br>39 –&gt;  “KEYCODE_K”<br>40 –&gt;  “KEYCODE_L”<br>41 –&gt;  “KEYCODE_M”<br>42 –&gt;  “KEYCODE_N”<br>43 –&gt;  “KEYCODE_O”<br>44 –&gt;  “KEYCODE_P”<br>45 –&gt;  “KEYCODE_Q”<br>46 –&gt;  “KEYCODE_R”<br>47 –&gt;  “KEYCODE_S”<br>48 –&gt;  “KEYCODE_T”<br>49 –&gt;  “KEYCODE_U”<br>50 –&gt;  “KEYCODE_V”<br>51 –&gt;  “KEYCODE_W”<br>52 –&gt;  “KEYCODE_X”<br>53 –&gt;  “KEYCODE_Y”<br>54 –&gt;  “KEYCODE_Z”<br>55 –&gt;  “KEYCODE_COMMA”<br>56 –&gt;  “KEYCODE_PERIOD”<br>57 –&gt;  “KEYCODE_ALT_LEFT”<br>58 –&gt;  “KEYCODE_ALT_RIGHT”<br>59 –&gt;  “KEYCODE_SHIFT_LEFT”<br>60 –&gt;  “KEYCODE_SHIFT_RIGHT”<br>61 –&gt;  “KEYCODE_TAB”<br>62 –&gt;  “KEYCODE_SPACE”<br>63 –&gt;  “KEYCODE_SYM”<br>64 –&gt;  “KEYCODE_EXPLORER”<br>65 –&gt;  “KEYCODE_ENVELOPE”<br>66 –&gt;  “KEYCODE_ENTER”<br>67 –&gt;  “KEYCODE_DEL”<br>68 –&gt;  “KEYCODE_GRAVE”<br>69 –&gt;  “KEYCODE_MINUS”<br>70 –&gt;  “KEYCODE_EQUALS”<br>71 –&gt;  “KEYCODE_LEFT_BRACKET”<br>72 –&gt;  “KEYCODE_RIGHT_BRACKET”<br>73 –&gt;  “KEYCODE_BACKSLASH”<br>74 –&gt;  “KEYCODE_SEMICOLON”<br>75 –&gt;  “KEYCODE_APOSTROPHE”<br>76 –&gt;  “KEYCODE_SLASH”<br>77 –&gt;  “KEYCODE_AT”<br>78 –&gt;  “KEYCODE_NUM”<br>79 –&gt;  “KEYCODE_HEADSETHOOK”<br>80 –&gt;  “KEYCODE_FOCUS”<br>81 –&gt;  “KEYCODE_PLUS”<br>82 –&gt;  “KEYCODE_MENU”<br>83 –&gt;  “KEYCODE_NOTIFICATION”<br>84 –&gt;  “KEYCODE_SEARCH”<br>85 –&gt;  “TAG_LAST_KEYCODE”</p><p>KEYCODE列表<br>电话键</p><p>KEYCODE_CALL    拨号键    5<br>KEYCODE_ENDCALL    挂机键    6<br>KEYCODE_HOME    按键Home    3<br>KEYCODE_MENU    菜单键    82<br>KEYCODE_BACK    返回键    4<br>KEYCODE_SEARCH    搜索键    84<br>KEYCODE_CAMERA    拍照键    27<br>KEYCODE_FOCUS    拍照对焦键    80<br>KEYCODE_POWER    电源键    26<br>KEYCODE_NOTIFICATION    通知键    83<br>KEYCODE_MUTE    话筒静音键    91<br>KEYCODE_VOLUME_MUTE    扬声器静音键    164<br>KEYCODE_VOLUME_UP    音量增加键    24<br>KEYCODE_VOLUME_DOWN    音量减小键    25</p><p>控制键</p><p>KEYCODE_ENTER    回车键    66<br>KEYCODE_ESCAPE    ESC键    111<br>KEYCODE_DPAD_CENTER    导航键 确定键    23<br>KEYCODE_DPAD_UP    导航键 向上    19<br>KEYCODE_DPAD_DOWN    导航键 向下    20<br>KEYCODE_DPAD_LEFT    导航键 向左    21<br>KEYCODE_DPAD_RIGHT    导航键 向右    22<br>KEYCODE_MOVE_HOME    光标移动到开始键    122<br>KEYCODE_MOVE_END    光标移动到末尾键    123<br>KEYCODE_PAGE_UP    向上翻页键    92<br>KEYCODE_PAGE_DOWN    向下翻页键    93<br>KEYCODE_DEL    退格键    67<br>KEYCODE_FORWARD_DEL    删除键    112<br>KEYCODE_INSERT    插入键    124<br>KEYCODE_TAB    Tab键    61<br>KEYCODE_NUM_LOCK    小键盘锁    143<br>KEYCODE_CAPS_LOCK    大写锁定键    115<br>KEYCODE_BREAK    Break/Pause键    121<br>KEYCODE_SCROLL_LOCK    滚动锁定键    116<br>KEYCODE_ZOOM_IN    放大键    168<br>KEYCODE_ZOOM_OUT    缩小键    169</p><p>组合键</p><p>KEYCODE_ALT_LEFT    Alt+Left<br>KEYCODE_ALT_RIGHT    Alt+Right<br>KEYCODE_CTRL_LEFT    Control+Left<br>KEYCODE_CTRL_RIGHT    Control+Right<br>KEYCODE_SHIFT_LEFT    Shift+Left<br>KEYCODE_SHIFT_RIGHT    Shift+Right</p><p>基本</p><p>KEYCODE_0    按键’0’    7<br>KEYCODE_1    按键’1’    8<br>KEYCODE_2    按键’2’    9<br>KEYCODE_3    按键’3’    10<br>KEYCODE_4    按键’4’    11<br>KEYCODE_5    按键’5’    12<br>KEYCODE_6    按键’6’    13<br>KEYCODE_7    按键’7’    14<br>KEYCODE_8    按键’8’    15<br>KEYCODE_9    按键’9’    16<br>KEYCODE_A    按键’A’    29<br>KEYCODE_B    按键’B’    30<br>KEYCODE_C    按键’C’    31<br>KEYCODE_D    按键’D’    32<br>KEYCODE_E    按键’E’    33<br>KEYCODE_F    按键’F’    34<br>KEYCODE_G    按键’G’    35<br>KEYCODE_H    按键’H’    36<br>KEYCODE_I    按键’I’    37<br>KEYCODE_J    按键’J’    38<br>KEYCODE_K    按键’K’    39<br>KEYCODE_L    按键’L’    40<br>KEYCODE_M    按键’M’    41<br>KEYCODE_N    按键’N’    42<br>KEYCODE_O    按键’O’    43<br>KEYCODE_P    按键’P’    44<br>KEYCODE_Q    按键’Q’    45<br>KEYCODE_R    按键’R’    46<br>KEYCODE_S    按键’S’    47<br>KEYCODE_T    按键’T’    48<br>KEYCODE_U    按键’U’    49<br>KEYCODE_V    按键’V’    50<br>KEYCODE_W    按键’W’    51<br>KEYCODE_X    按键’X’    52<br>KEYCODE_Y    按键’Y’    53<br>KEYCODE_Z    按键’Z’    54</p><p>符号</p><p>KEYCODE_PLUS    按键’+’<br>KEYCODE_MINUS    按键’-‘<br>KEYCODE_STAR    按键’*’<br>KEYCODE_SLASH    按键’/‘<br>KEYCODE_EQUALS    按键’=’<br>KEYCODE_AT    按键‘@’<br>KEYCODE_POUND    按键’#’<br>KEYCODE_APOSTROPHE    按键’’’ (单引号)<br>KEYCODE_BACKSLASH    按键’&#39;<br>KEYCODE_COMMA    按键’,’<br>KEYCODE_PERIOD    按键’.’<br>KEYCODE_LEFT_BRACKET    按键’[‘<br>KEYCODE_RIGHT_BRACKET    按键’]’<br>KEYCODE_SEMICOLON    按键’;’<br>KEYCODE_GRAVE    按键’`’<br>KEYCODE_SPACE    空格键</p><p>小键盘</p><p>KEYCODE_NUMPAD_0    小键盘按键’0’<br>KEYCODE_NUMPAD_1    小键盘按键’1’<br>KEYCODE_NUMPAD_2    小键盘按键’2’<br>KEYCODE_NUMPAD_3    小键盘按键’3’<br>KEYCODE_NUMPAD_4    小键盘按键’4’<br>KEYCODE_NUMPAD_5    小键盘按键’5’<br>KEYCODE_NUMPAD_6    小键盘按键’6’<br>KEYCODE_NUMPAD_7    小键盘按键’7’<br>KEYCODE_NUMPAD_8    小键盘按键’8’<br>KEYCODE_NUMPAD_9    小键盘按键’9’<br>KEYCODE_NUMPAD_ADD    小键盘按键’+’<br>KEYCODE_NUMPAD_SUBTRACT    小键盘按键’-‘<br>KEYCODE_NUMPAD_MULTIPLY    小键盘按键’*’<br>KEYCODE_NUMPAD_DIVIDE    小键盘按键’/‘<br>KEYCODE_NUMPAD_EQUALS    小键盘按键’=’<br>KEYCODE_NUMPAD_COMMA    小键盘按键’,’<br>KEYCODE_NUMPAD_DOT    小键盘按键’.’<br>KEYCODE_NUMPAD_LEFT_PAREN    小键盘按键’(‘<br>KEYCODE_NUMPAD_RIGHT_PAREN    小键盘按键’)’<br>KEYCODE_NUMPAD_ENTER    小键盘按键回车</p><p>功能键</p><p>KEYCODE_F1    按键F1<br>KEYCODE_F2    按键F2<br>KEYCODE_F3    按键F3<br>KEYCODE_F4    按键F4<br>KEYCODE_F5    按键F5<br>KEYCODE_F6    按键F6<br>KEYCODE_F7    按键F7<br>KEYCODE_F8    按键F8<br>KEYCODE_F9    按键F9<br>KEYCODE_F10    按键F10<br>KEYCODE_F11    按键F11<br>KEYCODE_F12    按键F12</p><p>多媒体键</p><p>KEYCODE_MEDIA_PLAY    多媒体键 播放<br>KEYCODE_MEDIA_STOP    多媒体键 停止<br>KEYCODE_MEDIA_PAUSE    多媒体键 暂停<br>KEYCODE_MEDIA_PLAY_PAUSE    多媒体键 播放/暂停<br>KEYCODE_MEDIA_FAST_FORWARD    多媒体键 快进<br>KEYCODE_MEDIA_REWIND    多媒体键 快退<br>KEYCODE_MEDIA_NEXT    多媒体键 下一首<br>KEYCODE_MEDIA_PREVIOUS    多媒体键 上一首<br>KEYCODE_MEDIA_CLOSE    多媒体键 关闭<br>KEYCODE_MEDIA_EJECT    多媒体键 弹出<br>KEYCODE_MEDIA_RECORD    多媒体键 录音</p><p>手柄按键</p><p>KEYCODE_BUTTON_1    通用游戏手柄按钮#1<br>KEYCODE_BUTTON_2    通用游戏手柄按钮 #2<br>KEYCODE_BUTTON_3    通用游戏手柄按钮 #3<br>KEYCODE_BUTTON_4    通用游戏手柄按钮 #4<br>KEYCODE_BUTTON_5    通用游戏手柄按钮 #5<br>KEYCODE_BUTTON_6    通用游戏手柄按钮 #6<br>KEYCODE_BUTTON_7    通用游戏手柄按钮 #7<br>KEYCODE_BUTTON_8    通用游戏手柄按钮 #8<br>KEYCODE_BUTTON_9    通用游戏手柄按钮 #9<br>KEYCODE_BUTTON_10    通用游戏手柄按钮 #10<br>KEYCODE_BUTTON_11    通用游戏手柄按钮 #11<br>KEYCODE_BUTTON_12    通用游戏手柄按钮 #12<br>KEYCODE_BUTTON_13    通用游戏手柄按钮 #13<br>KEYCODE_BUTTON_14    通用游戏手柄按钮 #14<br>KEYCODE_BUTTON_15    通用游戏手柄按钮 #15<br>KEYCODE_BUTTON_16    通用游戏手柄按钮 #16<br>KEYCODE_BUTTON_A    游戏手柄按钮 A<br>KEYCODE_BUTTON_B    游戏手柄按钮 B<br>KEYCODE_BUTTON_C    游戏手柄按钮 C<br>KEYCODE_BUTTON_X    游戏手柄按钮 X<br>KEYCODE_BUTTON_Y    游戏手柄按钮 Y<br>KEYCODE_BUTTON_Z    游戏手柄按钮 Z<br>KEYCODE_BUTTON_L1    游戏手柄按钮 L1<br>KEYCODE_BUTTON_L2    游戏手柄按钮 L2<br>KEYCODE_BUTTON_R1    游戏手柄按钮 R1<br>KEYCODE_BUTTON_R2    游戏手柄按钮 R2<br>KEYCODE_BUTTON_MODE    游戏手柄按钮 Mode<br>KEYCODE_BUTTON_SELECT    游戏手柄按钮 Select<br>KEYCODE_BUTTON_START    游戏手柄按钮 Start<br>KEYCODE_BUTTON_THUMBL    Left Thumb Button<br>KEYCODE_BUTTON_THUMBR    Right Thumb Button</p><p>待查</p><p>KEYCODE_NUM</p><p>按键Number modifier</p><p>KEYCODE_INFO</p><p>按键Info</p><p>KEYCODE_APP_SWITCH</p><p>按键App switch</p><p>KEYCODE_BOOKMARK</p><p>按键Bookmark</p><p>KEYCODE_AVR_INPUT</p><p>按键A/V Receiver input</p><p>KEYCODE_AVR_POWER</p><p>按键A/V Receiver power</p><p>KEYCODE_CAPTIONS</p><p>按键Toggle captions</p><p>KEYCODE_CHANNEL_DOWN</p><p>按键Channel down</p><p>KEYCODE_CHANNEL_UP</p><p>按键Channel up</p><p>KEYCODE_CLEAR</p><p>按键Clear</p><p>KEYCODE_DVR</p><p>按键DVR</p><p>KEYCODE_ENVELOPE</p><p>按键Envelope special function</p><p>KEYCODE_EXPLORER</p><p>按键Explorer special function</p><p>KEYCODE_FORWARD</p><p>按键Forward</p><p>KEYCODE_FORWARD_DEL</p><p>按键Forward Delete</p><p>KEYCODE_FUNCTION</p><p>按键Function modifier</p><p>KEYCODE_GUIDE</p><p>按键Guide</p><p>KEYCODE_HEADSETHOOK</p><p>按键Headset Hook</p><p>KEYCODE_META_LEFT</p><p>按键Left Meta modifier</p><p>KEYCODE_META_RIGHT</p><p>按键Right Meta modifier</p><p>KEYCODE_PICTSYMBOLS</p><p>按键Picture Symbols modifier</p><p>KEYCODE_PROG_BLUE</p><p>按键Blue “programmable”</p><p>KEYCODE_PROG_GREEN</p><p>按键Green “programmable”</p><p>KEYCODE_PROG_RED</p><p>按键Red “programmable”</p><p>KEYCODE_PROG_YELLOW</p><p>按键Yellow “programmable”</p><p>KEYCODE_SETTINGS</p><p>按键Settings</p><p>KEYCODE_SOFT_LEFT</p><p>按键Soft Left</p><p>KEYCODE_SOFT_RIGHT</p><p>按键Soft Right</p><p>KEYCODE_STB_INPUT</p><p>按键Set-top-box input</p><p>KEYCODE_STB_POWER</p><p>按键Set-top-box power</p><p>KEYCODE_SWITCH_CHARSET</p><p>按键Switch Charset modifier</p><p>KEYCODE_SYM</p><p>按键Symbol modifier</p><p>KEYCODE_SYSRQ</p><p>按键System Request / Print Screen</p><p>KEYCODE_TV</p><p>按键TV</p><p>KEYCODE_TV_INPUT</p><p>按键TV input</p><p>KEYCODE_TV_POWER</p><p>按键TV power</p><p>KEYCODE_WINDOW</p><p>按键Window</p><p>KEYCODE_UNKNOWN</p><p>未知按键</p>]]></content>
    
    
    
    <tags>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>6月计划</title>
    <link href="/2016/05/20/6%E6%9C%88%E8%AE%A1%E5%88%92/"/>
    <url>/2016/05/20/6%E6%9C%88%E8%AE%A1%E5%88%92/</url>
    
    <content type="html"><![CDATA[<p>just do IT</p><a id="more"></a><ol><li>骑车去趟天安门</li><li>学习swift</li><li>学习Android XML相关</li><li>学习Android IPC</li><li>做一款clock app</li><li>每天一道算法题</li><li>完成广告推广软件</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>计划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>那一年</title>
    <link href="/2016/05/12/%E9%82%A3%E4%B8%80%E5%B9%B4/"/>
    <url>/2016/05/12/%E9%82%A3%E4%B8%80%E5%B9%B4/</url>
    
    <content type="html"><![CDATA[<blockquote><p>好有感觉的一首歌</p></blockquote><a id="more"></a><p>那一年 - 许巍 </p><p>那一年 你正年轻<br>总觉得明天肯定会很美<br>那理想世界 就像一道光芒<br>在你心里闪耀着<br>怎能就让这不停燃烧的心<br>就这样耗尽消失在平庸里<br>你决定上路 就离开这城市<br>离开你深爱多年的姑娘<br>这么多年 你还在不停奔跑<br>眼看着明天依然虚无飘渺<br>在生存面前那纯洁的理想<br>原来是那么脆弱不堪<br>你站在这繁华的街上<br>找不到你该去的方向<br>你站在这繁华的街上<br>感觉到从来没有的慌张<br>你站在这繁华的街上<br>找不到你该去的方向<br>你站在这繁华的街上<br>感觉到从来没有的慌张<br>你曾拥有一些英雄的梦想<br>好像黑夜里面温暖的灯光<br>怎能没有了希望的力量<br>只能够挺身永往直前<br>你走在这繁华的街上<br>在寻找你该去的方向<br>你走在这繁华的街上<br>在寻找你曾拥有的力量</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>新的开始</title>
    <link href="/2016/04/26/%E6%96%B0%E7%9A%84%E5%BC%80%E5%A7%8B/"/>
    <url>/2016/04/26/%E6%96%B0%E7%9A%84%E5%BC%80%E5%A7%8B/</url>
    
    <content type="html"><![CDATA[<blockquote><p>今天是我从学校回来的第二天<a id="more"></a>，从公司回来，洗洗衣服，擦擦地，关了大灯，只留台灯。台灯亮着，心中就是明的。</p></blockquote><h3 id="新的开始"><a href="#新的开始" class="headerlink" title="新的开始"></a>新的开始</h3><p>我准备了好久，台灯、书、杯子，等了也好久，毕设、论文、答辩，终于，在这个孤独的城市里，我要享受我的孤独。</p><p>正好今天也是我的生日，就让今天成为我新的开始吧！<br><img src="/img/IMG_20160426_210112.jpg" srcset="/img/loading.gif" alt="..." width="600"></p><h3 id="A计划"><a href="#A计划" class="headerlink" title="A计划"></a>A计划</h3><ul><li>读书，读闲书。</li><li>写博客</li><li>学习JVM</li><li>学习Android APP开发</li><li>学习C/C++</li><li>研究算法</li><li>学习数学</li><li>写写画画</li></ul><h3 id="作息时间"><a href="#作息时间" class="headerlink" title="作息时间"></a>作息时间</h3><ul><li>夏天来了，早睡早起 </li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>生活</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第一次面试</title>
    <link href="/2015/11/11/%E7%AC%AC%E4%B8%80%E6%AC%A1%E9%9D%A2%E8%AF%95/"/>
    <url>/2015/11/11/%E7%AC%AC%E4%B8%80%E6%AC%A1%E9%9D%A2%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<p>刚来北京的时候，第一个星期，收到的两次面试邀请，后来还去了其他的校招，最后加入了VINCI。不知道能在这里呆多久。面试是一个相互选择的过程，感觉面试时需要的交流能力要大于技术能力，当然两者也是相辅相成的。</p><a id="more"></a><p>以下是我当时的笔记。</p><h3 id="VINCI"><a href="#VINCI" class="headerlink" title="VINCI"></a>VINCI</h3><blockquote><p>早上 11：00，不是特别好找，一个院子里，创业型公司，环境还可以，一起办公的那种，待遇250/day<br>面试官挺好的，随和。现在是我老大了。</p><ul><li>handler是怎么实现的，postAtTime是怎么定时的</li><li>多线程同时操作一个列表，如何线程安全</li><li>如何返回登陆界面（就是关闭其他的activity,打开登陆界面）</li></ul></blockquote><h3 id="零用钱"><a href="#零用钱" class="headerlink" title="零用钱"></a>零用钱</h3><blockquote><p>下午 3：00，不是特别好找，在21楼一个房间，创业型公司，一个大牛，做ios android，问的问题挺难<br>大牛就是大牛。</p><ul><li>Java反射用过吗，什么原理，怎么用的</li><li>怎么自定义注解</li><li>你常用的设计模式</li><li>写个单例模式</li><li>单例模式如何保证线程安全</li><li>线程安全了，效率会下降，怎么办</li><li>如何用两个栈实现一个队列</li><li>对于一个大文件，如何找出出现次数最多的一行，在效率最高的情况下</li><li>多个线程怎么管理维护</li><li>asynctask实现机制</li><li>感觉说自己有阅读源码的习惯是给自己找坑呢</li><li>断点续传怎么搞</li><li>多线程下载怎么搞</li></ul></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
